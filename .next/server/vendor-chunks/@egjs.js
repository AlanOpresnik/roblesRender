"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@egjs";
exports.ids = ["vendor-chunks/@egjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@egjs/component/dist/component.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/@egjs/component/dist/component.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentEvent: () => (/* binding */ ComponentEvent$1),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\nCopyright (c) NAVER Corp.\nname: @egjs/component\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-component\nversion: 3.0.5\n*/ /*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nfunction __spread() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));\n    return ar;\n}\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */ var isUndefined = function(value) {\n    return typeof value === \"undefined\";\n};\n// This class name is not matched to file name intentionally\n/**\n * Event class to provide additional properties\n * @ko Component에서 추가적인 프로퍼티를 제공하는 이벤트 클래스\n */ var ComponentEvent = /*#__PURE__*/ function() {\n    /**\n   * Create a new instance of ComponentEvent.\n   * @ko ComponentEvent의 새로운 인스턴스를 생성한다.\n   * @param eventType The name of the event.<ko>이벤트 이름.</ko>\n   * @param props An object that contains additional event properties.<ko>추가적인 이벤트 프로퍼티 오브젝트.</ko>\n   */ function ComponentEvent(eventType, props) {\n        var e_1, _a;\n        this._canceled = false;\n        if (props) {\n            try {\n                for(var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()){\n                    var key = _c.value;\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    this[key] = props[key];\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        this.eventType = eventType;\n    }\n    /**\n   * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.\n   * @ko 이벤트를 중단한다. 이후 {@link ComponentEvent#isCanceled}가 `true`를 반환한다.\n   */ var __proto = ComponentEvent.prototype;\n    __proto.stop = function() {\n        this._canceled = true;\n    };\n    /**\n   * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.\n   * @ko {@link ComponentEvent#stop}이 호출되었는지 여부를 반환한다.\n   * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko>이전에 {@link ComponentEvent#stop}이 불려졌는지 여부를 반환한다.</ko>\n   */ __proto.isCanceled = function() {\n        return this._canceled;\n    };\n    return ComponentEvent;\n}();\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n */ var Component = /*#__PURE__*/ function() {\n    /**\n   * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n   */ function Component() {\n        this._eventHandler = {};\n    }\n    /**\n   * Trigger a custom event.\n   * @ko 커스텀 이벤트를 발생시킨다\n   * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>발생할 커스텀 이벤트의 이름 또는 ComponentEvent의 인스턴스</ko>\n   * @param {any[]} params Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;\n   *   hi: { foo: { a: number; b: boolean } };\n   *   someEvent: (foo: number, bar: string) => void;\n   *   someOtherEvent: void; // When there's no event argument\n   * }> {\n   *   some(){\n   *     if(this.trigger(\"beforeHi\")){ // When event call to stop return false.\n   *       this.trigger(\"hi\");// fire hi event.\n   *     }\n   *   }\n   * }\n   *\n   * const some = new Some();\n   * some.on(\"beforeHi\", e => {\n   *   if(condition){\n   *     e.stop(); // When event call to stop, `hi` event not call.\n   *   }\n   *   // `currentTarget` is component instance.\n   *   console.log(some === e.currentTarget); // true\n   *\n   *   typeof e.foo; // number\n   *   typeof e.bar; // string\n   * });\n   * some.on(\"hi\", e => {\n   *   typeof e.foo.b; // boolean\n   * });\n   * // If you want to more know event design. You can see article.\n   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n   * ```\n   */ var __proto = Component.prototype;\n    __proto.trigger = function(event) {\n        var params = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            params[_i - 1] = arguments[_i];\n        }\n        var eventName = event instanceof ComponentEvent ? event.eventType : event;\n        var handlers = __spread(this._eventHandler[eventName] || []);\n        if (handlers.length <= 0) {\n            return this;\n        }\n        if (event instanceof ComponentEvent) {\n            event.currentTarget = this;\n            handlers.forEach(function(handler) {\n                handler(event);\n            });\n        } else {\n            handlers.forEach(function(handler) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                handler.apply(void 0, __spread(params));\n            });\n        }\n        return this;\n    };\n    /**\n   * Executed event just one time.\n   * @ko 이벤트가 한번만 실행된다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: ComponentEvent;\n   * }> {\n   *   hi() {\n   *     alert(\"hi\");\n   *   }\n   *   thing() {\n   *     this.once(\"hi\", this.hi);\n   *   }\n   * }\n   *\n   * var some = new Some();\n   * some.thing();\n   * some.trigger(new ComponentEvent(\"hi\"));\n   * // fire alert(\"hi\");\n   * some.trigger(new ComponentEvent(\"hi\"));\n   * // Nothing happens\n   * ```\n   */ __proto.once = function(eventName, handlerToAttach) {\n        var _this = this;\n        if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n            var eventHash = eventName;\n            for(var key in eventHash){\n                this.once(key, eventHash[key]);\n            }\n            return this;\n        } else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n            var listener_1 = function() {\n                var args = [];\n                for(var _i = 0; _i < arguments.length; _i++){\n                    args[_i] = arguments[_i];\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                handlerToAttach.apply(void 0, __spread(args));\n                _this.off(eventName, listener_1);\n            };\n            this.on(eventName, listener_1);\n        }\n        return this;\n    };\n    /**\n   * Checks whether an event has been attached to a component.\n   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n   * @example\n   * ```ts\n   * import Component from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   some() {\n   *     this.hasOn(\"hi\");// check hi event.\n   *   }\n   * }\n   * ```\n   */ __proto.hasOn = function(eventName) {\n        return !!this._eventHandler[eventName];\n    };\n    /**\n   * Attaches an event to a component.\n   * @ko 컴포넌트에 이벤트를 등록한다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.on(\"hi\",this.hi); //attach event\n   *   }\n   * }\n   * ```\n   */ __proto.on = function(eventName, handlerToAttach) {\n        if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n            var eventHash = eventName;\n            for(var name in eventHash){\n                this.on(name, eventHash[name]);\n            }\n            return this;\n        } else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n            var handlerList = this._eventHandler[eventName];\n            if (isUndefined(handlerList)) {\n                this._eventHandler[eventName] = [];\n                handlerList = this._eventHandler[eventName];\n            }\n            handlerList.push(handlerToAttach);\n        }\n        return this;\n    };\n    /**\n   * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.\n   * @ko 컴포넌트에 등록된 이벤트를 해제한다.<br/>`eventName`이 주어지지 않았을 경우 모든 이벤트 핸들러를 제거한다.<br/>`handlerToAttach`가 주어지지 않았을 경우 `eventName`에 해당하는 모든 이벤트 핸들러를 제거한다.\n   * @param {string?} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n   * @param {function?} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.off(\"hi\",this.hi); //detach event\n   *   }\n   * }\n   * ```\n   */ __proto.off = function(eventName, handlerToDetach) {\n        // Detach all event handlers.\n        if (isUndefined(eventName)) {\n            this._eventHandler = {};\n            return this;\n        }\n        // Detach all handlers for eventname or detach event handlers by object.\n        if (isUndefined(handlerToDetach)) {\n            if (typeof eventName === \"string\") {\n                delete this._eventHandler[eventName];\n                return this;\n            } else {\n                var eventHash = eventName;\n                for(var name in eventHash){\n                    this.off(name, eventHash[name]);\n                }\n                return this;\n            }\n        }\n        // Detach single event handler\n        var handlerList = this._eventHandler[eventName];\n        if (handlerList) {\n            var length = handlerList.length;\n            for(var i = 0; i < length; ++i){\n                if (handlerList[i] === handlerToDetach) {\n                    handlerList.splice(i, 1);\n                    if (length <= 1) {\n                        delete this._eventHandler[eventName];\n                    }\n                    break;\n                }\n            }\n        }\n        return this;\n    };\n    /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @example\n   * Component.VERSION;  // ex) 3.0.0\n   * @memberof Component\n   */ Component.VERSION = \"3.0.5\";\n    return Component;\n}();\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */ // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-assignment\nvar ComponentEvent$1 = ComponentEvent;\n/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */ /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);\n //# sourceMappingURL=component.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvY29tcG9uZW50L2Rpc3QvY29tcG9uZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7O0FBT0EsR0FDQTs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsU0FBU0EsU0FBU0MsQ0FBQztJQUNqQixJQUFJQyxJQUFJLE9BQU9DLFdBQVcsY0FBY0EsT0FBT0MsUUFBUSxFQUNyREMsSUFBSUgsS0FBS0QsQ0FBQyxDQUFDQyxFQUFFLEVBQ2JJLElBQUk7SUFDTixJQUFJRCxHQUFHLE9BQU9BLEVBQUVFLElBQUksQ0FBQ047SUFDckIsSUFBSUEsS0FBSyxPQUFPQSxFQUFFTyxNQUFNLEtBQUssVUFBVSxPQUFPO1FBQzVDQyxNQUFNO1lBQ0osSUFBSVIsS0FBS0ssS0FBS0wsRUFBRU8sTUFBTSxFQUFFUCxJQUFJLEtBQUs7WUFDakMsT0FBTztnQkFDTFMsT0FBT1QsS0FBS0EsQ0FBQyxDQUFDSyxJQUFJO2dCQUNsQkssTUFBTSxDQUFDVjtZQUNUO1FBQ0Y7SUFDRjtJQUNBLE1BQU0sSUFBSVcsVUFBVVYsSUFBSSw0QkFBNEI7QUFDdEQ7QUFDQSxTQUFTVyxPQUFPWixDQUFDLEVBQUVhLENBQUM7SUFDbEIsSUFBSVQsSUFBSSxPQUFPRixXQUFXLGNBQWNGLENBQUMsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDO0lBQzFELElBQUksQ0FBQ0MsR0FBRyxPQUFPSjtJQUNmLElBQUlLLElBQUlELEVBQUVFLElBQUksQ0FBQ04sSUFDYmMsR0FDQUMsS0FBSyxFQUFFLEVBQ1BDO0lBQ0YsSUFBSTtRQUNGLE1BQU8sQ0FBQ0gsTUFBTSxLQUFLLEtBQUtBLE1BQU0sTUFBTSxDQUFDLENBQUNDLElBQUlULEVBQUVHLElBQUksRUFBQyxFQUFHRSxJQUFJLENBQUVLLEdBQUdFLElBQUksQ0FBQ0gsRUFBRUwsS0FBSztJQUMzRSxFQUFFLE9BQU9TLE9BQU87UUFDZEYsSUFBSTtZQUNGRSxPQUFPQTtRQUNUO0lBQ0YsU0FBVTtRQUNS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U0FBUyxDQUFDTSxLQUFLO2dCQUNoQztnQkFDQSxPQUFPLElBQUk7WUFDYjtRQUNGO1FBQ0EsOEJBQThCO1FBQzlCLElBQUlDLGNBQWMsSUFBSSxDQUFDckIsYUFBYSxDQUFDSyxVQUFVO1FBQy9DLElBQUlnQixhQUFhO1lBQ2YsSUFBSXZELFNBQVN1RCxZQUFZdkQsTUFBTTtZQUMvQixJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSUUsUUFBUSxFQUFFRixFQUFHO2dCQUMvQixJQUFJeUQsV0FBVyxDQUFDekQsRUFBRSxLQUFLMEQsaUJBQWlCO29CQUN0Q0QsWUFBWUUsTUFBTSxDQUFDM0QsR0FBRztvQkFDdEIsSUFBSUUsVUFBVSxHQUFHO3dCQUNmLE9BQU8sSUFBSSxDQUFDa0MsYUFBYSxDQUFDSyxVQUFVO29CQUN0QztvQkFDQTtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBOzs7Ozs7OztHQVFDLEdBQ0ROLFVBQVV5QixPQUFPLEdBQUc7SUFDcEIsT0FBT3pCO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCx5R0FBeUc7QUFDekcsSUFBSTBCLG1CQUFtQjNDO0FBRXZCOzs7Q0FHQyxHQUVELGlFQUFlaUIsU0FBU0EsRUFBQztBQUNxQixDQUM5Qyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yb2JsZXMtcmVuZGVyLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL2NvbXBvbmVudC9kaXN0L2NvbXBvbmVudC5lc20uanM/YThiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvY29tcG9uZW50XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNvbXBvbmVudFxudmVyc2lvbjogMy4wLjVcbiovXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsXG4gICAgbSA9IHMgJiYgb1tzXSxcbiAgICBpID0gMDtcbiAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG8gJiYgb1tpKytdLFxuICAgICAgICBkb25lOiAhb1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksXG4gICAgcixcbiAgICBhciA9IFtdLFxuICAgIGU7XG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufTtcblxuLy8gVGhpcyBjbGFzcyBuYW1lIGlzIG5vdCBtYXRjaGVkIHRvIGZpbGUgbmFtZSBpbnRlbnRpb25hbGx5XG4vKipcbiAqIEV2ZW50IGNsYXNzIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAa28gQ29tcG9uZW507JeQ7IScIOy2lOqwgOyggeyduCDtlITroZztjbzti7Drpbwg7KCc6rO17ZWY64qUIOydtOuypO2KuCDtgbTrnpjsiqRcbiAqL1xudmFyIENvbXBvbmVudEV2ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBDb21wb25lbnRFdmVudC5cbiAgICogQGtvIENvbXBvbmVudEV2ZW507J2YIOyDiOuhnOyatCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWc64ukLlxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudC48a28+7J2067Kk7Yq4IOydtOumhC48L2tvPlxuICAgKiBAcGFyYW0gcHJvcHMgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYWRkaXRpb25hbCBldmVudCBwcm9wZXJ0aWVzLjxrbz7stpTqsIDsoIHsnbgg7J2067Kk7Yq4IO2UhOuhnO2NvO2LsCDsmKTruIzsoJ3tirguPC9rbz5cbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudEV2ZW50KGV2ZW50VHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhwcm9wcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGV2ZW50LiB7QGxpbmsgQ29tcG9uZW50RXZlbnQjaXNDYW5jZWxlZH0gd2lsbCByZXR1cm4gYHRydWVgIGFmdGVyLlxuICAgKiBAa28g7J2067Kk7Yq466W8IOykkeuLqO2VnOuLpC4g7J207ZuEIHtAbGluayBDb21wb25lbnRFdmVudCNpc0NhbmNlbGVkfeqwgCBgdHJ1ZWDrpbwg67CY7ZmY7ZWc64ukLlxuICAgKi9cbiAgdmFyIF9fcHJvdG8gPSBDb21wb25lbnRFdmVudC5wcm90b3R5cGU7XG4gIF9fcHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfSBpcyBjYWxsZWQgYmVmb3JlLlxuICAgKiBAa28ge0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B97J20IO2YuOy2nOuQmOyXiOuKlOyngCDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgQ29tcG9uZW50RXZlbnQjc3RvcH0gaXMgY2FsbGVkIGJlZm9yZS48a28+7J207KCE7JeQIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfeydtCDrtojroKTsoYzripTsp4Ag7Jes67aA66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKi9cbiAgX19wcm90by5pc0NhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxlZDtcbiAgfTtcbiAgcmV0dXJuIENvbXBvbmVudEV2ZW50O1xufSgpO1xuXG4vKipcbiAqIEEgY2xhc3MgdXNlZCB0byBtYW5hZ2UgZXZlbnRzIGluIGEgY29tcG9uZW50XG4gKiBAa28g7Lu07Y+s64SM7Yq47J2YIOydtOuypO2KuOydhCDqtIDrpqztlaAg7IiYIOyeiOqyjCDtlZjripQg7YG0656Y7IqkXG4gKi9cbnZhciBDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHN1cHBvcnQge1wiaWVcIjogXCI3K1wiLCBcImNoXCIgOiBcImxhdGVzdFwiLCBcImZmXCIgOiBcImxhdGVzdFwiLCAgXCJzZlwiIDogXCJsYXRlc3RcIiwgXCJlZGdlXCIgOiBcImxhdGVzdFwiLCBcImlvc1wiIDogXCI3K1wiLCBcImFuXCIgOiBcIjIuMSsgKGV4Y2VwdCAzLngpXCJ9XG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBjdXN0b20gZXZlbnQuXG4gICAqIEBrbyDsu6TsiqTthYAg7J2067Kk7Yq466W8IOuwnOyDneyLnO2CqOuLpFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IENvbXBvbmVudEV2ZW50fSBldmVudCBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IHRvIGJlIHRyaWdnZXJlZCBvciBhbiBpbnN0YW5jZSBvZiB0aGUgQ29tcG9uZW50RXZlbnQ8a28+67Cc7IOd7ZWgIOy7pOyKpO2FgCDsnbTrsqTtirjsnZgg7J2066aEIOuYkOuKlCBDb21wb25lbnRFdmVudOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAcGFyYW0ge2FueVtdfSBwYXJhbXMgRXZlbnQgZGF0YSB0byBiZSBzZW50IHdoZW4gdHJpZ2dlcmluZyBhIGN1c3RvbSBldmVudCA8a28+7Luk7Iqk7YWAIOydtOuypO2KuOqwgCDrsJzsg53tlaAg65WMIOyghOuLrO2VoCDrjbDsnbTthLA8L2tvPlxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgYmVmb3JlSGk6IENvbXBvbmVudEV2ZW50PHsgZm9vOiBudW1iZXI7IGJhcjogc3RyaW5nIH0+O1xuICAgKiAgIGhpOiB7IGZvbzogeyBhOiBudW1iZXI7IGI6IGJvb2xlYW4gfSB9O1xuICAgKiAgIHNvbWVFdmVudDogKGZvbzogbnVtYmVyLCBiYXI6IHN0cmluZykgPT4gdm9pZDtcbiAgICogICBzb21lT3RoZXJFdmVudDogdm9pZDsgLy8gV2hlbiB0aGVyZSdzIG5vIGV2ZW50IGFyZ3VtZW50XG4gICAqIH0+IHtcbiAgICogICBzb21lKCl7XG4gICAqICAgICBpZih0aGlzLnRyaWdnZXIoXCJiZWZvcmVIaVwiKSl7IC8vIFdoZW4gZXZlbnQgY2FsbCB0byBzdG9wIHJldHVybiBmYWxzZS5cbiAgICogICAgICAgdGhpcy50cmlnZ2VyKFwiaGlcIik7Ly8gZmlyZSBoaSBldmVudC5cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgc29tZSA9IG5ldyBTb21lKCk7XG4gICAqIHNvbWUub24oXCJiZWZvcmVIaVwiLCBlID0+IHtcbiAgICogICBpZihjb25kaXRpb24pe1xuICAgKiAgICAgZS5zdG9wKCk7IC8vIFdoZW4gZXZlbnQgY2FsbCB0byBzdG9wLCBgaGlgIGV2ZW50IG5vdCBjYWxsLlxuICAgKiAgIH1cbiAgICogICAvLyBgY3VycmVudFRhcmdldGAgaXMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiAgIGNvbnNvbGUubG9nKHNvbWUgPT09IGUuY3VycmVudFRhcmdldCk7IC8vIHRydWVcbiAgICpcbiAgICogICB0eXBlb2YgZS5mb287IC8vIG51bWJlclxuICAgKiAgIHR5cGVvZiBlLmJhcjsgLy8gc3RyaW5nXG4gICAqIH0pO1xuICAgKiBzb21lLm9uKFwiaGlcIiwgZSA9PiB7XG4gICAqICAgdHlwZW9mIGUuZm9vLmI7IC8vIGJvb2xlYW5cbiAgICogfSk7XG4gICAqIC8vIElmIHlvdSB3YW50IHRvIG1vcmUga25vdyBldmVudCBkZXNpZ24uIFlvdSBjYW4gc2VlIGFydGljbGUuXG4gICAqIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNvbXBvbmVudC93aWtpL0hvdy10by1tYWtlLUNvbXBvbmVudC1ldmVudC1kZXNpZ24lM0ZcbiAgICogYGBgXG4gICAqL1xuICB2YXIgX19wcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIF9fcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQgaW5zdGFuY2VvZiBDb21wb25lbnRFdmVudCA/IGV2ZW50LmV2ZW50VHlwZSA6IGV2ZW50O1xuICAgIHZhciBoYW5kbGVycyA9IF9fc3ByZWFkKHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdIHx8IFtdKTtcbiAgICBpZiAoaGFuZGxlcnMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBDb21wb25lbnRFdmVudCkge1xuICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQocGFyYW1zKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBFeGVjdXRlZCBldmVudCBqdXN0IG9uZSB0aW1lLlxuICAgKiBAa28g7J2067Kk7Yq46rCAIO2VnOuyiOunjCDsi6TtlonrkJzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIG9yIGFuIGV2ZW50IG5hbWUgLSBldmVudCBoYW5kbGVyIG1hcHBlZCBvYmplY3QuPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7J2066aEIOuYkOuKlCDsnbTrsqTtirgg7J2066aELe2VuOuTpOufrCDsmKTruIzsoJ3tirg8L2tvPlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyVG9BdHRhY2ggVGhlIGhhbmRsZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIO2VuOuTpOufrCDtlajsiJg8L2tvPlxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IENvbXBvbmVudEV2ZW50O1xuICAgKiB9PiB7XG4gICAqICAgaGkoKSB7XG4gICAqICAgICBhbGVydChcImhpXCIpO1xuICAgKiAgIH1cbiAgICogICB0aGluZygpIHtcbiAgICogICAgIHRoaXMub25jZShcImhpXCIsIHRoaXMuaGkpO1xuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiB2YXIgc29tZSA9IG5ldyBTb21lKCk7XG4gICAqIHNvbWUudGhpbmcoKTtcbiAgICogc29tZS50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudChcImhpXCIpKTtcbiAgICogLy8gZmlyZSBhbGVydChcImhpXCIpO1xuICAgKiBzb21lLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50KFwiaGlcIikpO1xuICAgKiAvLyBOb3RoaW5nIGhhcHBlbnNcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyVG9BdHRhY2gpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcIm9iamVjdFwiICYmIGlzVW5kZWZpbmVkKGhhbmRsZXJUb0F0dGFjaCkpIHtcbiAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgIHRoaXMub25jZShrZXksIGV2ZW50SGFzaFtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaGFuZGxlclRvQXR0YWNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBsaXN0ZW5lcl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgIGhhbmRsZXJUb0F0dGFjaC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKGFyZ3MpKTtcbiAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXJfMSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGFuIGV2ZW50IGhhcyBiZWVuIGF0dGFjaGVkIHRvIGEgY29tcG9uZW50LlxuICAgKiBAa28g7Lu07Y+s64SM7Yq47JeQIOydtOuypO2KuOqwgCDrk7HroZ3rkJDripTsp4Ag7ZmV7J247ZWc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66GdIOyXrOu2gOulvCDtmZXsnbjtlaAg7J2067Kk7Yq47J2YIOydtOumhDwva28+XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCBpcyBhdHRhY2hlZC4gPGtvPuydtOuypO2KuCDrk7HroZ0g7Jes67aAPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGhpOiB2b2lkO1xuICAgKiB9PiB7XG4gICAqICAgc29tZSgpIHtcbiAgICogICAgIHRoaXMuaGFzT24oXCJoaVwiKTsvLyBjaGVjayBoaSBldmVudC5cbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLmhhc09uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICB9O1xuICAvKipcbiAgICogQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBjb21wb25lbnQuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag7J2067Kk7Yq466W8IOuTseuhne2VnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgb3IgYW4gZXZlbnQgbmFtZSAtIGV2ZW50IGhhbmRsZXIgbWFwcGVkIG9iamVjdC48a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDsnbTrpoQg65iQ64qUIOydtOuypO2KuCDsnbTrpoQt7ZW465Ok65+sIOyYpOu4jOygne2KuDwva28+XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJUb0F0dGFjaCBUaGUgaGFuZGxlciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7ZW465Ok65+sIO2VqOyImDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHNvbWUoKSB7XG4gICAqICAgICB0aGlzLm9uKFwiaGlcIix0aGlzLmhpKTsgLy9hdHRhY2ggZXZlbnRcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlclRvQXR0YWNoKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwib2JqZWN0XCIgJiYgaXNVbmRlZmluZWQoaGFuZGxlclRvQXR0YWNoKSkge1xuICAgICAgdmFyIGV2ZW50SGFzaCA9IGV2ZW50TmFtZTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgIHRoaXMub24obmFtZSwgZXZlbnRIYXNoW25hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaGFuZGxlclRvQXR0YWNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXJMaXN0KSkge1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgfVxuICAgICAgaGFuZGxlckxpc3QucHVzaChoYW5kbGVyVG9BdHRhY2gpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERldGFjaGVzIGFuIGV2ZW50IGZyb20gdGhlIGNvbXBvbmVudC48YnIvPklmIHRoZSBgZXZlbnROYW1lYCBpcyBub3QgZ2l2ZW4gdGhpcyB3aWxsIGRldGFjaCBhbGwgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQuPGJyLz5JZiB0aGUgYGhhbmRsZXJUb0RldGFjaGAgaXMgbm90IGdpdmVuLCB0aGlzIHdpbGwgZGV0YWNoIGFsbCBldmVudCBoYW5kbGVycyBmb3IgYGV2ZW50TmFtZWAuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag65Ox66Gd65CcIOydtOuypO2KuOulvCDtlbTsoJztlZzri6QuPGJyLz5gZXZlbnROYW1lYOydtCDso7zslrTsp4Dsp4Ag7JWK7JWY7J2EIOqyveyasCDrqqjrk6Ag7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJzqsbDtlZzri6QuPGJyLz5gaGFuZGxlclRvQXR0YWNoYOqwgCDso7zslrTsp4Dsp4Ag7JWK7JWY7J2EIOqyveyasCBgZXZlbnROYW1lYOyXkCDtlbTri7ntlZjripQg66qo65OgIOydtOuypO2KuCDtlbjrk6Trn6zrpbwg7KCc6rGw7ZWc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZz99IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgZGV0YWNoZWQgPGtvPu2VtOygnO2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbj99IGhhbmRsZXJUb0RldGFjaCBUaGUgaGFuZGxlciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgZGV0YWNoZWQgPGtvPu2VtOygnO2VoCDsnbTrsqTtirjsnZgg7ZW465Ok65+sIO2VqOyImDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgaXRzZWxmIDxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQsIHsgQ29tcG9uZW50RXZlbnQgfSBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGhpOiB2b2lkO1xuICAgKiB9PiB7XG4gICAqICAgaGkoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcImhpXCIpO1xuICAgKiAgIH1cbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5vZmYoXCJoaVwiLHRoaXMuaGkpOyAvL2RldGFjaCBldmVudFxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8ub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlclRvRGV0YWNoKSB7XG4gICAgLy8gRGV0YWNoIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICBpZiAoaXNVbmRlZmluZWQoZXZlbnROYW1lKSkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gRGV0YWNoIGFsbCBoYW5kbGVycyBmb3IgZXZlbnRuYW1lIG9yIGRldGFjaCBldmVudCBoYW5kbGVycyBieSBvYmplY3QuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXJUb0RldGFjaCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50SGFzaCkge1xuICAgICAgICAgIHRoaXMub2ZmKG5hbWUsIGV2ZW50SGFzaFtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERldGFjaCBzaW5nbGUgZXZlbnQgaGFuZGxlclxuICAgIHZhciBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyTGlzdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGhhbmRsZXJMaXN0Lmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGhhbmRsZXJMaXN0W2ldID09PSBoYW5kbGVyVG9EZXRhY2gpIHtcbiAgICAgICAgICBoYW5kbGVyTGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogVmVyc2lvbiBpbmZvIHN0cmluZ1xuICAgKiBAa28g67KE7KCE7KCV67O0IOusuOyekOyXtFxuICAgKiBAbmFtZSBWRVJTSU9OXG4gICAqIEBzdGF0aWNcbiAgICogQGV4YW1wbGVcbiAgICogQ29tcG9uZW50LlZFUlNJT047ICAvLyBleCkgMy4wLjBcbiAgICogQG1lbWJlcm9mIENvbXBvbmVudFxuICAgKi9cbiAgQ29tcG9uZW50LlZFUlNJT04gPSBcIjMuMC41XCI7XG4gIHJldHVybiBDb21wb25lbnQ7XG59KCk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbnZhciBDb21wb25lbnRFdmVudCQxID0gQ29tcG9uZW50RXZlbnQ7XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbmV4cG9ydCB7IENvbXBvbmVudEV2ZW50JDEgYXMgQ29tcG9uZW50RXZlbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiX192YWx1ZXMiLCJvIiwicyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibSIsImkiLCJjYWxsIiwibGVuZ3RoIiwibmV4dCIsInZhbHVlIiwiZG9uZSIsIlR5cGVFcnJvciIsIl9fcmVhZCIsIm4iLCJyIiwiYXIiLCJlIiwicHVzaCIsImVycm9yIiwiX19zcHJlYWQiLCJhcmd1bWVudHMiLCJjb25jYXQiLCJpc1VuZGVmaW5lZCIsIkNvbXBvbmVudEV2ZW50IiwiZXZlbnRUeXBlIiwicHJvcHMiLCJlXzEiLCJfYSIsIl9jYW5jZWxlZCIsIl9iIiwiT2JqZWN0Iiwia2V5cyIsIl9jIiwia2V5IiwiZV8xXzEiLCJyZXR1cm4iLCJfX3Byb3RvIiwicHJvdG90eXBlIiwic3RvcCIsImlzQ2FuY2VsZWQiLCJDb21wb25lbnQiLCJfZXZlbnRIYW5kbGVyIiwidHJpZ2dlciIsImV2ZW50IiwicGFyYW1zIiwiX2kiLCJldmVudE5hbWUiLCJoYW5kbGVycyIsImN1cnJlbnRUYXJnZXQiLCJmb3JFYWNoIiwiaGFuZGxlciIsImFwcGx5Iiwib25jZSIsImhhbmRsZXJUb0F0dGFjaCIsIl90aGlzIiwiZXZlbnRIYXNoIiwibGlzdGVuZXJfMSIsImFyZ3MiLCJvZmYiLCJvbiIsImhhc09uIiwibmFtZSIsImhhbmRsZXJMaXN0IiwiaGFuZGxlclRvRGV0YWNoIiwic3BsaWNlIiwiVkVSU0lPTiIsIkNvbXBvbmVudEV2ZW50JDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/component/dist/component.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@egjs/imready/dist/imready.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@egjs/imready/dist/imready.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EVENTS: () => (/* binding */ EVENTS),\n/* harmony export */   ImageLoader: () => (/* binding */ ImageLoader),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Manager: () => (/* binding */ ImReadyManager),\n/* harmony export */   PROPS: () => (/* binding */ PROPS),\n/* harmony export */   REACTIVE_IMREADY: () => (/* binding */ REACTIVE_IMREADY),\n/* harmony export */   VideoLoader: () => (/* binding */ VideoLoader),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _egjs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @egjs/component */ \"(ssr)/./node_modules/@egjs/component/dist/component.esm.js\");\n/* harmony import */ var _cfcs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cfcs/core */ \"(ssr)/./node_modules/@cfcs/core/dist/cfcs.esm.js\");\n/*\nCopyright (c) NAVER Corp.\nname: @egjs/imready\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-imready\nversion: 1.4.1\n*/ \n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/** @deprecated */ function __spreadArrays() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\n/*\negjs-imready\nCopyright (c) 2020-present NAVER Corp.\nMIT license\n*/ var isWindow = \"undefined\" !== \"undefined\";\nvar ua = isWindow ? window.navigator.userAgent : \"\";\nvar SUPPORT_COMPUTEDSTYLE = isWindow ? !!(\"getComputedStyle\" in window) : false;\nvar IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nvar SUPPORT_ADDEVENTLISTENER = isWindow ? !!(\"addEventListener\" in document) : false;\nvar WIDTH = \"width\";\nvar HEIGHT = \"height\";\nvar PROPS = [\n    \"prefix\",\n    \"loaders\"\n];\nvar EVENTS = [\n    \"preReadyElement\",\n    \"readyElement\",\n    \"error\",\n    \"preReady\",\n    \"ready\"\n];\nfunction getAttribute(el, name) {\n    return el.getAttribute(name) || \"\";\n}\nfunction toArray(arr) {\n    return [].slice.call(arr);\n}\nfunction hasSizeAttribute(target, prefix) {\n    if (prefix === void 0) {\n        prefix = \"data-\";\n    }\n    return !!target.getAttribute(prefix + \"width\");\n}\nfunction hasLoadingAttribute(target, prefix) {\n    if (prefix === void 0) {\n        prefix = \"data-\";\n    }\n    return \"loading\" in target && target.getAttribute(\"loading\") === \"lazy\" || !!target.getAttribute(prefix + \"lazy\");\n}\nfunction hasSkipAttribute(target, prefix) {\n    if (prefix === void 0) {\n        prefix = \"data-\";\n    }\n    return !!target.getAttribute(prefix + \"skip\");\n}\nfunction addEvent(element, type, handler) {\n    if (SUPPORT_ADDEVENTLISTENER) {\n        element.addEventListener(type, handler, false);\n    } else if (element.attachEvent) {\n        element.attachEvent(\"on\" + type, handler);\n    } else {\n        element[\"on\" + type] = handler;\n    }\n}\nfunction removeEvent(element, type, handler) {\n    if (element.removeEventListener) {\n        element.removeEventListener(type, handler, false);\n    } else if (element.detachEvent) {\n        element.detachEvent(\"on\" + type, handler);\n    } else {\n        element[\"on\" + type] = null;\n    }\n}\nfunction innerWidth(el) {\n    return getSize(el, \"Width\");\n}\nfunction innerHeight(el) {\n    return getSize(el, \"Height\");\n}\nfunction getStyles(el) {\n    return (SUPPORT_COMPUTEDSTYLE ? window.getComputedStyle(el) : el.currentStyle) || {};\n}\nfunction getSize(el, name) {\n    var size = el[\"client\" + name] || el[\"offset\" + name];\n    return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;\n}\nfunction getContentElements(element, tags, prefix) {\n    var skipElements = toArray(element.querySelectorAll(__spreadArrays([\n        \"[\" + prefix + \"skip] [\" + prefix + \"width]\"\n    ], tags.map(function(tag) {\n        return [\n            \"[\" + prefix + \"skip] \" + tag,\n            tag + \"[\" + prefix + \"skip]\",\n            \"[\" + prefix + \"width] \" + tag\n        ].join(\", \");\n    })).join(\", \")));\n    return toArray(element.querySelectorAll(\"[\" + prefix + \"width], \" + tags.join(\", \"))).filter(function(el) {\n        return skipElements.indexOf(el) === -1;\n    });\n}\n/*\negjs-imready\nCopyright (c) 2020-present NAVER Corp.\nMIT license\n*/ var elements = [];\nfunction addAutoSizer(element, prefix) {\n    !elements.length && addEvent(window, \"resize\", resizeAllAutoSizers);\n    element.__PREFIX__ = prefix;\n    elements.push(element);\n    resize(element);\n}\nfunction removeAutoSizer(element, prefix) {\n    var index = elements.indexOf(element);\n    if (index < 0) {\n        return;\n    }\n    var fixed = getAttribute(element, prefix + \"fixed\");\n    delete element.__PREFIX__;\n    element.style[fixed === HEIGHT ? WIDTH : HEIGHT] = \"\";\n    elements.splice(index, 1);\n    !elements.length && removeEvent(window, \"resize\", resizeAllAutoSizers);\n}\nfunction resize(element, prefix) {\n    if (prefix === void 0) {\n        prefix = \"data-\";\n    }\n    var elementPrefix = element.__PREFIX__ || prefix;\n    var dataWidth = parseInt(getAttribute(element, \"\" + elementPrefix + WIDTH), 10) || 0;\n    var dataHeight = parseInt(getAttribute(element, \"\" + elementPrefix + HEIGHT), 10) || 0;\n    var fixed = getAttribute(element, elementPrefix + \"fixed\");\n    if (fixed === HEIGHT) {\n        var size = innerHeight(element) || dataHeight;\n        element.style[WIDTH] = dataWidth / dataHeight * size + \"px\";\n    } else {\n        var size = innerWidth(element) || dataWidth;\n        element.style[HEIGHT] = dataHeight / dataWidth * size + \"px\";\n    }\n}\nfunction resizeAllAutoSizers() {\n    elements.forEach(function(element) {\n        resize(element);\n    });\n}\nvar Loader = /*#__PURE__*/ function(_super) {\n    __extends(Loader, _super);\n    function Loader(element, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _this = _super.call(this) || this;\n        _this.isReady = false;\n        _this.isPreReady = false;\n        _this.hasDataSize = false;\n        _this.hasLoading = false;\n        _this.isSkip = false;\n        _this.onCheck = function(e) {\n            _this.clear();\n            if (e && e.type === \"error\") {\n                _this.onError(_this.element);\n            }\n            if (_this.hasLoading && _this.checkElement()) {\n                // I'm not ready\n                return;\n            }\n            // I'm pre-ready and ready!\n            var withPreReady = !_this.hasDataSize && !_this.hasLoading;\n            _this.onReady(withPreReady);\n        };\n        _this.options = __assign({\n            prefix: \"data-\"\n        }, options);\n        _this.element = element;\n        var prefix = _this.options.prefix;\n        _this.hasDataSize = hasSizeAttribute(element, prefix);\n        _this.isSkip = hasSkipAttribute(element, prefix);\n        _this.hasLoading = hasLoadingAttribute(element, prefix);\n        return _this;\n    }\n    var __proto = Loader.prototype;\n    __proto.check = function() {\n        if (this.isSkip || !this.checkElement()) {\n            // I'm Ready\n            this.onAlreadyReady(true);\n            return false;\n        }\n        if (this.hasDataSize) {\n            addAutoSizer(this.element, this.options.prefix);\n        }\n        if (this.hasDataSize || this.hasLoading) {\n            // I'm Pre Ready\n            this.onAlreadyPreReady();\n        }\n        // Wati Pre Ready, Ready\n        return true;\n    };\n    __proto.addEvents = function() {\n        var _this = this;\n        var element = this.element;\n        this.constructor.EVENTS.forEach(function(name) {\n            addEvent(element, name, _this.onCheck);\n        });\n    };\n    __proto.clear = function() {\n        var _this = this;\n        var element = this.element;\n        this.constructor.EVENTS.forEach(function(name) {\n            removeEvent(element, name, _this.onCheck);\n        });\n        this.removeAutoSizer();\n    };\n    __proto.destroy = function() {\n        this.clear();\n        this.off();\n    };\n    __proto.removeAutoSizer = function() {\n        if (this.hasDataSize) {\n            // I'm already ready.\n            var prefix = this.options.prefix;\n            removeAutoSizer(this.element, prefix);\n        }\n    };\n    __proto.onError = function(target) {\n        this.trigger(\"error\", {\n            element: this.element,\n            target: target\n        });\n    };\n    __proto.onPreReady = function() {\n        if (this.isPreReady) {\n            return;\n        }\n        this.isPreReady = true;\n        this.trigger(\"preReady\", {\n            element: this.element,\n            hasLoading: this.hasLoading,\n            isSkip: this.isSkip\n        });\n    };\n    __proto.onReady = function(withPreReady) {\n        if (this.isReady) {\n            return;\n        }\n        withPreReady = !this.isPreReady && withPreReady;\n        if (withPreReady) {\n            this.isPreReady = true;\n        }\n        this.removeAutoSizer();\n        this.isReady = true;\n        this.trigger(\"ready\", {\n            element: this.element,\n            withPreReady: withPreReady,\n            hasLoading: this.hasLoading,\n            isSkip: this.isSkip\n        });\n    };\n    __proto.onAlreadyError = function(target) {\n        var _this = this;\n        setTimeout(function() {\n            _this.onError(target);\n        });\n    };\n    __proto.onAlreadyPreReady = function() {\n        var _this = this;\n        setTimeout(function() {\n            _this.onPreReady();\n        });\n    };\n    __proto.onAlreadyReady = function(withPreReady) {\n        var _this = this;\n        setTimeout(function() {\n            _this.onReady(withPreReady);\n        });\n    };\n    Loader.EVENTS = [];\n    return Loader;\n}(_egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\nvar ElementLoader = /*#__PURE__*/ function(_super) {\n    __extends(ElementLoader, _super);\n    function ElementLoader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    var __proto = ElementLoader.prototype;\n    __proto.setHasLoading = function(hasLoading) {\n        this.hasLoading = hasLoading;\n    };\n    __proto.check = function() {\n        if (this.isSkip) {\n            // I'm Ready\n            this.onAlreadyReady(true);\n            return false;\n        }\n        if (this.hasDataSize) {\n            addAutoSizer(this.element, this.options.prefix);\n            this.onAlreadyPreReady();\n        } else {\n            // has not data size\n            this.trigger(\"requestChildren\");\n        }\n        return true;\n    };\n    __proto.checkElement = function() {\n        return true;\n    };\n    __proto.destroy = function() {\n        this.clear();\n        this.trigger(\"requestDestroy\");\n        this.off();\n    };\n    __proto.onAlreadyPreReady = function() {\n        // has data size\n        _super.prototype.onAlreadyPreReady.call(this);\n        this.trigger(\"reqeustReadyChildren\");\n    };\n    ElementLoader.EVENTS = [];\n    return ElementLoader;\n}(Loader);\n/**\n * @alias eg.ImReady\n * @extends eg.Component\n */ var ImReadyManager = /*#__PURE__*/ function(_super) {\n    __extends(ImReadyManager, _super);\n    /**\n   * @param - ImReady's options\n   */ function ImReadyManager(options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _this = _super.call(this) || this;\n        _this.readyCount = 0;\n        _this.preReadyCount = 0;\n        _this.totalCount = 0;\n        _this.totalErrorCount = 0;\n        _this.isPreReadyOver = true;\n        _this.elementInfos = [];\n        _this.options = __assign({\n            loaders: {},\n            prefix: \"data-\"\n        }, options);\n        return _this;\n    }\n    /**\n   * Checks whether elements are in the ready state.\n   * @ko 엘리먼트가 준비 상태인지 체크한다.\n   * @elements - Elements to check ready status. <ko> 준비 상태를 체크할 엘리먼트들.</ko>\n   * @example\n     * ```html\n     * <div>\n     *    <img src=\"./1.jpg\" data-width=\"1280\" data-height=\"853\" style=\"width:100%\"/>\n     *    <img src=\"./2.jpg\" data-width=\"1280\" data-height=\"853\"/>\n     *    <img src=\"ERR\" data-width=\"1280\" data-height=\"853\"/>\n     * </div>\n     * ```\n     * ## Javascript\n     * ```js\n     * import ImReady from \"@egjs/imready\";\n     *\n     * const im = new ImReady(); // umd: eg.ImReady\n     * im.check(document.querySelectorAll(\"img\")).on({\n     *   preReadyElement: e => {\n     *     // 1, 3\n     *     // 2, 3\n     *     // 3, 3\n     *     console.log(e.preReadyCount, e.totalCount),\n     *   },\n     * });\n     * ```\n   */ var __proto = ImReadyManager.prototype;\n    __proto.check = function(elements) {\n        var _this = this;\n        var prefix = this.options.prefix;\n        this.clear();\n        this.elementInfos = toArray(elements).map(function(element, index) {\n            var loader = _this.getLoader(element, {\n                prefix: prefix\n            });\n            loader.check();\n            loader.on(\"error\", function(e) {\n                _this.onError(index, e.target);\n            }).on(\"preReady\", function(e) {\n                var info = _this.elementInfos[index];\n                info.hasLoading = e.hasLoading;\n                info.isSkip = e.isSkip;\n                var isPreReady = _this.checkPreReady(index);\n                _this.onPreReadyElement(index);\n                isPreReady && _this.onPreReady();\n            }).on(\"ready\", function(_a) {\n                var withPreReady = _a.withPreReady, hasLoading = _a.hasLoading, isSkip = _a.isSkip;\n                var info = _this.elementInfos[index];\n                info.hasLoading = hasLoading;\n                info.isSkip = isSkip;\n                var isPreReady = withPreReady && _this.checkPreReady(index);\n                var isReady = _this.checkReady(index);\n                // Pre-ready and ready occur simultaneously\n                withPreReady && _this.onPreReadyElement(index);\n                _this.onReadyElement(index);\n                isPreReady && _this.onPreReady();\n                isReady && _this.onReady();\n            });\n            return {\n                loader: loader,\n                element: element,\n                hasLoading: false,\n                hasError: false,\n                isPreReady: false,\n                isReady: false,\n                isSkip: false\n            };\n        });\n        var length = this.elementInfos.length;\n        this.totalCount = length;\n        if (!length) {\n            setTimeout(function() {\n                _this.onPreReady();\n                _this.onReady();\n            });\n        }\n        return this;\n    };\n    /**\n   * Gets the total count of elements to be checked.\n   * @ko 체크하는 element의 총 개수를 가져온다.\n   */ __proto.getTotalCount = function() {\n        return this.totalCount;\n    };\n    /**\n   * Whether the elements are all pre-ready. (all sizes are known)\n   * @ko 엘리먼트들이 모두 사전 준비가 됐는지 (사이즈를 전부 알 수 있는지) 여부.\n   */ __proto.isPreReady = function() {\n        return this.elementInfos.every(function(info) {\n            return info.isPreReady;\n        });\n    };\n    /**\n   * Whether the elements are all ready.\n   * @ko 엘리먼트들이 모두 준비가 됐는지 여부.\n   */ __proto.isReady = function() {\n        return this.elementInfos.every(function(info) {\n            return info.isReady;\n        });\n    };\n    /**\n   * Whether an error has occurred in the elements in the current state.\n   * @ko 현재 상태에서 엘리먼트들이 에러가 발생했는지 여부.\n   */ __proto.hasError = function() {\n        return this.totalErrorCount > 0;\n    };\n    /**\n   * Clears events of elements being checked.\n   * @ko 체크 중인 엘리먼트들의 이벤트를 해제 한다.\n   */ __proto.clear = function() {\n        this.isPreReadyOver = false;\n        this.totalCount = 0;\n        this.preReadyCount = 0;\n        this.readyCount = 0;\n        this.totalErrorCount = 0;\n        this.elementInfos.forEach(function(info) {\n            if (info.loader) {\n                info.loader.destroy();\n            }\n        });\n        this.elementInfos = [];\n    };\n    /**\n   * Destory all events.\n   * @ko 모든 이벤트를 해제 한다.\n   */ __proto.destroy = function() {\n        this.clear();\n        this.off();\n    };\n    __proto.getLoader = function(element, options) {\n        var _this = this;\n        var tagName = element.tagName.toLowerCase();\n        var loaders = this.options.loaders;\n        var prefix = options.prefix;\n        var tags = Object.keys(loaders);\n        if (loaders[tagName]) {\n            return new loaders[tagName](element, options);\n        }\n        var loader = new ElementLoader(element, options);\n        var children = toArray(element.querySelectorAll(tags.join(\", \")));\n        loader.setHasLoading(children.some(function(el) {\n            return hasLoadingAttribute(el, prefix);\n        }));\n        var withPreReady = false;\n        var childrenImReady = this.clone().on(\"error\", function(e) {\n            loader.onError(e.target);\n        }).on(\"ready\", function() {\n            loader.onReady(withPreReady);\n        });\n        loader.on(\"requestChildren\", function() {\n            // has not data size\n            var contentElements = getContentElements(element, tags, _this.options.prefix);\n            childrenImReady.check(contentElements).on(\"preReady\", function(e) {\n                withPreReady = e.isReady;\n                if (!withPreReady) {\n                    loader.onPreReady();\n                }\n            });\n        }).on(\"reqeustReadyChildren\", function() {\n            // has data size\n            // loader call preReady\n            // check only video, image elements\n            childrenImReady.check(children);\n        }).on(\"requestDestroy\", function() {\n            childrenImReady.destroy();\n        });\n        return loader;\n    };\n    __proto.clone = function() {\n        return new ImReadyManager(__assign({}, this.options));\n    };\n    __proto.checkPreReady = function(index) {\n        this.elementInfos[index].isPreReady = true;\n        ++this.preReadyCount;\n        if (this.preReadyCount < this.totalCount) {\n            return false;\n        }\n        return true;\n    };\n    __proto.checkReady = function(index) {\n        this.elementInfos[index].isReady = true;\n        ++this.readyCount;\n        if (this.readyCount < this.totalCount) {\n            return false;\n        }\n        return true;\n    };\n    __proto.onError = function(index, target) {\n        var info = this.elementInfos[index];\n        info.hasError = true;\n        /**\n     * An event occurs if the image, video fails to load.\n     * @ko 이미지, 비디오가 로딩에 실패하면 이벤트가 발생한다.\n     * @event eg.ImReady#error\n     * @param {eg.ImReady.OnError} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @example\n     * ```html\n     * <div>\n     *    <img src=\"./1.jpg\" data-width=\"1280\" data-height=\"853\" style=\"width:100%\"/>\n     *    <img src=\"./2.jpg\"/>\n     *    <img src=\"ERR\"/>\n     * </div>\n     * ```\n     * ## Javascript\n     * ```js\n     * import ImReady from \"@egjs/imready\";\n     *\n     * const im = new ImReady(); // umd: eg.ImReady\n     * im.check([document.querySelector(\"div\")]).on({\n     *   error: e => {\n     *     // <div>...</div>, 0, <img src=\"ERR\"/>\n     *     console.log(e.element, e.index, e.target),\n     *   },\n     * });\n     * ```\n     */ this.trigger(new _egjs_component__WEBPACK_IMPORTED_MODULE_0__.ComponentEvent(\"error\", {\n            element: info.element,\n            index: index,\n            target: target,\n            errorCount: this.getErrorCount(),\n            totalErrorCount: ++this.totalErrorCount\n        }));\n    };\n    __proto.onPreReadyElement = function(index) {\n        var info = this.elementInfos[index];\n        /**\n     * An event occurs when the element is pre-ready (when the loading attribute is applied or the size is known)\n     * @ko 해당 엘리먼트가 사전 준비되었을 때(loading 속성이 적용되었거나 사이즈를 알 수 있을 때) 이벤트가 발생한다.\n     * @event eg.ImReady#preReadyElement\n     * @param {eg.ImReady.OnPreReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @example\n     * ```html\n     * <div>\n     *    <img src=\"./1.jpg\" data-width=\"1280\" data-height=\"853\" style=\"width:100%\"/>\n     *    <img src=\"./2.jpg\" data-width=\"1280\" data-height=\"853\"/>\n     *    <img src=\"ERR\" data-width=\"1280\" data-height=\"853\"/>\n     * </div>\n     * ```\n     * ## Javascript\n     * ```js\n     * import ImReady from \"@egjs/imready\";\n     *\n     * const im = new ImReady(); // umd: eg.ImReady\n     * im.check(document.querySelectorAll(\"img\")).on({\n     *   preReadyElement: e => {\n     *     // 1, 3\n     *     // 2, 3\n     *     // 3, 3\n     *     console.log(e.preReadyCount, e.totalCount),\n     *   },\n     * });\n     * ```\n     */ this.trigger(new _egjs_component__WEBPACK_IMPORTED_MODULE_0__.ComponentEvent(\"preReadyElement\", {\n            element: info.element,\n            index: index,\n            preReadyCount: this.preReadyCount,\n            readyCount: this.readyCount,\n            totalCount: this.totalCount,\n            isPreReady: this.isPreReady(),\n            isReady: this.isReady(),\n            hasLoading: info.hasLoading,\n            isSkip: info.isSkip\n        }));\n    };\n    __proto.onPreReady = function() {\n        this.isPreReadyOver = true;\n        /**\n     * An event occurs when all element are pre-ready (When all elements have the loading attribute applied or the size is known)\n     * @ko 모든 엘리먼트들이 사전 준비된 경우 (모든 엘리먼트들이 loading 속성이 적용되었거나 사이즈를 알 수 있는 경우) 이벤트가 발생한다.\n     * @event eg.ImReady#preReady\n     * @param {eg.ImReady.OnPreReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @example\n     * ```html\n     * <div>\n     *    <img src=\"./1.jpg\" data-width=\"1280\" data-height=\"853\" style=\"width:100%\"/>\n     *    <img src=\"./2.jpg\" data-width=\"1280\" data-height=\"853\"/>\n     *    <img src=\"ERR\" data-width=\"1280\" data-height=\"853\"/>\n     * </div>\n     * ```\n     * ## Javascript\n     * ```js\n     * import ImReady from \"@egjs/imready\";\n     *\n     * const im = new ImReady(); // umd: eg.ImReady\n     * im.check(document.querySelectorAll(\"img\")).on({\n     *   preReady: e => {\n     *     // 0, 3\n     *     console.log(e.readyCount, e.totalCount),\n     *   },\n     * });\n     * ```\n     */ this.trigger(new _egjs_component__WEBPACK_IMPORTED_MODULE_0__.ComponentEvent(\"preReady\", {\n            readyCount: this.readyCount,\n            totalCount: this.totalCount,\n            isReady: this.isReady(),\n            hasLoading: this.hasLoading()\n        }));\n    };\n    __proto.onReadyElement = function(index) {\n        var info = this.elementInfos[index];\n        /**\n     * An event occurs when the element is ready\n     * @ko 해당 엘리먼트가 준비가 되었을 때 이벤트가 발생한다.\n     * @event eg.ImReady#readyElement\n     * @param {eg.ImReady.OnReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @example\n     * ```html\n     * <div>\n     *    <img src=\"./1.jpg\" data-width=\"1280\" data-height=\"853\" style=\"width:100%\"/>\n     *    <img src=\"./2.jpg\" data-width=\"1280\" data-height=\"853\"/>\n     *    <img src=\"ERR\" data-width=\"1280\" data-height=\"853\"/>\n     * </div>\n     * ```\n     * ## Javascript\n     * ```js\n     * import ImReady from \"@egjs/imready\";\n     *\n     * const im = new ImReady(); // umd: eg.ImReady\n     * im.check(document.querySelectorAll(\"img\")).on({\n     *   readyElement: e => {\n     *     // 1, 0, false, 3\n     *     // 2, 1, false, 3\n     *     // 3, 2, true, 3\n     *     console.log(e.readyCount, e.index, e.hasError, e.totalCount),\n     *   },\n     * });\n     * ```\n     */ this.trigger(new _egjs_component__WEBPACK_IMPORTED_MODULE_0__.ComponentEvent(\"readyElement\", {\n            index: index,\n            element: info.element,\n            hasError: info.hasError,\n            errorCount: this.getErrorCount(),\n            totalErrorCount: this.totalErrorCount,\n            preReadyCount: this.preReadyCount,\n            readyCount: this.readyCount,\n            totalCount: this.totalCount,\n            isPreReady: this.isPreReady(),\n            isReady: this.isReady(),\n            hasLoading: info.hasLoading,\n            isPreReadyOver: this.isPreReadyOver,\n            isSkip: info.isSkip\n        }));\n    };\n    __proto.onReady = function() {\n        /**\n     * An event occurs when all element are ready\n     * @ko 모든 엘리먼트들이 준비된 경우 이벤트가 발생한다.\n     * @event eg.ImReady#ready\n     * @param {eg.ImReady.OnReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     * @example\n     * ```html\n     * <div>\n     *    <img src=\"./1.jpg\" data-width=\"1280\" data-height=\"853\" style=\"width:100%\"/>\n     *    <img src=\"./2.jpg\" data-width=\"1280\" data-height=\"853\"/>\n     *    <img src=\"ERR\" data-width=\"1280\" data-height=\"853\"/>\n     * </div>\n     * ```\n     * ## Javascript\n     * ```js\n     * import ImReady from \"@egjs/imready\";\n     *\n     * const im = new ImReady(); // umd: eg.ImReady\n     * im.check(document.querySelectorAll(\"img\")).on({\n     *   preReady: e => {\n     *     // 0, 3\n     *     console.log(e.readyCount, e.totalCount),\n     *   },\n     *   ready: e => {\n     *     // 1, 3\n     *     console.log(e.errorCount, e.totalCount),\n     *   },\n     * });\n     * ```\n     */ this.trigger(new _egjs_component__WEBPACK_IMPORTED_MODULE_0__.ComponentEvent(\"ready\", {\n            errorCount: this.getErrorCount(),\n            totalErrorCount: this.totalErrorCount,\n            totalCount: this.totalCount\n        }));\n    };\n    __proto.getErrorCount = function() {\n        return this.elementInfos.filter(function(info) {\n            return info.hasError;\n        }).length;\n    };\n    __proto.hasLoading = function() {\n        return this.elementInfos.some(function(info) {\n            return info.hasLoading;\n        });\n    };\n    return ImReadyManager;\n}(_egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\nvar ImageLoader = /*#__PURE__*/ function(_super) {\n    __extends(ImageLoader, _super);\n    function ImageLoader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    var __proto = ImageLoader.prototype;\n    __proto.checkElement = function() {\n        var element = this.element;\n        var src = element.getAttribute(\"src\");\n        if (element.complete) {\n            if (src) {\n                // complete\n                if (!element.naturalWidth) {\n                    this.onAlreadyError(element);\n                }\n                return false;\n            } else {\n                // Using an external lazy loading module\n                this.onAlreadyPreReady();\n            }\n        }\n        this.addEvents();\n        IS_IE && element.setAttribute(\"src\", src);\n        return true;\n    };\n    ImageLoader.EVENTS = [\n        \"load\",\n        \"error\"\n    ];\n    return ImageLoader;\n}(Loader);\nvar VideoLoader = /*#__PURE__*/ function(_super) {\n    __extends(VideoLoader, _super);\n    function VideoLoader() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    var __proto = VideoLoader.prototype;\n    __proto.checkElement = function() {\n        var element = this.element;\n        // HAVE_NOTHING: 0, no information whether or not the audio/video is ready\n        // HAVE_METADATA: 1, HAVE_METADATA - metadata for the audio/video is ready\n        // HAVE_CURRENT_DATA: 2, data for the current playback position is available, but not enough data to play next frame/millisecond\n        // HAVE_FUTURE_DATA: 3, data for the current and at least the next frame is available\n        // HAVE_ENOUGH_DATA: 4, enough data available to start playing\n        if (element.readyState >= 1) {\n            return false;\n        }\n        if (element.error) {\n            this.onAlreadyError(element);\n            return false;\n        }\n        this.addEvents();\n        return true;\n    };\n    VideoLoader.EVENTS = [\n        \"loadedmetadata\",\n        \"error\"\n    ];\n    return VideoLoader;\n}(Loader);\nvar ImReady = /*#__PURE__*/ function(_super) {\n    __extends(ImReady, _super);\n    function ImReady(options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return _super.call(this, __assign({\n            loaders: {\n                img: ImageLoader,\n                video: VideoLoader\n            }\n        }, options)) || this;\n    }\n    return ImReady;\n}(ImReadyManager);\nvar REACTIVE_IMREADY = function(_a) {\n    var setEvents = _a.setEvents, setMethods = _a.setMethods, on = _a.on, onInit = _a.onInit, onDestroy = _a.onDestroy, getProps = _a.getProps;\n    setEvents(EVENTS);\n    setMethods([\n        \"add\"\n    ]);\n    var children = [];\n    var reactiveImReady = (0,_cfcs_core__WEBPACK_IMPORTED_MODULE_1__.reactive)({\n        preReadyCount: 0,\n        readyCount: 0,\n        errorCount: 0,\n        totalErrorCount: 0,\n        totalCount: 0,\n        isPreReady: false,\n        isReady: false,\n        hasError: false,\n        isPreReadyOver: false,\n        add: function(element) {\n            children.push(element);\n        }\n    });\n    var props = getProps() || {};\n    var imReady = new ImReady(props);\n    imReady.on(\"error\", function(e) {\n        reactiveImReady.hasError = true;\n        reactiveImReady.errorCount = e.errorCount;\n        reactiveImReady.totalErrorCount = e.totalErrorCount;\n    }).on(\"preReadyElement\", function(e) {\n        reactiveImReady.preReadyCount = e.preReadyCount;\n    }).on(\"readyElement\", function(e) {\n        reactiveImReady.readyCount = e.readyCount;\n        reactiveImReady.isPreReadyOver = e.isPreReadyOver;\n    }).on(\"preReady\", function() {\n        reactiveImReady.isPreReady = true;\n    }).on(\"ready\", function() {\n        reactiveImReady.isReady = true;\n    });\n    on(function(_, name, callback) {\n        imReady.on(name, callback);\n        return function() {\n            imReady.off(name, callback);\n        };\n    });\n    onInit(function() {\n        var selector = props === null || props === void 0 ? void 0 : props.selector;\n        var checkedElements = [];\n        children.forEach(function(child) {\n            if (!child) {\n                return;\n            }\n            if ((0,_cfcs_core__WEBPACK_IMPORTED_MODULE_1__.isString)(child)) {\n                checkedElements = __spreadArrays(checkedElements, toArray(document.querySelectorAll(child)));\n            } else if (child instanceof Element) {\n                checkedElements.push(child);\n            } else if (\"value\" in child || \"current\" in child) {\n                var element = child.value || child.current;\n                if (element) {\n                    checkedElements.push(element);\n                }\n            }\n        });\n        if (selector) {\n            checkedElements = checkedElements.reduce(function(prev, cur) {\n                return __spreadArrays(prev, [].slice.call(cur.querySelectorAll(selector)));\n            }, []);\n        }\n        reactiveImReady.totalCount = checkedElements.length;\n        imReady.check(checkedElements);\n    });\n    onDestroy(function() {\n        imReady.destroy();\n    });\n    return reactiveImReady;\n};\n/*\negjs-imready\nCopyright (c) 2020-present NAVER Corp.\nMIT license\n*/ /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImReady);\n //# sourceMappingURL=imready.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvaW1yZWFkeS9kaXN0L2ltcmVhZHkuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BLEdBQzREO0FBQ1o7QUFFaEQ7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLDJCQUEyQixHQUUzQixJQUFJSSxnQkFBZ0IsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hDRixnQkFBZ0JHLE9BQU9DLGNBQWMsSUFBSTtRQUN2Q0MsV0FBVyxFQUFFO0lBQ2YsY0FBYUMsU0FBUyxTQUFVTCxDQUFDLEVBQUVDLENBQUM7UUFDbENELEVBQUVJLFNBQVMsR0FBR0g7SUFDaEIsS0FBSyxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFDakIsSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFDOUU7SUFDQSxPQUFPUCxjQUFjQyxHQUFHQztBQUMxQjtBQUNBLFNBQVNTLFVBQVVWLENBQUMsRUFBRUMsQ0FBQztJQUNyQixJQUFJLE9BQU9BLE1BQU0sY0FBY0EsTUFBTSxNQUFNLE1BQU0sSUFBSVUsVUFBVSx5QkFBeUJDLE9BQU9YLEtBQUs7SUFDcEdGLGNBQWNDLEdBQUdDO0lBQ2pCLFNBQVNZO1FBQ1AsSUFBSSxDQUFDQyxXQUFXLEdBQUdkO0lBQ3JCO0lBQ0FBLEVBQUVPLFNBQVMsR0FBR04sTUFBTSxPQUFPQyxPQUFPYSxNQUFNLENBQUNkLEtBQU1ZLENBQUFBLEdBQUdOLFNBQVMsR0FBR04sRUFBRU0sU0FBUyxFQUFFLElBQUlNLElBQUc7QUFDcEY7QUFDQSxJQUFJRyxXQUFXO0lBQ2JBLFdBQVdkLE9BQU9lLE1BQU0sSUFBSSxTQUFTRCxTQUFTRSxDQUFDO1FBQzdDLElBQUssSUFBSUMsR0FBR0MsSUFBSSxHQUFHQyxJQUFJQyxVQUFVQyxN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LElBQUksQ0FBQ29MLElBQUkvRyxnQkFBZ0IsQ0FBQ3VHO1lBQ2pFLEdBQUcsRUFBRTtRQUNQO1FBQ0FOLGdCQUFnQjNDLFVBQVUsR0FBR2tELGdCQUFnQi9KLE1BQU07UUFDbkQySixRQUFRN0QsS0FBSyxDQUFDaUU7SUFDaEI7SUFDQVQsVUFBVTtRQUNSSyxRQUFRekQsT0FBTztJQUNqQjtJQUNBLE9BQU9zRDtBQUNUO0FBRUE7Ozs7QUFJQSxHQUVBLGlFQUFlVCxPQUFPQSxFQUFDO0FBQ2lGLENBQ3hHLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JvYmxlcy1yZW5kZXIvLi9ub2RlX21vZHVsZXMvQGVnanMvaW1yZWFkeS9kaXN0L2ltcmVhZHkuZXNtLmpzP2UyMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2ltcmVhZHlcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtaW1yZWFkeVxudmVyc2lvbjogMS40LjFcbiovXG5pbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSAnQGVnanMvY29tcG9uZW50JztcbmltcG9ydCB7IHJlYWN0aXZlLCBpc1N0cmluZyB9IGZyb20gJ0BjZmNzL2NvcmUnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG4vKlxuZWdqcy1pbXJlYWR5XG5Db3B5cmlnaHQgKGMpIDIwMjAtcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgaXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIHVhID0gaXNXaW5kb3cgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IFwiXCI7XG52YXIgU1VQUE9SVF9DT01QVVRFRFNUWUxFID0gaXNXaW5kb3cgPyAhIShcImdldENvbXB1dGVkU3R5bGVcIiBpbiB3aW5kb3cpIDogZmFsc2U7XG52YXIgSVNfSUUgPSAvTVNJRXxUcmlkZW50fFdpbmRvd3MgUGhvbmV8RWRnZS8udGVzdCh1YSk7XG52YXIgU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSID0gaXNXaW5kb3cgPyAhIShcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiBkb2N1bWVudCkgOiBmYWxzZTtcbnZhciBXSURUSCA9IFwid2lkdGhcIjtcbnZhciBIRUlHSFQgPSBcImhlaWdodFwiO1xudmFyIFBST1BTID0gW1wicHJlZml4XCIsIFwibG9hZGVyc1wiXTtcbnZhciBFVkVOVFMgPSBbXCJwcmVSZWFkeUVsZW1lbnRcIiwgXCJyZWFkeUVsZW1lbnRcIiwgXCJlcnJvclwiLCBcInByZVJlYWR5XCIsIFwicmVhZHlcIl07XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgbmFtZSkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKG5hbWUpIHx8IFwiXCI7XG59XG5mdW5jdGlvbiB0b0FycmF5KGFycikge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChhcnIpO1xufVxuZnVuY3Rpb24gaGFzU2l6ZUF0dHJpYnV0ZSh0YXJnZXQsIHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICBwcmVmaXggPSBcImRhdGEtXCI7XG4gIH1cbiAgcmV0dXJuICEhdGFyZ2V0LmdldEF0dHJpYnV0ZShwcmVmaXggKyBcIndpZHRoXCIpO1xufVxuZnVuY3Rpb24gaGFzTG9hZGluZ0F0dHJpYnV0ZSh0YXJnZXQsIHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICBwcmVmaXggPSBcImRhdGEtXCI7XG4gIH1cbiAgcmV0dXJuIFwibG9hZGluZ1wiIGluIHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibG9hZGluZ1wiKSA9PT0gXCJsYXp5XCIgfHwgISF0YXJnZXQuZ2V0QXR0cmlidXRlKHByZWZpeCArIFwibGF6eVwiKTtcbn1cbmZ1bmN0aW9uIGhhc1NraXBBdHRyaWJ1dGUodGFyZ2V0LCBwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgcHJlZml4ID0gXCJkYXRhLVwiO1xuICB9XG4gIHJldHVybiAhIXRhcmdldC5nZXRBdHRyaWJ1dGUocHJlZml4ICsgXCJza2lwXCIpO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50W1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50W1wib25cIiArIHR5cGVdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaW5uZXJXaWR0aChlbCkge1xuICByZXR1cm4gZ2V0U2l6ZShlbCwgXCJXaWR0aFwiKTtcbn1cbmZ1bmN0aW9uIGlubmVySGVpZ2h0KGVsKSB7XG4gIHJldHVybiBnZXRTaXplKGVsLCBcIkhlaWdodFwiKTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlcyhlbCkge1xuICByZXR1cm4gKFNVUFBPUlRfQ09NUFVURURTVFlMRSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSA6IGVsLmN1cnJlbnRTdHlsZSkgfHwge307XG59XG5mdW5jdGlvbiBnZXRTaXplKGVsLCBuYW1lKSB7XG4gIHZhciBzaXplID0gZWxbXCJjbGllbnRcIiArIG5hbWVdIHx8IGVsW1wib2Zmc2V0XCIgKyBuYW1lXTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoc2l6ZSB8fCBnZXRTdHlsZXMoZWwpW25hbWUudG9Mb3dlckNhc2UoKV0pIHx8IDA7XG59XG5mdW5jdGlvbiBnZXRDb250ZW50RWxlbWVudHMoZWxlbWVudCwgdGFncywgcHJlZml4KSB7XG4gIHZhciBza2lwRWxlbWVudHMgPSB0b0FycmF5KGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChfX3NwcmVhZEFycmF5cyhbXCJbXCIgKyBwcmVmaXggKyBcInNraXBdIFtcIiArIHByZWZpeCArIFwid2lkdGhdXCJdLCB0YWdzLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIFtcIltcIiArIHByZWZpeCArIFwic2tpcF0gXCIgKyB0YWcsIHRhZyArIFwiW1wiICsgcHJlZml4ICsgXCJza2lwXVwiLCBcIltcIiArIHByZWZpeCArIFwid2lkdGhdIFwiICsgdGFnXS5qb2luKFwiLCBcIik7XG4gIH0pKS5qb2luKFwiLCBcIikpKTtcbiAgcmV0dXJuIHRvQXJyYXkoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgcHJlZml4ICsgXCJ3aWR0aF0sIFwiICsgdGFncy5qb2luKFwiLCBcIikpKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIHNraXBFbGVtZW50cy5pbmRleE9mKGVsKSA9PT0gLTE7XG4gIH0pO1xufVxuXG4vKlxuZWdqcy1pbXJlYWR5XG5Db3B5cmlnaHQgKGMpIDIwMjAtcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgZWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uIGFkZEF1dG9TaXplcihlbGVtZW50LCBwcmVmaXgpIHtcbiAgIWVsZW1lbnRzLmxlbmd0aCAmJiBhZGRFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIHJlc2l6ZUFsbEF1dG9TaXplcnMpO1xuICBlbGVtZW50Ll9fUFJFRklYX18gPSBwcmVmaXg7XG4gIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gIHJlc2l6ZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUF1dG9TaXplcihlbGVtZW50LCBwcmVmaXgpIHtcbiAgdmFyIGluZGV4ID0gZWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZml4ZWQgPSBnZXRBdHRyaWJ1dGUoZWxlbWVudCwgcHJlZml4ICsgXCJmaXhlZFwiKTtcbiAgZGVsZXRlIGVsZW1lbnQuX19QUkVGSVhfXztcbiAgZWxlbWVudC5zdHlsZVtmaXhlZCA9PT0gSEVJR0hUID8gV0lEVEggOiBIRUlHSFRdID0gXCJcIjtcbiAgZWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgIWVsZW1lbnRzLmxlbmd0aCAmJiByZW1vdmVFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIHJlc2l6ZUFsbEF1dG9TaXplcnMpO1xufVxuZnVuY3Rpb24gcmVzaXplKGVsZW1lbnQsIHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICBwcmVmaXggPSBcImRhdGEtXCI7XG4gIH1cbiAgdmFyIGVsZW1lbnRQcmVmaXggPSBlbGVtZW50Ll9fUFJFRklYX18gfHwgcHJlZml4O1xuICB2YXIgZGF0YVdpZHRoID0gcGFyc2VJbnQoZ2V0QXR0cmlidXRlKGVsZW1lbnQsIFwiXCIgKyBlbGVtZW50UHJlZml4ICsgV0lEVEgpLCAxMCkgfHwgMDtcbiAgdmFyIGRhdGFIZWlnaHQgPSBwYXJzZUludChnZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJcIiArIGVsZW1lbnRQcmVmaXggKyBIRUlHSFQpLCAxMCkgfHwgMDtcbiAgdmFyIGZpeGVkID0gZ2V0QXR0cmlidXRlKGVsZW1lbnQsIGVsZW1lbnRQcmVmaXggKyBcImZpeGVkXCIpO1xuICBpZiAoZml4ZWQgPT09IEhFSUdIVCkge1xuICAgIHZhciBzaXplID0gaW5uZXJIZWlnaHQoZWxlbWVudCkgfHwgZGF0YUhlaWdodDtcbiAgICBlbGVtZW50LnN0eWxlW1dJRFRIXSA9IGRhdGFXaWR0aCAvIGRhdGFIZWlnaHQgKiBzaXplICsgXCJweFwiO1xuICB9IGVsc2Uge1xuICAgIHZhciBzaXplID0gaW5uZXJXaWR0aChlbGVtZW50KSB8fCBkYXRhV2lkdGg7XG4gICAgZWxlbWVudC5zdHlsZVtIRUlHSFRdID0gZGF0YUhlaWdodCAvIGRhdGFXaWR0aCAqIHNpemUgKyBcInB4XCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2l6ZUFsbEF1dG9TaXplcnMoKSB7XG4gIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXNpemUoZWxlbWVudCk7XG4gIH0pO1xufVxuXG52YXIgTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKExvYWRlciwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTG9hZGVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgIF90aGlzLmlzUHJlUmVhZHkgPSBmYWxzZTtcbiAgICBfdGhpcy5oYXNEYXRhU2l6ZSA9IGZhbHNlO1xuICAgIF90aGlzLmhhc0xvYWRpbmcgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1NraXAgPSBmYWxzZTtcbiAgICBfdGhpcy5vbkNoZWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLmNsZWFyKCk7XG4gICAgICBpZiAoZSAmJiBlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBfdGhpcy5vbkVycm9yKF90aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLmhhc0xvYWRpbmcgJiYgX3RoaXMuY2hlY2tFbGVtZW50KCkpIHtcbiAgICAgICAgLy8gSSdtIG5vdCByZWFkeVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJJ20gcHJlLXJlYWR5IGFuZCByZWFkeSFcbiAgICAgIHZhciB3aXRoUHJlUmVhZHkgPSAhX3RoaXMuaGFzRGF0YVNpemUgJiYgIV90aGlzLmhhc0xvYWRpbmc7XG4gICAgICBfdGhpcy5vblJlYWR5KHdpdGhQcmVSZWFkeSk7XG4gICAgfTtcbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgcHJlZml4OiBcImRhdGEtXCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBfdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB2YXIgcHJlZml4ID0gX3RoaXMub3B0aW9ucy5wcmVmaXg7XG4gICAgX3RoaXMuaGFzRGF0YVNpemUgPSBoYXNTaXplQXR0cmlidXRlKGVsZW1lbnQsIHByZWZpeCk7XG4gICAgX3RoaXMuaXNTa2lwID0gaGFzU2tpcEF0dHJpYnV0ZShlbGVtZW50LCBwcmVmaXgpO1xuICAgIF90aGlzLmhhc0xvYWRpbmcgPSBoYXNMb2FkaW5nQXR0cmlidXRlKGVsZW1lbnQsIHByZWZpeCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gTG9hZGVyLnByb3RvdHlwZTtcbiAgX19wcm90by5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1NraXAgfHwgIXRoaXMuY2hlY2tFbGVtZW50KCkpIHtcbiAgICAgIC8vIEknbSBSZWFkeVxuICAgICAgdGhpcy5vbkFscmVhZHlSZWFkeSh0cnVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRGF0YVNpemUpIHtcbiAgICAgIGFkZEF1dG9TaXplcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNEYXRhU2l6ZSB8fCB0aGlzLmhhc0xvYWRpbmcpIHtcbiAgICAgIC8vIEknbSBQcmUgUmVhZHlcbiAgICAgIHRoaXMub25BbHJlYWR5UHJlUmVhZHkoKTtcbiAgICB9XG4gICAgLy8gV2F0aSBQcmUgUmVhZHksIFJlYWR5XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9fcHJvdG8uYWRkRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgYWRkRXZlbnQoZWxlbWVudCwgbmFtZSwgX3RoaXMub25DaGVjayk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZW1vdmVFdmVudChlbGVtZW50LCBuYW1lLCBfdGhpcy5vbkNoZWNrKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbW92ZUF1dG9TaXplcigpO1xuICB9O1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH07XG4gIF9fcHJvdG8ucmVtb3ZlQXV0b1NpemVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmhhc0RhdGFTaXplKSB7XG4gICAgICAvLyBJJ20gYWxyZWFkeSByZWFkeS5cbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4O1xuICAgICAgcmVtb3ZlQXV0b1NpemVyKHRoaXMuZWxlbWVudCwgcHJlZml4KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0aGlzLnRyaWdnZXIoXCJlcnJvclwiLCB7XG4gICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLm9uUHJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNQcmVSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUHJlUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMudHJpZ2dlcihcInByZVJlYWR5XCIsIHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIGhhc0xvYWRpbmc6IHRoaXMuaGFzTG9hZGluZyxcbiAgICAgIGlzU2tpcDogdGhpcy5pc1NraXBcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5vblJlYWR5ID0gZnVuY3Rpb24gKHdpdGhQcmVSZWFkeSkge1xuICAgIGlmICh0aGlzLmlzUmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2l0aFByZVJlYWR5ID0gIXRoaXMuaXNQcmVSZWFkeSAmJiB3aXRoUHJlUmVhZHk7XG4gICAgaWYgKHdpdGhQcmVSZWFkeSkge1xuICAgICAgdGhpcy5pc1ByZVJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBdXRvU2l6ZXIoKTtcbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMudHJpZ2dlcihcInJlYWR5XCIsIHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIHdpdGhQcmVSZWFkeTogd2l0aFByZVJlYWR5LFxuICAgICAgaGFzTG9hZGluZzogdGhpcy5oYXNMb2FkaW5nLFxuICAgICAgaXNTa2lwOiB0aGlzLmlzU2tpcFxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLm9uQWxyZWFkeUVycm9yID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vbkVycm9yKHRhcmdldCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8ub25BbHJlYWR5UHJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUHJlUmVhZHkoKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5vbkFscmVhZHlSZWFkeSA9IGZ1bmN0aW9uICh3aXRoUHJlUmVhZHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZWFkeSh3aXRoUHJlUmVhZHkpO1xuICAgIH0pO1xuICB9O1xuICBMb2FkZXIuRVZFTlRTID0gW107XG4gIHJldHVybiBMb2FkZXI7XG59KENvbXBvbmVudCk7XG5cbnZhciBFbGVtZW50TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEVsZW1lbnRMb2FkZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEVsZW1lbnRMb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gRWxlbWVudExvYWRlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uc2V0SGFzTG9hZGluZyA9IGZ1bmN0aW9uIChoYXNMb2FkaW5nKSB7XG4gICAgdGhpcy5oYXNMb2FkaW5nID0gaGFzTG9hZGluZztcbiAgfTtcbiAgX19wcm90by5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1NraXApIHtcbiAgICAgIC8vIEknbSBSZWFkeVxuICAgICAgdGhpcy5vbkFscmVhZHlSZWFkeSh0cnVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRGF0YVNpemUpIHtcbiAgICAgIGFkZEF1dG9TaXplcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgICAgdGhpcy5vbkFscmVhZHlQcmVSZWFkeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgbm90IGRhdGEgc2l6ZVxuICAgICAgdGhpcy50cmlnZ2VyKFwicmVxdWVzdENoaWxkcmVuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX19wcm90by5jaGVja0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy50cmlnZ2VyKFwicmVxdWVzdERlc3Ryb3lcIik7XG4gICAgdGhpcy5vZmYoKTtcbiAgfTtcbiAgX19wcm90by5vbkFscmVhZHlQcmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBoYXMgZGF0YSBzaXplXG4gICAgX3N1cGVyLnByb3RvdHlwZS5vbkFscmVhZHlQcmVSZWFkeS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudHJpZ2dlcihcInJlcWV1c3RSZWFkeUNoaWxkcmVuXCIpO1xuICB9O1xuICBFbGVtZW50TG9hZGVyLkVWRU5UUyA9IFtdO1xuICByZXR1cm4gRWxlbWVudExvYWRlcjtcbn0oTG9hZGVyKTtcblxuLyoqXG4gKiBAYWxpYXMgZWcuSW1SZWFkeVxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKi9cbnZhciBJbVJlYWR5TWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhJbVJlYWR5TWFuYWdlciwgX3N1cGVyKTtcbiAgLyoqXG4gICAqIEBwYXJhbSAtIEltUmVhZHkncyBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBJbVJlYWR5TWFuYWdlcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLnJlYWR5Q291bnQgPSAwO1xuICAgIF90aGlzLnByZVJlYWR5Q291bnQgPSAwO1xuICAgIF90aGlzLnRvdGFsQ291bnQgPSAwO1xuICAgIF90aGlzLnRvdGFsRXJyb3JDb3VudCA9IDA7XG4gICAgX3RoaXMuaXNQcmVSZWFkeU92ZXIgPSB0cnVlO1xuICAgIF90aGlzLmVsZW1lbnRJbmZvcyA9IFtdO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBsb2FkZXJzOiB7fSxcbiAgICAgIHByZWZpeDogXCJkYXRhLVwiXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBlbGVtZW50cyBhcmUgaW4gdGhlIHJlYWR5IHN0YXRlLlxuICAgKiBAa28g7JeY66as66i87Yq46rCAIOykgOu5hCDsg4Htg5zsnbjsp4Ag7LK07YGs7ZWc64ukLlxuICAgKiBAZWxlbWVudHMgLSBFbGVtZW50cyB0byBjaGVjayByZWFkeSBzdGF0dXMuIDxrbz4g7KSA67mEIOyDge2DnOulvCDssrTtgaztlaAg7JeY66as66i87Yq465OkLjwva28+XG4gICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5vbih7XG4gICAgICogICBwcmVSZWFkeUVsZW1lbnQ6IGUgPT4ge1xuICAgICAqICAgICAvLyAxLCAzXG4gICAgICogICAgIC8vIDIsIDNcbiAgICAgKiAgICAgLy8gMywgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLnByZVJlYWR5Q291bnQsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgKi9cbiAgdmFyIF9fcHJvdG8gPSBJbVJlYWR5TWFuYWdlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uY2hlY2sgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4O1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IHRvQXJyYXkoZWxlbWVudHMpLm1hcChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfdGhpcy5nZXRMb2FkZXIoZWxlbWVudCwge1xuICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgfSk7XG4gICAgICBsb2FkZXIuY2hlY2soKTtcbiAgICAgIGxvYWRlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzLm9uRXJyb3IoaW5kZXgsIGUudGFyZ2V0KTtcbiAgICAgIH0pLm9uKFwicHJlUmVhZHlcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGluZm8gPSBfdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgICAgICBpbmZvLmhhc0xvYWRpbmcgPSBlLmhhc0xvYWRpbmc7XG4gICAgICAgIGluZm8uaXNTa2lwID0gZS5pc1NraXA7XG4gICAgICAgIHZhciBpc1ByZVJlYWR5ID0gX3RoaXMuY2hlY2tQcmVSZWFkeShpbmRleCk7XG4gICAgICAgIF90aGlzLm9uUHJlUmVhZHlFbGVtZW50KGluZGV4KTtcbiAgICAgICAgaXNQcmVSZWFkeSAmJiBfdGhpcy5vblByZVJlYWR5KCk7XG4gICAgICB9KS5vbihcInJlYWR5XCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2l0aFByZVJlYWR5ID0gX2Eud2l0aFByZVJlYWR5LFxuICAgICAgICAgIGhhc0xvYWRpbmcgPSBfYS5oYXNMb2FkaW5nLFxuICAgICAgICAgIGlzU2tpcCA9IF9hLmlzU2tpcDtcbiAgICAgICAgdmFyIGluZm8gPSBfdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgICAgICBpbmZvLmhhc0xvYWRpbmcgPSBoYXNMb2FkaW5nO1xuICAgICAgICBpbmZvLmlzU2tpcCA9IGlzU2tpcDtcbiAgICAgICAgdmFyIGlzUHJlUmVhZHkgPSB3aXRoUHJlUmVhZHkgJiYgX3RoaXMuY2hlY2tQcmVSZWFkeShpbmRleCk7XG4gICAgICAgIHZhciBpc1JlYWR5ID0gX3RoaXMuY2hlY2tSZWFkeShpbmRleCk7XG4gICAgICAgIC8vIFByZS1yZWFkeSBhbmQgcmVhZHkgb2NjdXIgc2ltdWx0YW5lb3VzbHlcbiAgICAgICAgd2l0aFByZVJlYWR5ICYmIF90aGlzLm9uUHJlUmVhZHlFbGVtZW50KGluZGV4KTtcbiAgICAgICAgX3RoaXMub25SZWFkeUVsZW1lbnQoaW5kZXgpO1xuICAgICAgICBpc1ByZVJlYWR5ICYmIF90aGlzLm9uUHJlUmVhZHkoKTtcbiAgICAgICAgaXNSZWFkeSAmJiBfdGhpcy5vblJlYWR5KCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvYWRlcjogbG9hZGVyLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBoYXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgaGFzRXJyb3I6IGZhbHNlLFxuICAgICAgICBpc1ByZVJlYWR5OiBmYWxzZSxcbiAgICAgICAgaXNSZWFkeTogZmFsc2UsXG4gICAgICAgIGlzU2tpcDogZmFsc2VcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuZWxlbWVudEluZm9zLmxlbmd0aDtcbiAgICB0aGlzLnRvdGFsQ291bnQgPSBsZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5vblByZVJlYWR5KCk7XG4gICAgICAgIF90aGlzLm9uUmVhZHkoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIHRvdGFsIGNvdW50IG9mIGVsZW1lbnRzIHRvIGJlIGNoZWNrZWQuXG4gICAqIEBrbyDssrTtgaztlZjripQgZWxlbWVudOydmCDstJ0g6rCc7IiY66W8IOqwgOyguOyYqOuLpC5cbiAgICovXG4gIF9fcHJvdG8uZ2V0VG90YWxDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbENvdW50O1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0aGUgZWxlbWVudHMgYXJlIGFsbCBwcmUtcmVhZHkuIChhbGwgc2l6ZXMgYXJlIGtub3duKVxuICAgKiBAa28g7JeY66as66i87Yq465Ok7J20IOuqqOuRkCDsgqzsoIQg7KSA67mE6rCAIOuQkOuKlOyngCAo7IKs7J207KaI66W8IOyghOu2gCDslYwg7IiYIOyeiOuKlOyngCkg7Jes67aALlxuICAgKi9cbiAgX19wcm90by5pc1ByZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRJbmZvcy5ldmVyeShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaXNQcmVSZWFkeTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGVsZW1lbnRzIGFyZSBhbGwgcmVhZHkuXG4gICAqIEBrbyDsl5jrpqzrqLztirjrk6TsnbQg66qo65GQIOykgOu5hOqwgCDrkJDripTsp4Ag7Jes67aALlxuICAgKi9cbiAgX19wcm90by5pc1JlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRJbmZvcy5ldmVyeShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaXNSZWFkeTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgYW4gZXJyb3IgaGFzIG9jY3VycmVkIGluIHRoZSBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQGtvIO2YhOyerCDsg4Htg5zsl5DshJwg7JeY66as66i87Yq465Ok7J20IOyXkOufrOqwgCDrsJzsg53tlojripTsp4Ag7Jes67aALlxuICAgKi9cbiAgX19wcm90by5oYXNFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbEVycm9yQ291bnQgPiAwO1xuICB9O1xuICAvKipcbiAgICogQ2xlYXJzIGV2ZW50cyBvZiBlbGVtZW50cyBiZWluZyBjaGVja2VkLlxuICAgKiBAa28g7LK07YGsIOykkeyduCDsl5jrpqzrqLztirjrk6TsnZgg7J2067Kk7Yq466W8IO2VtOygnCDtlZzri6QuXG4gICAqL1xuICBfX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQcmVSZWFkeU92ZXIgPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsQ291bnQgPSAwO1xuICAgIHRoaXMucHJlUmVhZHlDb3VudCA9IDA7XG4gICAgdGhpcy5yZWFkeUNvdW50ID0gMDtcbiAgICB0aGlzLnRvdGFsRXJyb3JDb3VudCA9IDA7XG4gICAgdGhpcy5lbGVtZW50SW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgaWYgKGluZm8ubG9hZGVyKSB7XG4gICAgICAgIGluZm8ubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IFtdO1xuICB9O1xuICAvKipcbiAgICogRGVzdG9yeSBhbGwgZXZlbnRzLlxuICAgKiBAa28g66qo65OgIOydtOuypO2KuOulvCDtlbTsoJwg7ZWc64ukLlxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLm9mZigpO1xuICB9O1xuICBfX3Byb3RvLmdldExvYWRlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBsb2FkZXJzID0gdGhpcy5vcHRpb25zLmxvYWRlcnM7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMucHJlZml4O1xuICAgIHZhciB0YWdzID0gT2JqZWN0LmtleXMobG9hZGVycyk7XG4gICAgaWYgKGxvYWRlcnNbdGFnTmFtZV0pIHtcbiAgICAgIHJldHVybiBuZXcgbG9hZGVyc1t0YWdOYW1lXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgdmFyIGxvYWRlciA9IG5ldyBFbGVtZW50TG9hZGVyKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRvQXJyYXkoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhZ3Muam9pbihcIiwgXCIpKSk7XG4gICAgbG9hZGVyLnNldEhhc0xvYWRpbmcoY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBoYXNMb2FkaW5nQXR0cmlidXRlKGVsLCBwcmVmaXgpO1xuICAgIH0pKTtcbiAgICB2YXIgd2l0aFByZVJlYWR5ID0gZmFsc2U7XG4gICAgdmFyIGNoaWxkcmVuSW1SZWFkeSA9IHRoaXMuY2xvbmUoKS5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBsb2FkZXIub25FcnJvcihlLnRhcmdldCk7XG4gICAgfSkub24oXCJyZWFkeVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2FkZXIub25SZWFkeSh3aXRoUHJlUmVhZHkpO1xuICAgIH0pO1xuICAgIGxvYWRlci5vbihcInJlcXVlc3RDaGlsZHJlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBoYXMgbm90IGRhdGEgc2l6ZVxuICAgICAgdmFyIGNvbnRlbnRFbGVtZW50cyA9IGdldENvbnRlbnRFbGVtZW50cyhlbGVtZW50LCB0YWdzLCBfdGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgICBjaGlsZHJlbkltUmVhZHkuY2hlY2soY29udGVudEVsZW1lbnRzKS5vbihcInByZVJlYWR5XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHdpdGhQcmVSZWFkeSA9IGUuaXNSZWFkeTtcbiAgICAgICAgaWYgKCF3aXRoUHJlUmVhZHkpIHtcbiAgICAgICAgICBsb2FkZXIub25QcmVSZWFkeSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5vbihcInJlcWV1c3RSZWFkeUNoaWxkcmVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGhhcyBkYXRhIHNpemVcbiAgICAgIC8vIGxvYWRlciBjYWxsIHByZVJlYWR5XG4gICAgICAvLyBjaGVjayBvbmx5IHZpZGVvLCBpbWFnZSBlbGVtZW50c1xuICAgICAgY2hpbGRyZW5JbVJlYWR5LmNoZWNrKGNoaWxkcmVuKTtcbiAgICB9KS5vbihcInJlcXVlc3REZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoaWxkcmVuSW1SZWFkeS5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfTtcbiAgX19wcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEltUmVhZHlNYW5hZ2VyKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpKTtcbiAgfTtcbiAgX19wcm90by5jaGVja1ByZVJlYWR5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdLmlzUHJlUmVhZHkgPSB0cnVlO1xuICAgICsrdGhpcy5wcmVSZWFkeUNvdW50O1xuICAgIGlmICh0aGlzLnByZVJlYWR5Q291bnQgPCB0aGlzLnRvdGFsQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9fcHJvdG8uY2hlY2tSZWFkeSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHRoaXMuZWxlbWVudEluZm9zW2luZGV4XS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICArK3RoaXMucmVhZHlDb3VudDtcbiAgICBpZiAodGhpcy5yZWFkeUNvdW50IDwgdGhpcy50b3RhbENvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBfX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIHRhcmdldCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgIGluZm8uaGFzRXJyb3IgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyBpZiB0aGUgaW1hZ2UsIHZpZGVvIGZhaWxzIHRvIGxvYWQuXG4gICAgICogQGtvIOydtOuvuOyngCwg67mE65SU7Jik6rCAIOuhnOuUqeyXkCDsi6TtjKjtlZjrqbQg7J2067Kk7Yq46rCAIOuwnOyDne2VnOuLpC5cbiAgICAgKiBAZXZlbnQgZWcuSW1SZWFkeSNlcnJvclxuICAgICAqIEBwYXJhbSB7ZWcuSW1SZWFkeS5PbkVycm9yfSBlIC0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdlwiKV0pLm9uKHtcbiAgICAgKiAgIGVycm9yOiBlID0+IHtcbiAgICAgKiAgICAgLy8gPGRpdj4uLi48L2Rpdj4sIDAsIDxpbWcgc3JjPVwiRVJSXCIvPlxuICAgICAqICAgICBjb25zb2xlLmxvZyhlLmVsZW1lbnQsIGUuaW5kZXgsIGUudGFyZ2V0KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudChcImVycm9yXCIsIHtcbiAgICAgIGVsZW1lbnQ6IGluZm8uZWxlbWVudCxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZXJyb3JDb3VudDogdGhpcy5nZXRFcnJvckNvdW50KCksXG4gICAgICB0b3RhbEVycm9yQ291bnQ6ICsrdGhpcy50b3RhbEVycm9yQ291bnRcbiAgICB9KSk7XG4gIH07XG4gIF9fcHJvdG8ub25QcmVSZWFkeUVsZW1lbnQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuZWxlbWVudEluZm9zW2luZGV4XTtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBvY2N1cnMgd2hlbiB0aGUgZWxlbWVudCBpcyBwcmUtcmVhZHkgKHdoZW4gdGhlIGxvYWRpbmcgYXR0cmlidXRlIGlzIGFwcGxpZWQgb3IgdGhlIHNpemUgaXMga25vd24pXG4gICAgICogQGtvIO2VtOuLuSDsl5jrpqzrqLztirjqsIAg7IKs7KCEIOykgOu5hOuQmOyXiOydhCDrlYwobG9hZGluZyDsho3shLHsnbQg7KCB7Jqp65CY7JeI6rGw64KYIOyCrOydtOymiOulvCDslYwg7IiYIOyeiOydhCDrlYwpIOydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXG4gICAgICogQGV2ZW50IGVnLkltUmVhZHkjcHJlUmVhZHlFbGVtZW50XG4gICAgICogQHBhcmFtIHtlZy5JbVJlYWR5Lk9uUHJlUmVhZHlFbGVtZW50fSBlIC0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCJFUlJcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqICMjIEphdmFzY3JpcHRcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBJbVJlYWR5IGZyb20gXCJAZWdqcy9pbXJlYWR5XCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbSA9IG5ldyBJbVJlYWR5KCk7IC8vIHVtZDogZWcuSW1SZWFkeVxuICAgICAqIGltLmNoZWNrKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLm9uKHtcbiAgICAgKiAgIHByZVJlYWR5RWxlbWVudDogZSA9PiB7XG4gICAgICogICAgIC8vIDEsIDNcbiAgICAgKiAgICAgLy8gMiwgM1xuICAgICAqICAgICAvLyAzLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUucHJlUmVhZHlDb3VudCwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudChcInByZVJlYWR5RWxlbWVudFwiLCB7XG4gICAgICBlbGVtZW50OiBpbmZvLmVsZW1lbnQsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBwcmVSZWFkeUNvdW50OiB0aGlzLnByZVJlYWR5Q291bnQsXG4gICAgICByZWFkeUNvdW50OiB0aGlzLnJlYWR5Q291bnQsXG4gICAgICB0b3RhbENvdW50OiB0aGlzLnRvdGFsQ291bnQsXG4gICAgICBpc1ByZVJlYWR5OiB0aGlzLmlzUHJlUmVhZHkoKSxcbiAgICAgIGlzUmVhZHk6IHRoaXMuaXNSZWFkeSgpLFxuICAgICAgaGFzTG9hZGluZzogaW5mby5oYXNMb2FkaW5nLFxuICAgICAgaXNTa2lwOiBpbmZvLmlzU2tpcFxuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by5vblByZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQcmVSZWFkeU92ZXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyB3aGVuIGFsbCBlbGVtZW50IGFyZSBwcmUtcmVhZHkgKFdoZW4gYWxsIGVsZW1lbnRzIGhhdmUgdGhlIGxvYWRpbmcgYXR0cmlidXRlIGFwcGxpZWQgb3IgdGhlIHNpemUgaXMga25vd24pXG4gICAgICogQGtvIOuqqOuToCDsl5jrpqzrqLztirjrk6TsnbQg7IKs7KCEIOykgOu5hOuQnCDqsr3smrAgKOuqqOuToCDsl5jrpqzrqLztirjrk6TsnbQgbG9hZGluZyDsho3shLHsnbQg7KCB7Jqp65CY7JeI6rGw64KYIOyCrOydtOymiOulvCDslYwg7IiYIOyeiOuKlCDqsr3smrApIOydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXG4gICAgICogQGV2ZW50IGVnLkltUmVhZHkjcHJlUmVhZHlcbiAgICAgKiBAcGFyYW0ge2VnLkltUmVhZHkuT25QcmVSZWFkeX0gZSAtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5vbih7XG4gICAgICogICBwcmVSZWFkeTogZSA9PiB7XG4gICAgICogICAgIC8vIDAsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5yZWFkeUNvdW50LCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50KFwicHJlUmVhZHlcIiwge1xuICAgICAgcmVhZHlDb3VudDogdGhpcy5yZWFkeUNvdW50LFxuICAgICAgdG90YWxDb3VudDogdGhpcy50b3RhbENvdW50LFxuICAgICAgaXNSZWFkeTogdGhpcy5pc1JlYWR5KCksXG4gICAgICBoYXNMb2FkaW5nOiB0aGlzLmhhc0xvYWRpbmcoKVxuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by5vblJlYWR5RWxlbWVudCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyB3aGVuIHRoZSBlbGVtZW50IGlzIHJlYWR5XG4gICAgICogQGtvIO2VtOuLuSDsl5jrpqzrqLztirjqsIAg7KSA67mE6rCAIOuQmOyXiOydhCDrlYwg7J2067Kk7Yq46rCAIOuwnOyDne2VnOuLpC5cbiAgICAgKiBAZXZlbnQgZWcuSW1SZWFkeSNyZWFkeUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2VnLkltUmVhZHkuT25SZWFkeUVsZW1lbnR9IGUgLSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkub24oe1xuICAgICAqICAgcmVhZHlFbGVtZW50OiBlID0+IHtcbiAgICAgKiAgICAgLy8gMSwgMCwgZmFsc2UsIDNcbiAgICAgKiAgICAgLy8gMiwgMSwgZmFsc2UsIDNcbiAgICAgKiAgICAgLy8gMywgMiwgdHJ1ZSwgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLnJlYWR5Q291bnQsIGUuaW5kZXgsIGUuaGFzRXJyb3IsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQoXCJyZWFkeUVsZW1lbnRcIiwge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZWxlbWVudDogaW5mby5lbGVtZW50LFxuICAgICAgaGFzRXJyb3I6IGluZm8uaGFzRXJyb3IsXG4gICAgICBlcnJvckNvdW50OiB0aGlzLmdldEVycm9yQ291bnQoKSxcbiAgICAgIHRvdGFsRXJyb3JDb3VudDogdGhpcy50b3RhbEVycm9yQ291bnQsXG4gICAgICBwcmVSZWFkeUNvdW50OiB0aGlzLnByZVJlYWR5Q291bnQsXG4gICAgICByZWFkeUNvdW50OiB0aGlzLnJlYWR5Q291bnQsXG4gICAgICB0b3RhbENvdW50OiB0aGlzLnRvdGFsQ291bnQsXG4gICAgICBpc1ByZVJlYWR5OiB0aGlzLmlzUHJlUmVhZHkoKSxcbiAgICAgIGlzUmVhZHk6IHRoaXMuaXNSZWFkeSgpLFxuICAgICAgaGFzTG9hZGluZzogaW5mby5oYXNMb2FkaW5nLFxuICAgICAgaXNQcmVSZWFkeU92ZXI6IHRoaXMuaXNQcmVSZWFkeU92ZXIsXG4gICAgICBpc1NraXA6IGluZm8uaXNTa2lwXG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLm9uUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgb2NjdXJzIHdoZW4gYWxsIGVsZW1lbnQgYXJlIHJlYWR5XG4gICAgICogQGtvIOuqqOuToCDsl5jrpqzrqLztirjrk6TsnbQg7KSA67mE65CcIOqyveyasCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWc64ukLlxuICAgICAqIEBldmVudCBlZy5JbVJlYWR5I3JlYWR5XG4gICAgICogQHBhcmFtIHtlZy5JbVJlYWR5Lk9uUmVhZHl9IGUgLSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkub24oe1xuICAgICAqICAgcHJlUmVhZHk6IGUgPT4ge1xuICAgICAqICAgICAvLyAwLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUucmVhZHlDb3VudCwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogICByZWFkeTogZSA9PiB7XG4gICAgICogICAgIC8vIDEsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5lcnJvckNvdW50LCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50KFwicmVhZHlcIiwge1xuICAgICAgZXJyb3JDb3VudDogdGhpcy5nZXRFcnJvckNvdW50KCksXG4gICAgICB0b3RhbEVycm9yQ291bnQ6IHRoaXMudG90YWxFcnJvckNvdW50LFxuICAgICAgdG90YWxDb3VudDogdGhpcy50b3RhbENvdW50XG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLmdldEVycm9yQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihmdW5jdGlvbiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaGFzRXJyb3I7XG4gICAgfSkubGVuZ3RoO1xuICB9O1xuICBfX3Byb3RvLmhhc0xvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudEluZm9zLnNvbWUoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmhhc0xvYWRpbmc7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBJbVJlYWR5TWFuYWdlcjtcbn0oQ29tcG9uZW50KTtcblxudmFyIEltYWdlTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEltYWdlTG9hZGVyLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBJbWFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBJbWFnZUxvYWRlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uY2hlY2tFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIHZhciBzcmMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICBpZiAoZWxlbWVudC5jb21wbGV0ZSkge1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICAvLyBjb21wbGV0ZVxuICAgICAgICBpZiAoIWVsZW1lbnQubmF0dXJhbFdpZHRoKSB7XG4gICAgICAgICAgdGhpcy5vbkFscmVhZHlFcnJvcihlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2luZyBhbiBleHRlcm5hbCBsYXp5IGxvYWRpbmcgbW9kdWxlXG4gICAgICAgIHRoaXMub25BbHJlYWR5UHJlUmVhZHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudHMoKTtcbiAgICBJU19JRSAmJiBlbGVtZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCBzcmMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBJbWFnZUxvYWRlci5FVkVOVFMgPSBbXCJsb2FkXCIsIFwiZXJyb3JcIl07XG4gIHJldHVybiBJbWFnZUxvYWRlcjtcbn0oTG9hZGVyKTtcblxudmFyIFZpZGVvTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFZpZGVvTG9hZGVyLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBWaWRlb0xvYWRlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBWaWRlb0xvYWRlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uY2hlY2tFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIC8vIEhBVkVfTk9USElORzogMCwgbm8gaW5mb3JtYXRpb24gd2hldGhlciBvciBub3QgdGhlIGF1ZGlvL3ZpZGVvIGlzIHJlYWR5XG4gICAgLy8gSEFWRV9NRVRBREFUQTogMSwgSEFWRV9NRVRBREFUQSAtIG1ldGFkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHlcbiAgICAvLyBIQVZFX0NVUlJFTlRfREFUQTogMiwgZGF0YSBmb3IgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBidXQgbm90IGVub3VnaCBkYXRhIHRvIHBsYXkgbmV4dCBmcmFtZS9taWxsaXNlY29uZFxuICAgIC8vIEhBVkVfRlVUVVJFX0RBVEE6IDMsIGRhdGEgZm9yIHRoZSBjdXJyZW50IGFuZCBhdCBsZWFzdCB0aGUgbmV4dCBmcmFtZSBpcyBhdmFpbGFibGVcbiAgICAvLyBIQVZFX0VOT1VHSF9EQVRBOiA0LCBlbm91Z2ggZGF0YSBhdmFpbGFibGUgdG8gc3RhcnQgcGxheWluZ1xuICAgIGlmIChlbGVtZW50LnJlYWR5U3RhdGUgPj0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5lcnJvcikge1xuICAgICAgdGhpcy5vbkFscmVhZHlFcnJvcihlbGVtZW50KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudHMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgVmlkZW9Mb2FkZXIuRVZFTlRTID0gW1wibG9hZGVkbWV0YWRhdGFcIiwgXCJlcnJvclwiXTtcbiAgcmV0dXJuIFZpZGVvTG9hZGVyO1xufShMb2FkZXIpO1xuXG52YXIgSW1SZWFkeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhJbVJlYWR5LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBJbVJlYWR5KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBfX2Fzc2lnbih7XG4gICAgICBsb2FkZXJzOiB7XG4gICAgICAgIGltZzogSW1hZ2VMb2FkZXIsXG4gICAgICAgIHZpZGVvOiBWaWRlb0xvYWRlclxuICAgICAgfVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG4gIHJldHVybiBJbVJlYWR5O1xufShJbVJlYWR5TWFuYWdlcik7XG5cbnZhciBSRUFDVElWRV9JTVJFQURZID0gZnVuY3Rpb24gKF9hKSB7XG4gIHZhciBzZXRFdmVudHMgPSBfYS5zZXRFdmVudHMsXG4gICAgc2V0TWV0aG9kcyA9IF9hLnNldE1ldGhvZHMsXG4gICAgb24gPSBfYS5vbixcbiAgICBvbkluaXQgPSBfYS5vbkluaXQsXG4gICAgb25EZXN0cm95ID0gX2Eub25EZXN0cm95LFxuICAgIGdldFByb3BzID0gX2EuZ2V0UHJvcHM7XG4gIHNldEV2ZW50cyhFVkVOVFMpO1xuICBzZXRNZXRob2RzKFtcImFkZFwiXSk7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgcmVhY3RpdmVJbVJlYWR5ID0gcmVhY3RpdmUoe1xuICAgIHByZVJlYWR5Q291bnQ6IDAsXG4gICAgcmVhZHlDb3VudDogMCxcbiAgICBlcnJvckNvdW50OiAwLFxuICAgIHRvdGFsRXJyb3JDb3VudDogMCxcbiAgICB0b3RhbENvdW50OiAwLFxuICAgIGlzUHJlUmVhZHk6IGZhbHNlLFxuICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgIGhhc0Vycm9yOiBmYWxzZSxcbiAgICBpc1ByZVJlYWR5T3ZlcjogZmFsc2UsXG4gICAgYWRkOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgcHJvcHMgPSBnZXRQcm9wcygpIHx8IHt9O1xuICB2YXIgaW1SZWFkeSA9IG5ldyBJbVJlYWR5KHByb3BzKTtcbiAgaW1SZWFkeS5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgcmVhY3RpdmVJbVJlYWR5Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgICByZWFjdGl2ZUltUmVhZHkuZXJyb3JDb3VudCA9IGUuZXJyb3JDb3VudDtcbiAgICByZWFjdGl2ZUltUmVhZHkudG90YWxFcnJvckNvdW50ID0gZS50b3RhbEVycm9yQ291bnQ7XG4gIH0pLm9uKFwicHJlUmVhZHlFbGVtZW50XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgcmVhY3RpdmVJbVJlYWR5LnByZVJlYWR5Q291bnQgPSBlLnByZVJlYWR5Q291bnQ7XG4gIH0pLm9uKFwicmVhZHlFbGVtZW50XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgcmVhY3RpdmVJbVJlYWR5LnJlYWR5Q291bnQgPSBlLnJlYWR5Q291bnQ7XG4gICAgcmVhY3RpdmVJbVJlYWR5LmlzUHJlUmVhZHlPdmVyID0gZS5pc1ByZVJlYWR5T3ZlcjtcbiAgfSkub24oXCJwcmVSZWFkeVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmVhY3RpdmVJbVJlYWR5LmlzUHJlUmVhZHkgPSB0cnVlO1xuICB9KS5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZWFjdGl2ZUltUmVhZHkuaXNSZWFkeSA9IHRydWU7XG4gIH0pO1xuICBvbihmdW5jdGlvbiAoXywgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBpbVJlYWR5Lm9uKG5hbWUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaW1SZWFkeS5vZmYobmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gIH0pO1xuICBvbkluaXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxlY3RvciA9IHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5zZWxlY3RvcjtcbiAgICB2YXIgY2hlY2tlZEVsZW1lbnRzID0gW107XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICBjaGVja2VkRWxlbWVudHMgPSBfX3NwcmVhZEFycmF5cyhjaGVja2VkRWxlbWVudHMsIHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjaGlsZCkpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIGNoZWNrZWRFbGVtZW50cy5wdXNoKGNoaWxkKTtcbiAgICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGNoaWxkIHx8IFwiY3VycmVudFwiIGluIGNoaWxkKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY2hpbGQudmFsdWUgfHwgY2hpbGQuY3VycmVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBjaGVja2VkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgY2hlY2tlZEVsZW1lbnRzID0gY2hlY2tlZEVsZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5cyhwcmV2LCBbXS5zbGljZS5jYWxsKGN1ci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZWFjdGl2ZUltUmVhZHkudG90YWxDb3VudCA9IGNoZWNrZWRFbGVtZW50cy5sZW5ndGg7XG4gICAgaW1SZWFkeS5jaGVjayhjaGVja2VkRWxlbWVudHMpO1xuICB9KTtcbiAgb25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICBpbVJlYWR5LmRlc3Ryb3koKTtcbiAgfSk7XG4gIHJldHVybiByZWFjdGl2ZUltUmVhZHk7XG59O1xuXG4vKlxuZWdqcy1pbXJlYWR5XG5Db3B5cmlnaHQgKGMpIDIwMjAtcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmV4cG9ydCBkZWZhdWx0IEltUmVhZHk7XG5leHBvcnQgeyBFVkVOVFMsIEltYWdlTG9hZGVyLCBMb2FkZXIsIEltUmVhZHlNYW5hZ2VyIGFzIE1hbmFnZXIsIFBST1BTLCBSRUFDVElWRV9JTVJFQURZLCBWaWRlb0xvYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1yZWFkeS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiQ29tcG9uZW50RXZlbnQiLCJyZWFjdGl2ZSIsImlzU3RyaW5nIiwiZXh0ZW5kU3RhdGljcyIsImQiLCJiIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2V4dGVuZHMiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJfXyIsImNvbnN0cnVjdG9yIiwiY3JlYXRlIiwiX19hc3NpZ24iLCJhc3NpZ24iLCJ0IiwicyIsImkiLCJuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXBwbHkiLCJfX3NwcmVhZEFycmF5cyIsImlsIiwiciIsImsiLCJhIiwiaiIsImpsIiwiaXNXaW5kb3ciLCJ1YSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlNVUFBPUlRfQ09NUFVURURTVFlMRSIsIklTX0lFIiwidGVzdCIsIlNVUFBPUlRfQURERVZFTlRMSVNURU5FUiIsImRvY3VtZW50IiwiV0lEVEgiLCJIRUlHSFQiLCJQUk9QUyIsIkVWRU5UUyIsImdldEF0dHJpYnV0ZSIsImVsIiwibmFtZSIsInRvQXJyYXkiLCJhcnIiLCJzbGljZSIsImhhc1NpemVBdHRyaWJ1dGUiLCJ0YXJnZXQiLCJwcmVmaXgiLCJoYXNMb2FkaW5nQXR0cmlidXRlIiwiaGFzU2tpcEF0dHJpYnV0ZSIsImFkZEV2ZW50IiwiZWxlbWVudCIsInR5cGUiLCJoYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJpbm5lcldpZHRoIiwiZ2V0U2l6ZSIsImlubmVySGVpZ2h0IiwiZ2V0U3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRTdHlsZSIsInNpemUiLCJwYXJzZUZsb2F0IiwidG9Mb3dlckNhc2UiLCJnZXRDb250ZW50RWxlbWVudHMiLCJ0YWdzIiwic2tpcEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsIm1hcCIsInRhZyIsImpvaW4iLCJmaWx0ZXIiLCJpbmRleE9mIiwiZWxlbWVudHMiLCJhZGRBdXRvU2l6ZXIiLCJyZXNpemVBbGxBdXRvU2l6ZXJzIiwiX19QUkVGSVhfXyIsInB1c2giLCJyZXNpemUiLCJyZW1vdmVBdXRvU2l6ZXIiLCJpbmRleCIsImZpeGVkIiwic3R5bGUiLCJzcGxpY2UiLCJlbGVtZW50UHJlZml4IiwiZGF0YVdpZHRoIiwicGFyc2VJbnQiLCJkYXRhSGVpZ2h0IiwiZm9yRWFjaCIsIkxvYWRlciIsIl9zdXBlciIsIm9wdGlvbnMiLCJfdGhpcyIsImlzUmVhZHkiLCJpc1ByZVJlYWR5IiwiaGFzRGF0YVNpemUiLCJoYXNMb2FkaW5nIiwiaXNTa2lwIiwib25DaGVjayIsImUiLCJjbGVhciIsIm9uRXJyb3IiLCJjaGVja0VsZW1lbnQiLCJ3aXRoUHJlUmVhZHkiLCJvblJlYWR5IiwiX19wcm90byIsImNoZWNrIiwib25BbHJlYWR5UmVhZHkiLCJvbkFscmVhZHlQcmVSZWFkeSIsImFkZEV2ZW50cyIsImRlc3Ryb3kiLCJvZmYiLCJ0cmlnZ2VyIiwib25QcmVSZWFkeSIsIm9uQWxyZWFkeUVycm9yIiwic2V0VGltZW91dCIsIkVsZW1lbnRMb2FkZXIiLCJzZXRIYXNMb2FkaW5nIiwiSW1SZWFkeU1hbmFnZXIiLCJyZWFkeUNvdW50IiwicHJlUmVhZHlDb3VudCIsInRvdGFsQ291bnQiLCJ0b3RhbEVycm9yQ291bnQiLCJpc1ByZVJlYWR5T3ZlciIsImVsZW1lbnRJbmZvcyIsImxvYWRlcnMiLCJsb2FkZXIiLCJnZXRMb2FkZXIiLCJvbiIsImluZm8iLCJjaGVja1ByZVJlYWR5Iiwib25QcmVSZWFkeUVsZW1lbnQiLCJfYSIsImNoZWNrUmVhZHkiLCJvblJlYWR5RWxlbWVudCIsImhhc0Vycm9yIiwiZ2V0VG90YWxDb3VudCIsImV2ZXJ5IiwidGFnTmFtZSIsImtleXMiLCJjaGlsZHJlbiIsInNvbWUiLCJjaGlsZHJlbkltUmVhZHkiLCJjbG9uZSIsImNvbnRlbnRFbGVtZW50cyIsImVycm9yQ291bnQiLCJnZXRFcnJvckNvdW50IiwiSW1hZ2VMb2FkZXIiLCJzcmMiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsInNldEF0dHJpYnV0ZSIsIlZpZGVvTG9hZGVyIiwicmVhZHlTdGF0ZSIsImVycm9yIiwiSW1SZWFkeSIsImltZyIsInZpZGVvIiwiUkVBQ1RJVkVfSU1SRUFEWSIsInNldEV2ZW50cyIsInNldE1ldGhvZHMiLCJvbkluaXQiLCJvbkRlc3Ryb3kiLCJnZXRQcm9wcyIsInJlYWN0aXZlSW1SZWFkeSIsImFkZCIsInByb3BzIiwiaW1SZWFkeSIsIl8iLCJjYWxsYmFjayIsInNlbGVjdG9yIiwiY2hlY2tlZEVsZW1lbnRzIiwiY2hpbGQiLCJFbGVtZW50IiwidmFsdWUiLCJjdXJyZW50IiwicmVkdWNlIiwicHJldiIsImN1ciIsIk1hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/imready/dist/imready.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@egjs/react-view360/dist/view360.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@egjs/react-view360/dist/view360.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoResizer: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.AutoResizer),\n/* harmony export */   Autoplay: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.Autoplay),\n/* harmony export */   Camera: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.Camera),\n/* harmony export */   CameraAnimation: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.CameraAnimation),\n/* harmony export */   ControlBar: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.ControlBar),\n/* harmony export */   ControlBarItem: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.ControlBarItem),\n/* harmony export */   CubemapProjection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.CubemapProjection),\n/* harmony export */   CubestripProjection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.CubestripProjection),\n/* harmony export */   CylindricalProjection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.CylindricalProjection),\n/* harmony export */   DEFAULT_CLASS: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CLASS),\n/* harmony export */   EASING: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.EASING),\n/* harmony export */   ERROR_CODES: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.ERROR_CODES),\n/* harmony export */   EVENTS: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.EVENTS),\n/* harmony export */   EquiangularProjection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.EquiangularProjection),\n/* harmony export */   EquirectProjection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.EquirectProjection),\n/* harmony export */   FullscreenButton: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.FullscreenButton),\n/* harmony export */   GyroControl: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.GyroControl),\n/* harmony export */   Hotspot: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.Hotspot),\n/* harmony export */   HotspotRenderer: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.HotspotRenderer),\n/* harmony export */   LittlePlanetProjection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.LittlePlanetProjection),\n/* harmony export */   LoadingSpinner: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.LoadingSpinner),\n/* harmony export */   Motion: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.Motion),\n/* harmony export */   Object3D: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.Object3D),\n/* harmony export */   PanoControl: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.PanoControl),\n/* harmony export */   PieView: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.PieView),\n/* harmony export */   PlayButton: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.PlayButton),\n/* harmony export */   ProgressBar: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.ProgressBar),\n/* harmony export */   Projection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.Projection),\n/* harmony export */   RotateControl: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.RotateControl),\n/* harmony export */   StereoEquiProjection: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.StereoEquiProjection),\n/* harmony export */   VIEW360_METHODS: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.VIEW360_METHODS),\n/* harmony export */   VideoTime: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.VideoTime),\n/* harmony export */   View360Error: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.View360Error),\n/* harmony export */   VolumeControl: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.VolumeControl),\n/* harmony export */   WebGLRenderer: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer),\n/* harmony export */   XRManager: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.XRManager),\n/* harmony export */   ZoomControl: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.ZoomControl),\n/* harmony export */   \"default\": () => (/* binding */ View360),\n/* harmony export */   getValidProps: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.getValidProps),\n/* harmony export */   withMethods: () => (/* reexport safe */ _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.withMethods)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _egjs_view360__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @egjs/view360 */ \"(ssr)/./node_modules/@egjs/view360/dist/view360.esm.js\");\n/*\nCopyright (c) 2023-present NAVER Corp.\nname: @egjs/view360\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-view360\nversion: 4.0.0-beta.7\n*/ \n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nvar view360SetterNames = Object.getOwnPropertyNames(_egjs_view360__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype).filter(function(name) {\n    var descriptor = Object.getOwnPropertyDescriptor(_egjs_view360__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype, name);\n    if (name.startsWith(\"_\")) return false;\n    if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.value) return false;\n    return !!descriptor.set;\n});\nvar View360 = /*#__PURE__*/ function(_super) {\n    __extends(View360, _super);\n    function View360(props) {\n        var _this = _super.call(this, props) || this;\n        (0,_egjs_view360__WEBPACK_IMPORTED_MODULE_1__.withMethods)(_this, \"_vanillaView360\");\n        return _this;\n    }\n    var __proto = View360.prototype;\n    Object.defineProperty(__proto, \"view360\", {\n        get: function() {\n            return this._vanillaView360;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(__proto, \"element\", {\n        get: function() {\n            return this._containerEl;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    __proto.componentDidMount = function() {\n        this._vanillaView360 = new _egjs_view360__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this._containerEl, this.props);\n        this._bindEvents();\n    };\n    __proto.componentWillUnmount = function() {\n        this._vanillaView360.destroy();\n    };\n    __proto.componentDidUpdate = function(prevProps) {\n        var _this = this;\n        var view360 = this._vanillaView360;\n        view360SetterNames.forEach(function(name) {\n            var oldProp = prevProps[name];\n            var newProp = _this.props[name];\n            if (newProp !== oldProp) {\n                view360[name] = newProp;\n            }\n        });\n    };\n    __proto.render = function() {\n        var _this = this;\n        var _a = this.props, tag = _a.tag, _b = _a.className, className = _b === void 0 ? \"\" : _b, _c = _a.canvasClass, canvasClass = _c === void 0 ? \"\" : _c, restProps = __rest(_a, [\n            \"tag\",\n            \"className\",\n            \"canvasClass\"\n        ]);\n        var Container = tag;\n        var containerClassName = \"\".concat(_egjs_view360__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CLASS.CONTAINER, \" \").concat(className).trim();\n        var canvasClassName = \"\".concat(_egjs_view360__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_CLASS.CANVAS, \" \").concat(canvasClass).trim();\n        var attributes = {};\n        for(var name_1 in restProps){\n            if (!name_1.startsWith(\"on\") && !(name_1 in _egjs_view360__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype)) {\n                attributes[name_1] = restProps[name_1];\n            }\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Container, __assign({}, attributes, {\n            className: containerClassName,\n            ref: function(e) {\n                e && (_this._containerEl = e);\n            }\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"canvas\", {\n            className: canvasClassName\n        }), this.props.children);\n    };\n    __proto._bindEvents = function() {\n        var _this = this;\n        var view360 = this._vanillaView360;\n        Object.keys(_egjs_view360__WEBPACK_IMPORTED_MODULE_1__.EVENTS).forEach(function(eventKey) {\n            var eventName = _egjs_view360__WEBPACK_IMPORTED_MODULE_1__.EVENTS[eventKey];\n            var propName = \"on\".concat(eventName.charAt(0).toUpperCase() + eventName.slice(1));\n            view360.on(eventName, function(e) {\n                e.target = _this;\n                var evtHandler = _this.props[propName];\n                if (evtHandler) {\n                    evtHandler(e);\n                }\n            });\n        });\n    };\n    View360.defaultProps = {\n        tag: \"div\"\n    };\n    return View360;\n}(react__WEBPACK_IMPORTED_MODULE_0__.PureComponent);\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */  //# sourceMappingURL=view360.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvcmVhY3QtdmlldzM2MC9kaXN0L3ZpZXczNjAuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BLEdBQytCO0FBQzZEO0FBQzlEO0FBRTlCOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSwyQkFBMkIsR0FFM0IsSUFBSUssZ0JBQWdCLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztJQUNoQ0YsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQUk7UUFDdkNDLFdBQVcsRUFBRTtJQUNmLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1FBQ2xDRCxFQUFFSSxTQUFTLEdBQUdIO0lBQ2hCLEtBQUssU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQ2pCLElBQUssSUFBSUssS0FBS0wsRUFBRyxJQUFJQyxPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO0lBQzlFO0lBQ0EsT0FBT1AsY0FBY0MsR0FBR0M7QUFDMUI7QUFDQSxTQUFTUyxVQUFVVixDQUFDLEVBQUVDLENBQUM7SUFDckIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFBTSxNQUFNLElBQUlVLFVBQVUseUJBQXlCQyxPQUFPWCxLQUFLO0lBQ3BHRixjQUFjQyxHQUFHQztJQUNqQixTQUFTWTtRQUNQLElBQUksQ0FBQ0MsV0FBVyxHQUFHZDtJQUNyQjtJQUNBQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0MsT0FBT2EsTUFBTSxDQUFDZCxLQUFNWSxDQUFBQSxHQUFHTixTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJTSxJQUFHO0FBQ3BGO0FBQ0EsSUFBSUcsV0FBVztJQUNiQSxXQUFXZCxPQUFPZSxNQUFNLElBQUksU0FBU0QsU0FBU0UsQ0FBQztR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T0FBTztZQUN4QztRQUNGO1FBQ0EscUJBQU9sRixnREFBbUIsQ0FBQzBFLFdBQVdwRCxTQUFTLENBQUMsR0FBRzJELFlBQVk7WUFDN0RYLFdBQVdLO1lBQ1hTLEtBQUssU0FBVXBELENBQUM7Z0JBQ2RBLEtBQU1nQixDQUFBQSxNQUFNTyxZQUFZLEdBQUd2QixDQUFBQTtZQUM3QjtRQUNGLGtCQUFJaEMsZ0RBQW1CLENBQUMsVUFBVTtZQUNoQ3NFLFdBQVdTO1FBQ2IsSUFBSSxJQUFJLENBQUNoQyxLQUFLLENBQUNzQyxRQUFRO0lBQ3pCO0lBQ0FwQyxRQUFRUSxXQUFXLEdBQUc7UUFDcEIsSUFBSVQsUUFBUSxJQUFJO1FBQ2hCLElBQUljLFVBQVUsSUFBSSxDQUFDVixlQUFlO1FBQ2xDNUMsT0FBTzhFLElBQUksQ0FBQ25GLGlEQUFNQSxFQUFFNEQsT0FBTyxDQUFDLFNBQVV3QixRQUFRO1lBQzVDLElBQUlDLFlBQVlyRixpREFBTSxDQUFDb0YsU0FBUztZQUNoQyxJQUFJRSxXQUFXLEtBQUtiLE1BQU0sQ0FBQ1ksVUFBVUUsTUFBTSxDQUFDLEdBQUdDLFdBQVcsS0FBS0gsVUFBVUksS0FBSyxDQUFDO1lBQy9FOUIsUUFBUStCLEVBQUUsQ0FBQ0wsV0FBVyxTQUFVeEQsQ0FBQztnQkFDL0JBLEVBQUU4RCxNQUFNLEdBQUc5QztnQkFDWCxJQUFJK0MsYUFBYS9DLE1BQU1ELEtBQUssQ0FBQzBDLFNBQVM7Z0JBQ3RDLElBQUlNLFlBQVk7b0JBQ2RBLFdBQVcvRDtnQkFDYjtZQUNGO1FBQ0Y7SUFDRjtJQUNBYSxRQUFRbUQsWUFBWSxHQUFHO1FBQ3JCNUIsS0FBSztJQUNQO0lBQ0EsT0FBT3ZCO0FBQ1QsRUFBRTdDLGdEQUFtQjtBQUVyQjs7O0NBR0MsR0FFNkIsQ0FDOUIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ibGVzLXJlbmRlci8uL25vZGVfbW9kdWxlcy9AZWdqcy9yZWFjdC12aWV3MzYwL2Rpc3QvdmlldzM2MC5lc20uanM/ZTc4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL3ZpZXczNjBcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtdmlldzM2MFxudmVyc2lvbjogNC4wLjAtYmV0YS43XG4qL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFZhbmlsbGFWaWV3MzYwX19kZWZhdWx0LCB7IERFRkFVTFRfQ0xBU1MsIEVWRU5UUywgd2l0aE1ldGhvZHMgfSBmcm9tICdAZWdqcy92aWV3MzYwJztcbmV4cG9ydCAqIGZyb20gJ0BlZ2pzL3ZpZXczNjAnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG52YXIgdmlldzM2MFNldHRlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoVmFuaWxsYVZpZXczNjBfX2RlZmF1bHQucHJvdG90eXBlKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFZhbmlsbGFWaWV3MzYwX19kZWZhdWx0LnByb3RvdHlwZSwgbmFtZSk7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkZXNjcmlwdG9yID09PSBudWxsIHx8IGRlc2NyaXB0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlc2NyaXB0b3IudmFsdWUpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvci5zZXQ7XG59KTtcbnZhciBWaWV3MzYwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFZpZXczNjAsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFZpZXczNjAocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICB3aXRoTWV0aG9kcyhfdGhpcywgXCJfdmFuaWxsYVZpZXczNjBcIik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVmlldzM2MC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpZXczNjBcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbmlsbGFWaWV3MzYwO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJFbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl92YW5pbGxhVmlldzM2MCA9IG5ldyBWYW5pbGxhVmlldzM2MF9fZGVmYXVsdCh0aGlzLl9jb250YWluZXJFbCwgdGhpcy5wcm9wcyk7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9O1xuICBfX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3ZhbmlsbGFWaWV3MzYwLmRlc3Ryb3koKTtcbiAgfTtcbiAgX19wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgdmlldzM2MCA9IHRoaXMuX3ZhbmlsbGFWaWV3MzYwO1xuICAgIHZpZXczNjBTZXR0ZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgb2xkUHJvcCA9IHByZXZQcm9wc1tuYW1lXTtcbiAgICAgIHZhciBuZXdQcm9wID0gX3RoaXMucHJvcHNbbmFtZV07XG4gICAgICBpZiAobmV3UHJvcCAhPT0gb2xkUHJvcCkge1xuICAgICAgICB2aWV3MzYwW25hbWVdID0gbmV3UHJvcDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLFxuICAgICAgdGFnID0gX2EudGFnLFxuICAgICAgX2IgPSBfYS5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gXCJcIiA6IF9iLFxuICAgICAgX2MgPSBfYS5jYW52YXNDbGFzcyxcbiAgICAgIGNhbnZhc0NsYXNzID0gX2MgPT09IHZvaWQgMCA/IFwiXCIgOiBfYyxcbiAgICAgIHJlc3RQcm9wcyA9IF9fcmVzdChfYSwgW1widGFnXCIsIFwiY2xhc3NOYW1lXCIsIFwiY2FudmFzQ2xhc3NcIl0pO1xuICAgIHZhciBDb250YWluZXIgPSB0YWc7XG4gICAgdmFyIGNvbnRhaW5lckNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KERFRkFVTFRfQ0xBU1MuQ09OVEFJTkVSLCBcIiBcIikuY29uY2F0KGNsYXNzTmFtZSkudHJpbSgpO1xuICAgIHZhciBjYW52YXNDbGFzc05hbWUgPSBcIlwiLmNvbmNhdChERUZBVUxUX0NMQVNTLkNBTlZBUywgXCIgXCIpLmNvbmNhdChjYW52YXNDbGFzcykudHJpbSgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIHJlc3RQcm9wcykge1xuICAgICAgaWYgKCFuYW1lXzEuc3RhcnRzV2l0aChcIm9uXCIpICYmICEobmFtZV8xIGluIFZhbmlsbGFWaWV3MzYwX19kZWZhdWx0LnByb3RvdHlwZSkpIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXzFdID0gcmVzdFByb3BzW25hbWVfMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lciwgX19hc3NpZ24oe30sIGF0dHJpYnV0ZXMsIHtcbiAgICAgIGNsYXNzTmFtZTogY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgcmVmOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlICYmIChfdGhpcy5fY29udGFpbmVyRWwgPSBlKTtcbiAgICAgIH1cbiAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XG4gICAgICBjbGFzc05hbWU6IGNhbnZhc0NsYXNzTmFtZVxuICAgIH0pLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfTtcbiAgX19wcm90by5fYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciB2aWV3MzYwID0gdGhpcy5fdmFuaWxsYVZpZXczNjA7XG4gICAgT2JqZWN0LmtleXMoRVZFTlRTKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEtleSkge1xuICAgICAgdmFyIGV2ZW50TmFtZSA9IEVWRU5UU1tldmVudEtleV07XG4gICAgICB2YXIgcHJvcE5hbWUgPSBcIm9uXCIuY29uY2F0KGV2ZW50TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGV2ZW50TmFtZS5zbGljZSgxKSk7XG4gICAgICB2aWV3MzYwLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS50YXJnZXQgPSBfdGhpcztcbiAgICAgICAgdmFyIGV2dEhhbmRsZXIgPSBfdGhpcy5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmIChldnRIYW5kbGVyKSB7XG4gICAgICAgICAgZXZ0SGFuZGxlcihlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIFZpZXczNjAuZGVmYXVsdFByb3BzID0ge1xuICAgIHRhZzogXCJkaXZcIlxuICB9O1xuICByZXR1cm4gVmlldzM2MDtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cblxuZXhwb3J0IHsgVmlldzM2MCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3MzYwLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlZhbmlsbGFWaWV3MzYwX19kZWZhdWx0IiwiREVGQVVMVF9DTEFTUyIsIkVWRU5UUyIsIndpdGhNZXRob2RzIiwiZXh0ZW5kU3RhdGljcyIsImQiLCJiIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2V4dGVuZHMiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJfXyIsImNvbnN0cnVjdG9yIiwiY3JlYXRlIiwiX19hc3NpZ24iLCJhc3NpZ24iLCJ0IiwicyIsImkiLCJuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXBwbHkiLCJfX3Jlc3QiLCJlIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidmlldzM2MFNldHRlck5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZpbHRlciIsIm5hbWUiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwic3RhcnRzV2l0aCIsInZhbHVlIiwic2V0IiwiVmlldzM2MCIsIl9zdXBlciIsInByb3BzIiwiX3RoaXMiLCJfX3Byb3RvIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJfdmFuaWxsYVZpZXczNjAiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiX2NvbnRhaW5lckVsIiwiY29tcG9uZW50RGlkTW91bnQiLCJfYmluZEV2ZW50cyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZGVzdHJveSIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInZpZXczNjAiLCJmb3JFYWNoIiwib2xkUHJvcCIsIm5ld1Byb3AiLCJyZW5kZXIiLCJfYSIsInRhZyIsIl9iIiwiY2xhc3NOYW1lIiwiX2MiLCJjYW52YXNDbGFzcyIsInJlc3RQcm9wcyIsIkNvbnRhaW5lciIsImNvbnRhaW5lckNsYXNzTmFtZSIsImNvbmNhdCIsIkNPTlRBSU5FUiIsInRyaW0iLCJjYW52YXNDbGFzc05hbWUiLCJDQU5WQVMiLCJhdHRyaWJ1dGVzIiwibmFtZV8xIiwiY3JlYXRlRWxlbWVudCIsInJlZiIsImNoaWxkcmVuIiwia2V5cyIsImV2ZW50S2V5IiwiZXZlbnROYW1lIiwicHJvcE5hbWUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwib24iLCJ0YXJnZXQiLCJldnRIYW5kbGVyIiwiZGVmYXVsdFByb3BzIiwiUHVyZUNvbXBvbmVudCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/react-view360/dist/view360.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@egjs/view360/dist/view360.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@egjs/view360/dist/view360.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoResizer: () => (/* binding */ AutoResizer),\n/* harmony export */   Autoplay: () => (/* binding */ Autoplay),\n/* harmony export */   Camera: () => (/* binding */ Camera),\n/* harmony export */   CameraAnimation: () => (/* binding */ CameraAnimation),\n/* harmony export */   ControlBar: () => (/* binding */ ControlBar),\n/* harmony export */   ControlBarItem: () => (/* binding */ ControlBarItem),\n/* harmony export */   CubemapProjection: () => (/* binding */ CubemapProjection),\n/* harmony export */   CubestripProjection: () => (/* binding */ CubestripProjection),\n/* harmony export */   CylindricalProjection: () => (/* binding */ CylindricalProjection),\n/* harmony export */   DEFAULT_CLASS: () => (/* binding */ DEFAULT_CLASS),\n/* harmony export */   EASING: () => (/* binding */ EASING),\n/* harmony export */   ERROR_CODES: () => (/* binding */ ERROR_CODES),\n/* harmony export */   EVENTS: () => (/* binding */ EVENTS),\n/* harmony export */   EquiangularProjection: () => (/* binding */ EquiangularProjection),\n/* harmony export */   EquirectProjection: () => (/* binding */ EquirectProjection),\n/* harmony export */   FullscreenButton: () => (/* binding */ FullscreenButton),\n/* harmony export */   GyroControl: () => (/* binding */ GyroControl),\n/* harmony export */   Hotspot: () => (/* binding */ Hotspot),\n/* harmony export */   HotspotRenderer: () => (/* binding */ HotspotRenderer),\n/* harmony export */   LittlePlanetProjection: () => (/* binding */ LittlePlanetProjection),\n/* harmony export */   LoadingSpinner: () => (/* binding */ LoadingSpinner),\n/* harmony export */   Motion: () => (/* binding */ Motion),\n/* harmony export */   Object3D: () => (/* binding */ Object3D),\n/* harmony export */   PanoControl: () => (/* binding */ PanoControl),\n/* harmony export */   PieView: () => (/* binding */ PieView),\n/* harmony export */   PlayButton: () => (/* binding */ PlayButton),\n/* harmony export */   ProgressBar: () => (/* binding */ ProgressBar),\n/* harmony export */   Projection: () => (/* binding */ Projection),\n/* harmony export */   RotateControl: () => (/* binding */ RotateControl),\n/* harmony export */   StereoEquiProjection: () => (/* binding */ StereoEquiProjection),\n/* harmony export */   VIEW360_METHODS: () => (/* binding */ VIEW360_METHODS),\n/* harmony export */   VideoTime: () => (/* binding */ VideoTime),\n/* harmony export */   View360Error: () => (/* binding */ View360Error),\n/* harmony export */   VolumeControl: () => (/* binding */ VolumeControl),\n/* harmony export */   WebGLRenderer: () => (/* binding */ WebGLRenderer),\n/* harmony export */   XRManager: () => (/* binding */ XRManager),\n/* harmony export */   ZoomControl: () => (/* binding */ ZoomControl),\n/* harmony export */   \"default\": () => (/* binding */ View360),\n/* harmony export */   getValidProps: () => (/* binding */ getValidProps),\n/* harmony export */   withMethods: () => (/* binding */ withMethods)\n/* harmony export */ });\n/* harmony import */ var _egjs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @egjs/component */ \"(ssr)/./node_modules/@egjs/component/dist/component.esm.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/./node_modules/gl-matrix/esm/quat.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix */ \"(ssr)/./node_modules/gl-matrix/esm/vec2.js\");\n/* harmony import */ var _egjs_imready__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @egjs/imready */ \"(ssr)/./node_modules/@egjs/imready/dist/imready.esm.js\");\n/*\nCopyright (c) 2023-present NAVER Corp.\nname: @egjs/view360\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-view360\nversion: 4.0.0-beta.7\n*/ \n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Error thrown by {@link View360}\r\n * @ko {@link View360}이 발생시킨 에러\r\n * @since 4.0.0\r\n */ class View360Error extends Error {\n    /**\r\n   * Create new instance of View360Error\r\n   * @ko View360Error의 인스턴스를 생성합니다.\r\n   * @param message - Error message {@ko 에러 메시지}\r\n   * @param code - Error code {@ko 에러 코드}\r\n   */ constructor(message, code){\n        super(message);\n        Object.setPrototypeOf(this, View360Error.prototype);\n        this.name = \"View360Error\";\n        this.code = code;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Error codes of {@link View360Error}\r\n * @ko {@link View360Error}가 가질 수 있는 에러 코드 값들\r\n * @since 4.0.0\r\n */ const ERROR_CODES = {\n    /**\r\n   * The given value's type is not expected\r\n   * @ko 주어진 값의 타입이 잘못되었을 경우\r\n   * @since 4.0.0\r\n   */ WRONG_TYPE: 0,\n    /**\r\n   * The given value is not a supported option\r\n   * @ko 잘못된 옵션을 받았을 경우\r\n   * @since 4.0.0\r\n   */ WRONG_OPTION: 1,\n    /**\r\n   * The element with given CSS selector does not exist\r\n   * @ko 주어진 CSS 셀렉터로 엘리먼트를 찾지 못했을 경우\r\n   * @since 4.0.0\r\n   */ ELEMENT_NOT_FOUND: 2,\n    /**\r\n   * Couldn't find canvas element inside the given container element.\r\n   * @ko 컨테이너 엘리먼트 내부에서 캔버스 엘리먼트를 찾지 못했을 경우\r\n   * @since 4.0.0\r\n   */ CANVAS_NOT_FOUND: 3,\n    /**\r\n   * The browser does not support WebGL\r\n   * @ko 브라우저가 WebGL을 지원하지 않는 경우\r\n   * @since 4.0.0\r\n   */ WEBGL_NOT_SUPPORTED: 4,\n    /**\r\n   * Failed creating canvas 2D context\r\n   * @ko 캔버스 2D 컨텍스트를 생성하지 못한 경우\r\n   * @since 4.0.0\r\n   */ FAILED_CREATE_CONTEXT_2D: 5,\n    /**\r\n   * `init()` is called before setting {@link View360Options#projection}\r\n   * @ko {@link View360Options#projection}을 설정하기 전에 `init()`이 호출된 경우\r\n   * @since 4.0.0\r\n   */ PROVIDE_PROJECTION_FIRST: 6,\n    /**\r\n   * Failed linking WebGL program. Only can be thrown when {@link View360Options#debug} is `true`.\r\n   * @ko WebGL 프로그램 링크에 실패한 경우. {@link View360Options#debug}를 `true`로 설정한 경우에만 발생할 수 있습니다.\r\n   * @since 4.0.0\r\n   */ FAILED_LINKING_PROGRAM: 7,\n    /**\r\n   * Arguments are not sufficient for the given property.\r\n   * @ko 프로퍼티에 값이 충분히 주어지지 않았을 때\r\n   * @since 4.0.0\r\n   */ INSUFFICIENT_ARGS: 8\n};\nconst MESSAGES = {\n    WRONG_TYPE: (val, types)=>`${typeof val} is not a ${types.map((type)=>`\"${type}\"`).join(\" or \")}.`,\n    WRONG_OPTION: (val, optionName)=>`Bad option: given \"${val}\" for option \"${optionName}\".`,\n    ELEMENT_NOT_FOUND: (query)=>`Element with selector \"${query}\" not found.`,\n    CANVAS_NOT_FOUND: \"The canvas element was not found inside the given root element.\",\n    WEBGL_NOT_SUPPORTED: \"WebGL is not supported on this browser.\",\n    FAILED_CREATE_CONTEXT_2D: \"Failed to create canvas 2D context\",\n    PROVIDE_PROJECTION_FIRST: '\"projection\" should be provided before initialization.',\n    FAILED_LINKING_PROGRAM: (msg, shaderLog)=>`Failed linking WebGL program - \"${msg}\\nShader compile Log: ${shaderLog}`,\n    INSUFFICIENT_ARGS: (val, name)=>`Insufficient arguments: given \"${val}\" for \"${name}\".`\n};\nvar ERROR = {\n    CODES: ERROR_CODES,\n    MESSAGES\n};\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ const EVENTS$1 = {\n    MOUSE_DOWN: \"mousedown\",\n    MOUSE_MOVE: \"mousemove\",\n    MOUSE_UP: \"mouseup\",\n    TOUCH_START: \"touchstart\",\n    TOUCH_MOVE: \"touchmove\",\n    TOUCH_END: \"touchend\",\n    WHEEL: \"wheel\",\n    RESIZE: \"resize\",\n    CONTEXT_MENU: \"contextmenu\",\n    MOUSE_ENTER: \"mouseenter\",\n    MOUSE_LEAVE: \"mouseleave\",\n    POINTER_DOWN: \"pointerdown\",\n    POINTER_MOVE: \"pointermove\",\n    POINTER_UP: \"pointerup\",\n    POINTER_CANCEL: \"pointercancel\",\n    POINTER_ENTER: \"pointerenter\",\n    POINTER_LEAVE: \"pointerleave\",\n    KEY_DOWN: \"keydown\",\n    KEY_UP: \"keyup\",\n    LOAD: \"load\",\n    ERROR: \"error\",\n    CLICK: \"click\",\n    DOUBLE_CLICK: \"dblclick\",\n    CONTEXT_CREATE_ERROR: \"webglcontextcreationerror\",\n    CONTEXT_LOST: \"webglcontextlost\",\n    CONTEXT_RESTORED: \"webglcontextrestored\",\n    DEVICE_ORIENTATION: \"deviceorientation\",\n    DEVICE_MOTION: \"devicemotion\",\n    ORIENTATION_CHANGE: \"orientationchange\",\n    VIDEO_PLAY: \"play\",\n    VIDEO_PAUSE: \"pause\",\n    VIDEO_LOADED_DATA: \"loadeddata\",\n    VIDEO_VOLUME_CHANGE: \"volumechange\",\n    VIDEO_TIME_UPDATE: \"timeupdate\",\n    VIDEO_DURATION_CHANGE: \"durationchange\",\n    VIDEO_CAN_PLAYTHROUGH: \"canplaythrough\",\n    TRANSITION_END: \"transitionend\",\n    XR_END: \"end\"\n};\nconst EL_DIV = \"div\";\nconst EL_BUTTON = \"button\";\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\nvar MOUSE_BUTTON;\n(function(MOUSE_BUTTON) {\n    MOUSE_BUTTON[MOUSE_BUTTON[\"LEFT\"] = 0] = \"LEFT\";\n    MOUSE_BUTTON[MOUSE_BUTTON[\"MIDDLE\"] = 1] = \"MIDDLE\";\n    MOUSE_BUTTON[MOUSE_BUTTON[\"RIGHT\"] = 2] = \"RIGHT\";\n})(MOUSE_BUTTON || (MOUSE_BUTTON = {}));\nconst CURSOR = {\n    GRAB: \"grab\",\n    GRABBING: \"grabbing\",\n    NONE: \"\"\n};\nconst KEY_DIRECTION = [\n    \"LEFT\",\n    \"UP\",\n    \"RIGHT\",\n    \"DOWN\"\n];\nvar DIRECTION_KEY_CODE;\n(function(DIRECTION_KEY_CODE) {\n    DIRECTION_KEY_CODE[DIRECTION_KEY_CODE[\"LEFT\"] = 37] = \"LEFT\";\n    DIRECTION_KEY_CODE[DIRECTION_KEY_CODE[\"UP\"] = 38] = \"UP\";\n    DIRECTION_KEY_CODE[DIRECTION_KEY_CODE[\"RIGHT\"] = 39] = \"RIGHT\";\n    DIRECTION_KEY_CODE[DIRECTION_KEY_CODE[\"DOWN\"] = 40] = \"DOWN\";\n})(DIRECTION_KEY_CODE || (DIRECTION_KEY_CODE = {}));\nconst SPACE_KEY_CODE = 32;\nconst DIRECTION_KEY_NAME = {\n    LEFT: \"ArrowLeft\",\n    UP: \"ArrowUp\",\n    RIGHT: \"ArrowRight\",\n    DOWN: \"ArrowDown\"\n};\nconst SPACE_KEY_NAME = \" \";\nconst FULLSCREEN_REQUEST = [\n    \"requestFullscreen\",\n    \"webkitRequestFullscreen\",\n    \"webkitRequestFullScreen\",\n    \"webkitCancelFullScreen\",\n    \"mozRequestFullScreen\",\n    \"msRequestFullscreen\"\n];\nconst FULLSCREEN_ELEMENT = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"webkitCurrentFullScreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n];\nconst FULLSCREEN_EXIT = [\n    \"exitFullscreen\",\n    \"webkitExitFullscreen\",\n    \"webkitCancelFullScreen\",\n    \"mozCancelFullScreen\",\n    \"msExitFullscreen\"\n];\nconst FULLSCREEN_CHANGE = [\n    \"fullscreenchange\",\n    \"webkitfullscreenchange\",\n    \"mozfullscreenchange\",\n    \"MSFullscreenChange\"\n];\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Default class names\r\n * @ko 기본 클래스 이름들\r\n * @since 4.0.0\r\n */ const DEFAULT_CLASS = {\n    CONTAINER: \"view360-container\",\n    CANVAS: \"view360-canvas\",\n    CTX_LOST: \"view360-ctx-lost\",\n    IN_VR: \"view360-vr-presenting\",\n    HOTSPOT_CONTAINER: \"view360-hotspots\",\n    HOTSPOT: \"view360-hotspot\",\n    HOTSPOT_VISIBLE: \"view360-hotspot-visible\",\n    HOTSPOT_FLIP_X: \"view360-hotspot-flip-x\",\n    HOTSPOT_FLIP_Y: \"view360-hotspot-flip-y\"\n};\n/**\r\n * Event names\r\n * @ko 이벤트 이름들\r\n * @since 4.0.0\r\n * @example\r\n * ```ts\r\n * import View360, { EVENTS } from \"@egjs/view360\";\r\n *\r\n * const viewer = new View360(\"#el_id\");\r\n *\r\n * viewer.on(EVENTS.READY, evt => {\r\n *   console.log(\"View360 is ready!\");\r\n * });\r\n * ```\r\n */ const EVENTS = {\n    READY: \"ready\",\n    LOAD_START: \"loadStart\",\n    LOAD: \"load\",\n    PROJECTION_CHANGE: \"projectionChange\",\n    RESIZE: \"resize\",\n    BEFORE_RENDER: \"beforeRender\",\n    RENDER: \"render\",\n    INPUT_START: \"inputStart\",\n    INPUT_END: \"inputEnd\",\n    VIEW_CHANGE: \"viewChange\",\n    STATIC_CLICK: \"staticClick\",\n    VR_START: \"vrStart\",\n    VR_END: \"vrEnd\"\n};\n/**\r\n * Collection of predefined easing functions\r\n * @ko 미리 정의된 easing 함수들\r\n */ const EASING = {\n    LINEAR: (x)=>x,\n    SINE_WAVE: (x)=>Math.sin(x * Math.PI * 2),\n    EASE_OUT_CUBIC: (x)=>1 - Math.pow(1 - x, 3),\n    EASE_OUT_BOUNCE: (x)=>{\n        const n1 = 7.5625;\n        const d1 = 2.75;\n        if (x < 1 / d1) {\n            return n1 * x * x;\n        } else if (x < 2 / d1) {\n            return n1 * (x -= 1.5 / d1) * x + 0.75;\n        } else if (x < 2.5 / d1) {\n            return n1 * (x -= 2.25 / d1) * x + 0.9375;\n        } else {\n            return n1 * (x -= 2.625 / d1) * x + 0.984375;\n        }\n    }\n};\nvar _a;\nconst CAMERA_EVENTS = {\n    CHANGE: \"change\",\n    ANIMATION_END: \"animationEnd\"\n};\nconst OBJECT_3D_EVENTS = {\n    UPDATE: \"update\"\n};\nconst CONTROL_EVENTS = {\n    INPUT_START: \"inputStart\",\n    CHANGE: \"change\",\n    INPUT_END: \"inputEnd\",\n    ENABLE: \"enable\",\n    DISABLE: \"disable\",\n    STATIC_CLICK: \"staticClick\"\n};\nconst DEG_TO_RAD = Math.PI / 180;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEFAULT_EASING = EASING.EASE_OUT_CUBIC;\nconst DEFAULT_ANIMATION_DURATION = 300;\nconst INFINITE_RANGE = {\n    min: -Infinity,\n    max: Infinity\n};\nconst DEFAULT_PITCH_RANGE = {\n    min: -90,\n    max: 90\n};\nconst DEFAULT_ZOOM_RANGE = {\n    min: 0.6,\n    max: 10\n};\nvar ROTATE;\n(function(ROTATE) {\n    ROTATE[ROTATE[\"ZERO\"] = 0] = \"ZERO\";\n    ROTATE[ROTATE[\"CW_90\"] = 1] = \"CW_90\";\n    ROTATE[ROTATE[\"CCW_90\"] = 2] = \"CCW_90\";\n    ROTATE[ROTATE[\"CW_180\"] = 3] = \"CW_180\";\n})(ROTATE || (ROTATE = {}));\n// Custom event name for video time change\nconst VIDEO_TIME_CHANGE_EVENT = \"view360videotimechange\";\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nconst SESSION_VR = \"immersive-vr\";\nconst XR_REFERENCE_SPACE = \"local\";\nconst EPSILON = (_a = Number.EPSILON) !== null && _a !== void 0 ? _a : 2.220446049250313e-16;\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ const isString = (val)=>typeof val === \"string\";\nconst isElement = (val)=>!!val && val.nodeType === Node.ELEMENT_NODE;\nconst createElement = (className, tag = EL_DIV)=>{\n    const el = document.createElement(tag);\n    el.classList.add(className);\n    return el;\n};\nconst getNullableElement = (el, parent)=>{\n    let targetEl = null;\n    if (isString(el)) {\n        const parentEl = parent ? parent : document;\n        const queryResult = parentEl.querySelector(el);\n        if (!queryResult) {\n            return null;\n        }\n        targetEl = queryResult;\n    } else if (isElement(el)) {\n        targetEl = el;\n    }\n    return targetEl;\n};\nconst getElement = (el, parent)=>{\n    const targetEl = getNullableElement(el, parent);\n    if (!targetEl) {\n        if (isString(el)) {\n            throw new View360Error(ERROR.MESSAGES.ELEMENT_NOT_FOUND(el), ERROR.CODES.ELEMENT_NOT_FOUND);\n        } else {\n            throw new View360Error(ERROR.MESSAGES.WRONG_TYPE(el, [\n                \"HTMLElement\",\n                \"string\"\n            ]), ERROR.CODES.WRONG_TYPE);\n        }\n    }\n    return targetEl;\n};\nconst findCanvas = (root, selector)=>{\n    const canvas = root.querySelector(selector);\n    if (!canvas) {\n        throw new View360Error(ERROR.MESSAGES.CANVAS_NOT_FOUND, ERROR.CODES.CANVAS_NOT_FOUND);\n    }\n    return canvas;\n};\nconst range = (end)=>{\n    if (!end || end <= 0) {\n        return [];\n    }\n    return Array.apply(0, Array(end)).map((undef, idx)=>idx);\n};\nconst clamp = (x, min, max)=>Math.max(Math.min(x, max), min);\n// Linear interpolation between a and b\nconst lerp = (a, b, t)=>{\n    return a * (1 - t) + b * t;\n};\nconst circulate = (val, min, max)=>{\n    const size = Math.abs(max - min);\n    if (val < min) {\n        const offset = (min - val) % size;\n        val = max - offset;\n    } else if (val > max) {\n        const offset = (val - max) % size;\n        val = min + offset;\n    }\n    return val;\n};\nconst findIndex = (array, checker)=>{\n    for(let idx = 0; idx < array.length; idx++){\n        if (checker(array[idx])) {\n            return idx;\n        }\n    }\n    return -1;\n};\nconst getObjectOption = (val)=>typeof val === \"object\" ? val : {};\nconst toVerticalFov = (fovRadian, aspect)=>{\n    return Math.atan(Math.tan(fovRadian * 0.5) / aspect) * 2;\n};\nconst reorderCube = (arr, order, defaultOrder = \"RLUDFB\")=>{\n    return defaultOrder.split(\"\").map((face)=>order.indexOf(face)).map((index)=>arr[index]);\n};\nconst isFullscreen = ()=>{\n    if (!document) return false;\n    for (const key of FULLSCREEN_ELEMENT){\n        if (document[key]) return true;\n    }\n    return false;\n};\nconst sensorCanBeEnabledIOS = ()=>{\n    return window.isSecureContext && !!DeviceMotionEvent && \"requestPermission\" in DeviceMotionEvent;\n};\nconst hfovToZoom = (baseFov, fov)=>{\n    const renderingWidth = Math.tan(DEG_TO_RAD * baseFov * 0.5);\n    const zoomedWidth = Math.tan(DEG_TO_RAD * fov * 0.5);\n    return renderingWidth / zoomedWidth;\n};\nconst eulerToQuat = (out, yaw, pitch, roll)=>{\n    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.identity(out);\n    const pitchThreshold = 0.01;\n    const pitchClamped = clamp(pitch, -90 + pitchThreshold, 90 - pitchThreshold);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateY(out, out, yaw * DEG_TO_RAD);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateX(out, out, pitchClamped * DEG_TO_RAD);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateZ(out, out, roll * DEG_TO_RAD);\n    return out;\n};\n/**\r\n * Extract euler angles from the quaternion, except roll(z-axis rotation)\r\n * @hidden\r\n */ const quatToEuler = (quaternion)=>{\n    const x = quaternion[0];\n    const y = quaternion[1];\n    const z = quaternion[2];\n    const w = quaternion[3];\n    const x2 = x * x;\n    const y2 = y * y;\n    const z2 = z * z;\n    const w2 = w * w;\n    const unit = x2 + y2 + z2 + w2;\n    const test = x * w - y * z;\n    let pitch, yaw;\n    if (test > 0.499995 * unit) {\n        // singularity at the north pole\n        pitch = Math.PI / 2;\n        yaw = 2 * Math.atan2(y, x);\n    } else if (test < -0.499995 * unit) {\n        // singularity at the south pole\n        pitch = -Math.PI / 2;\n        yaw = -2 * Math.atan2(y, x);\n    } else {\n        const view = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 1);\n        const up = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(view, view, quaternion);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(up, up, quaternion);\n        const viewXZ = Math.sqrt(view[0] * view[0] + view[2] * view[2]);\n        pitch = Math.atan2(-view[1], viewXZ);\n        yaw = Math.atan2(view[0], view[2]);\n    }\n    return {\n        pitch: clamp(pitch * RAD_TO_DEG, -90, 90),\n        yaw: circulate(yaw * RAD_TO_DEG, 0, 360)\n    };\n};\n/*\r\n * Copyright (c) 2020 NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Interpolator between two values with duration\r\n * @ko 특정 시간동안 두 값을 보간해주는 보간기\r\n * @since 4.0.0\r\n */ class Motion {\n    /**\r\n   * Current interpolated value\r\n   * @ko 현재 보간된 값\r\n   * @since 4.0.0\r\n   */ get val() {\n        return this._val;\n    }\n    /**\r\n   * Start(from) value of interpolation\r\n   * @ko 보간 시작 값\r\n   * @since 4.0.0\r\n   */ get start() {\n        return this._start;\n    }\n    /**\r\n   * End(to) value of interpolation\r\n   * @ko 보간 끝 값\r\n   * @since 4.0.0\r\n   */ get end() {\n        return this._end;\n    }\n    /**\r\n   * Interpolation progress value (0 ~ 1)\r\n   * @ko 현재 보간 진행정도 (0 ~ 1)\r\n   * @since 4.0.0\r\n   */ get progress() {\n        return this._progress;\n    }\n    /**\r\n   * Whether the interpolation is in active state.\r\n   * @ko 보간 진행중인지 여부. `true`일 경우 보간이 진행중입니다.\r\n   * @since 4.0.0\r\n   */ get activated() {\n        return this._activated;\n    }\n    /**\r\n   * Duration of the interpolation\r\n   * @ko 보간할 시간\r\n   * @since 4.0.0\r\n   */ get duration() {\n        return this._duration;\n    }\n    set duration(val) {\n        this._duration = val;\n    }\n    /**\r\n   * Whether to loop interpolation on finish\r\n   * @ko 보간이 끝난 이후에 다시 시작할지 여부\r\n   * @since 4.0.0\r\n   */ get loop() {\n        return this._loop;\n    }\n    set loop(val) {\n        this._loop = val;\n    }\n    /**\r\n   * Range of the interpolation\r\n   * @ko 보간 범위\r\n   * @since 4.0.0\r\n   */ get range() {\n        return this._range;\n    }\n    /**\r\n   * Easing function of the interpolation\r\n   * @ko 보간에 사용되는 easing function\r\n   * @since 4.0.0\r\n   */ get easing() {\n        return this._easing;\n    }\n    set easing(val) {\n        this._easing = val;\n    }\n    /**\r\n   * Create new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options Options {@ko 옵션들}\r\n   * @param options.duration Duration of the interpolation {@ko 보간할 시간}\r\n   * @param options.loop Whether to loop interpolation on finish {@ko 보간이 끝난 이후에 다시 시작할지 여부}\r\n   * @param options.range Range of the interpolation {@ko 보간 범위}\r\n   * @param options.loop Easing function of the interpolation {@ko 보간에 사용되는 easing function}\r\n   */ constructor({ duration = DEFAULT_ANIMATION_DURATION, loop = false, range = {\n        min: 0,\n        max: 1\n    }, easing = DEFAULT_EASING } = {}){\n        this._duration = duration;\n        this._loop = loop;\n        this._range = range;\n        this._easing = easing;\n        this._activated = false;\n        this.reset(0);\n    }\n    /**\r\n   * Update motion and progress it by given deltaTime\r\n   * @ko 주어진 deltaTime만큼 보간을 진행합니다.\r\n   * @param deltaTime - number of milisec to update motion {@ko 보간을 진행할 시간, 밀리초 단위}\r\n   * @returns Difference(delta) of the value from the last update. {@ko 지난 업데이트 이후의 값 변화량}\r\n   * @since 4.0.0\r\n   */ update(deltaTime) {\n        if (!this._activated) {\n            this._val = this._end;\n            return 0;\n        }\n        const start = this._start;\n        const end = this._end;\n        const duration = this._duration;\n        const prev = this._val;\n        const loop = this._loop;\n        const nextProgress = this._progress + deltaTime / duration;\n        this._progress = loop ? circulate(nextProgress, 0, 1) : clamp(nextProgress, 0, 1);\n        const easedProgress = this._easing(this._progress);\n        this._val = lerp(start, end, easedProgress);\n        if (!loop && this._progress >= 1) {\n            this._activated = false;\n        }\n        return this._val - prev;\n    }\n    /**\r\n   * Set `start`, `end` to the given value and set `progress` to 0.\r\n   * @ko 주어진 값으로 시작 지점, 끝 지점을 초기화하고 progress를 0으로 세팅합니다.\r\n   * @param defaultVal - Value to reset {@ko 초기화할 값}\r\n   * @since 4.0.0\r\n   */ reset(defaultVal) {\n        const range = this._range;\n        const val = clamp(defaultVal, range.min, range.max);\n        this._start = val;\n        this._end = val;\n        this._val = val;\n        this._progress = 0;\n        this._activated = false;\n    }\n    /**\r\n   * Add delta to start & end and current value.\r\n   * @ko 현재 & 끝 및 현재 값에 주어진 값을 더합니다.\r\n   * @param delta - Delta value to add {@ko 추가할 값}\r\n   */ add(delta) {\n        const range = this._range;\n        this._start = clamp(this._start + delta, range.min, range.max);\n        this._end = clamp(this._end + delta, range.min, range.max);\n        this._val = clamp(this._val + delta, range.min, range.max);\n    }\n    /**\r\n   * Set current value to start, and end to current value + delta, then reset progress to 0.\r\n   * @ko 현재 값을 시작 지점으로, 그에서 delta만큼 추가된 값을 끝점으로 하고 progress를 0으로 갱신합니다.\r\n   * @param delta - Delta value to add {@ko 추가할 값}\r\n   */ setNewEndByDelta(delta) {\n        const range = this._range;\n        this._start = this._val;\n        this._end = clamp(this._end + delta, range.min, range.max);\n        this._progress = 0;\n        this._activated = true;\n    }\n    /**\r\n   * Set new range of the interpolation.\r\n   * @ko 보간의 범위를 변경합니다.\r\n   * @param min - New minimum range {@ko 변경할 범위의 최소값}\r\n   * @param max - New maximum range {@ko 변경할 범위의 최대값}\r\n   */ setRange(min, max) {\n        this._start = clamp(this._start, min, max);\n        this._end = clamp(this._end, min, max);\n        this._range = {\n            min,\n            max\n        };\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Animation of the {@link Camera}\r\n * @internal\r\n * @ko {@link Camera}의 애니메이션\r\n * @since 4.0.0\r\n */ class CameraAnimation {\n    /**\r\n   * Duration of the animation\r\n   * @ko 애니메이션 재생시간\r\n   * @since 4.0.0\r\n   */ get duration() {\n        return this._motion.duration;\n    }\n    set duration(val) {\n        this._motion.duration = val;\n    }\n    /**\r\n   * Easing function of the animation\r\n   * @ko 애니메이션의 easing function\r\n   * @since 4.0.0\r\n   */ get easing() {\n        return this._motion.easing;\n    }\n    set easing(val) {\n        this._motion.easing = val;\n    }\n    /**\r\n   * Create new instance\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param camera - Camera to animate {@ko 애니메이션을 적용할 카메라}\r\n   * @param from - Start pose {@ko 애니메이션이 시작 시점의 카메라의 회전 및 줌}\r\n   * @param to - End pose {@ko 애니메이션이 끝났을 때 카메라의 회전 및 줌}\r\n   * @param options - Options {@ko 옵션들}\r\n   * @param options.duration - Animation duration {@ko 애니메이션 재생 시간}\r\n   * @param options.easing - Animation easing function {@ko 애니메이션 easing function}\r\n   */ constructor(camera, from, to, { duration = DEFAULT_ANIMATION_DURATION, easing = DEFAULT_EASING } = {}){\n        this._camera = camera;\n        this._motion = new Motion({\n            duration,\n            easing,\n            range: {\n                min: 0,\n                max: 1\n            }\n        });\n        this._from = from;\n        this._to = to;\n        this._finishPromise = new Promise((resolve)=>{\n            this._finish = resolve;\n        });\n        // Enable motion\n        this._motion.setNewEndByDelta(1);\n    }\n    /**\r\n   * Return a promise that resolved on animation end.\r\n   * @ko 애니메이션 재생이 끝났을 때 resolve되는 Promise를 반환합니다.\r\n   * @since 4.0.0\r\n   */ getFinishPromise() {\n        return this._finishPromise;\n    }\n    /**\r\n   * Update animation by given deltaTime.\r\n   * @ko 주어진 시간만큼 애니메이션을 업데이트합니다.\r\n   * @param deltaTime Number of milisec to update {@ko 업데이트할 시간, 밀리초 단위}\r\n   * @since 4.0.0\r\n   */ update(deltaTime) {\n        const camera = this._camera;\n        const from = this._from;\n        const to = this._to;\n        const motion = this._motion;\n        motion.update(deltaTime);\n        // Progress that easing is applied\n        const progress = motion.val;\n        const rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n        const zoom = lerp(from.zoom, to.zoom, progress);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.slerp(rotation, from.rotation, to.rotation, progress);\n        camera.rotate(rotation, zoom);\n        if (progress >= 1) {\n            this._finish();\n        }\n    }\n}\n/**\r\n * Camera for View360\r\n * @ko View360용 카메라 구현체\r\n * @version 4.0.0\r\n */ class Camera extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   * Camera's width / height ratio\r\n   * @ko 카메라의 가로 / 세로 비율\r\n   * @readonly\r\n   */ get aspect() {\n        return this._aspect;\n    }\n    /**\r\n   * Whether the camera's rotation changed from the last frame.\r\n   * @ko 마지막 프레임 이후로 카메라의 회전값이 변경되었는지 나타내는 플래그.\r\n   * @readonly\r\n   */ get changed() {\n        return this._changed;\n    }\n    /**\r\n   * @copy View360#yawRange\r\n   */ get yawRange() {\n        return this._initialYawRange;\n    }\n    set yawRange(val) {\n        this._initialYawRange = val;\n    }\n    /**\r\n   * @copy View360#pitchRange\r\n   */ get pitchRange() {\n        return this._initialPitchRange;\n    }\n    set pitchRange(val) {\n        this._initialPitchRange = val;\n    }\n    /**\r\n   * @copy View360#zoomRange\r\n   */ get zoomRange() {\n        return this._initialZoomRange;\n    }\n    set zoomRange(val) {\n        this._initialZoomRange = val;\n    }\n    /**\r\n   * Create new instance of Camera\r\n   * @param options - Camera options {@ko 카메라 옵션들}\r\n   */ constructor({ initialYaw, initialPitch, initialZoom, yawRange, pitchRange, zoomRange, fov }){\n        super();\n        this.yaw = initialYaw;\n        this.pitch = initialPitch;\n        this.zoom = initialZoom;\n        this.rollOffset = 0;\n        this.initialYaw = initialYaw;\n        this.initialPitch = initialPitch;\n        this.initialZoom = initialZoom;\n        this.position = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\n        this.animation = null;\n        this._up = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 1, 0);\n        this._aspect = 1;\n        this._initialYawRange = yawRange;\n        this._initialPitchRange = pitchRange;\n        this._initialZoomRange = zoomRange;\n        this._yawRange = yawRange;\n        this._pitchRange = pitchRange;\n        this._zoomRange = zoomRange;\n        this.quaternion = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n        this._updateQuaternion();\n        this.viewMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();\n        this.projectionMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();\n        this.fov = fov;\n        this._maxRenderHeight = -1;\n    }\n    /**\r\n   * Destroy instance and detach all event listeners\r\n   * @ko 인스턴스를 삭제하고 모든 이벤트 리스너를 삭제합니다.\r\n   * @since 4.0.0\r\n   */ destroy() {\n        this.off();\n    }\n    /**\r\n   * Refresh internal size value.\r\n   * @ko 내부 크기값을 갱신합니다.\r\n   * @param width - New width {@ko 변경된 너비값}\r\n   * @param height - New height {@ko 변경된 높이값}\r\n   * @since 4.0.0\r\n   */ resize(width, height) {\n        const prevAspect = this._aspect;\n        this._aspect = width / height;\n        if (this._aspect !== prevAspect) {\n            this.updateMatrix();\n        }\n    }\n    /**\r\n   * Change camera's rotation with euler values.\r\n   * @ko 카메라 회전을 오일러 각 방향으로 변경합니다.\r\n   * @param rotation - Rotation values {@ko 회전 값}\r\n   * @param rotation.yaw - yaw(y-axis rotation) to look at {@ko 바라볼 yaw(y축 회전) 값}\r\n   * @param rotation.pitch - pitch(x-axis rotation) to look at {@ko 바라볼 pitch(x축 회전) 값}\r\n   * @param rotation.zoom - zoom value to apply {@ko 적용할 카메라 줌 값}\r\n   * @since 4.0.0\r\n   */ lookAt({ yaw = this.yaw, pitch = this.pitch, zoom = this.zoom }) {\n        const prevQuaternion = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.clone(this.quaternion);\n        const prevZoom = this.zoom;\n        this.yaw = circulate(yaw, 0, 360);\n        this.pitch = clamp(pitch, -90, 90);\n        this.zoom = zoom;\n        this._updateQuaternion();\n        const zoomDiff = Math.abs(zoom - prevZoom);\n        if (!gl_matrix__WEBPACK_IMPORTED_MODULE_1__.equals(this.quaternion, prevQuaternion) || zoomDiff >= EPSILON * 10 // ignore small changes\n        ) {\n            this.updateMatrix();\n        }\n    }\n    /**\r\n   * Change camera's rotation with quaternion.\r\n   * @ko 카메라 회전을 Quaternion을 이용해서 변경합니다.\r\n   * @param rotation - Quaternion to apply {@ko 적용할 Quaternion}\r\n   * @param zoom - zoom value to apply {@ko 적용할 카메라 줌 값}\r\n   * @since 4.0.0\r\n   */ rotate(rotation, zoom = this.zoom) {\n        const normalized = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), rotation);\n        const isSameRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.equals(this.quaternion, normalized);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.copy(this.quaternion, normalized);\n        const prevZoom = this.zoom;\n        const { yaw, pitch } = quatToEuler(normalized);\n        this.yaw = yaw;\n        this.pitch = pitch;\n        this.zoom = zoom;\n        const zoomDiff = Math.abs(zoom - prevZoom);\n        if (!isSameRotation || zoomDiff >= EPSILON * 10) {\n            this.updateMatrix();\n        }\n    }\n    /**\r\n   * Change camera's rotation to given euler values by the given duration.\r\n   * @ko 카메라를 주어진 방향으로 주어진 시간동안 서서히 이동시킵니다.\r\n   * @param options - Animation parameters {@ko 애니메이션 패러미터}\r\n   * @param options.yaw - yaw(y-axis rotation) to look at {@ko 바라볼 yaw(y축 회전) 값}\r\n   * @param options.pitch - pitch(x-axis rotation) to look at {@ko 바라볼 pitch(x축 회전) 값}\r\n   * @param options.zoom - zoom value to apply {@ko 적용할 카메라 줌 값}\r\n   * @param options.duration - Duration of the animation {@ko 애니메이션 시간}\r\n   * @param options.easing - Easing function for the animation {@ko 애니메이션에 적용할 easing function}\r\n   */ animateTo({ yaw = this.yaw, pitch = this.pitch, zoom = this.zoom, duration = 0, easing = DEFAULT_EASING } = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.yaw === yaw && this.pitch === pitch && this.zoom === zoom) return;\n            const from = {\n                rotation: gl_matrix__WEBPACK_IMPORTED_MODULE_1__.clone(this.quaternion),\n                zoom: this.zoom\n            };\n            const to = {\n                rotation: eulerToQuat(gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create(), yaw, pitch, this.rollOffset),\n                zoom\n            };\n            const animation = new CameraAnimation(this, from, to, {\n                duration,\n                easing\n            });\n            const finishPromise = animation.getFinishPromise();\n            this.animation = animation;\n            finishPromise.then(()=>{\n                this.animation = null;\n                this.trigger(CAMERA_EVENTS.ANIMATION_END, {\n                    animation\n                });\n            });\n            return finishPromise;\n        });\n    }\n    /**\r\n   * @hidden\r\n   */ restrictYawRange(min, max) {\n        this._yawRange = {\n            min,\n            max\n        };\n    }\n    /**\r\n   * @hidden\r\n   */ restrictPitchRange(min, max) {\n        this._pitchRange = {\n            min,\n            max\n        };\n    }\n    /**\r\n   * @hidden\r\n   */ restrictZoomRange(min, max) {\n        this._zoomRange = {\n            min,\n            max\n        };\n    }\n    /**\r\n   * @hidden\r\n   */ restrictRenderHeight(height) {\n        this._maxRenderHeight = height;\n    }\n    /**\r\n   * @hidden\r\n   */ resetRange() {\n        this._yawRange = this._initialYawRange;\n        this._pitchRange = this._initialPitchRange;\n        this._zoomRange = this._initialZoomRange;\n        this._maxRenderHeight = -1;\n    }\n    /**\r\n   * Get actual yaw range by the given zoom value.\r\n   * @ko 주어진 zoom 값에 대한 실제 yaw 범위값을 반환합니다.\r\n   * @since 4.0.0\r\n   */ getYawRange(zoom) {\n        const yawLimit = this._yawRange;\n        const maxRenderHeight = this._maxRenderHeight;\n        if (!yawLimit) return INFINITE_RANGE;\n        const halfHFov = this.getHorizontalFov(zoom) * 0.5;\n        let minYaw = yawLimit.min;\n        let maxYaw = yawLimit.max;\n        if (maxRenderHeight > 0) {\n            const halfVFovRad = toVerticalFov(halfHFov * DEG_TO_RAD, this._aspect);\n            const h = maxRenderHeight * 0.5;\n            const t = Math.tan(halfVFovRad);\n            const d = Math.sqrt((1 + h * h) / (1 + t * t));\n            const theta = Math.atan(Math.tan(halfHFov * DEG_TO_RAD) * d) * RAD_TO_DEG;\n            minYaw = yawLimit.min + theta;\n            maxYaw = yawLimit.max - theta;\n        }\n        if (minYaw > maxYaw) {\n            minYaw = 0;\n            maxYaw = 0;\n        }\n        return {\n            min: minYaw,\n            max: maxYaw\n        };\n    }\n    /**\r\n   * Get actual pitch range by the given zoom value.\r\n   * @ko 주어진 zoom 값에 대한 실제 pitch 범위값을 반환합니다.\r\n   * @since 4.0.0\r\n   */ getPitchRange(zoom) {\n        const pitchLimit = this._pitchRange;\n        const maxRenderHeight = this._maxRenderHeight;\n        if (!pitchLimit) return DEFAULT_PITCH_RANGE;\n        let minPitch = pitchLimit.min;\n        let maxPitch = pitchLimit.max;\n        if (maxRenderHeight > 0) {\n            const halfVFov = this.getVerticalFov(zoom) * 0.5;\n            minPitch = pitchLimit.min + halfVFov;\n            maxPitch = pitchLimit.max - halfVFov;\n        }\n        if (minPitch > maxPitch) {\n            minPitch = 0;\n            maxPitch = 0;\n        }\n        return {\n            min: Math.max(minPitch, -90),\n            max: Math.min(maxPitch, 90)\n        };\n    }\n    /**\r\n   * Get actual zoom range in fov degrees.\r\n   * @ko 실제 줌 범위를 fov각의 범위로 반환합니다.\r\n   * @since 4.0.0\r\n   */ getZoomRange() {\n        var _a;\n        const limit = (_a = this._zoomRange) !== null && _a !== void 0 ? _a : DEFAULT_ZOOM_RANGE;\n        // max (zoom in) -> minimum fov\n        const minFov = this.getHorizontalFov(limit.max);\n        const maxFov = this.getHorizontalFov(limit.min);\n        const currentFov = this.getHorizontalFov(this.zoom);\n        return {\n            min: Math.max(minFov, 1),\n            max: Math.min(maxFov, 180),\n            current: currentFov\n        };\n    }\n    /**\r\n   * Return horizontal fov value when the given zoom is applied. (in degrees, °)\r\n   * @ko 주어진 zoom 값이 적용되었을 때의 수평 fov값을 반환합니다. (도 단위, °)\r\n   * @returns Zoomed horizontal FOV {@ko 줌이 적용된 수평 fov값}\r\n   * @since 4.0.0\r\n   */ getHorizontalFov(zoom = this.zoom) {\n        return this._getZoomedHorizontalFov(zoom) * RAD_TO_DEG;\n    }\n    /**\r\n   * Return vertical fov value when the given zoom is applied. (in degrees, °)\r\n   * @ko 주어진 zoom 값이 적용되었을 때의 수직 fov값을 반환합니다. (도 단위, °)\r\n   * @returns Zoomed vertical FOV {@ko 줌이 적용된 수직 fov값}\r\n   * @since 4.0.0\r\n   */ getVerticalFov(zoom = this.zoom) {\n        const aspect = this._aspect;\n        const hFov = this._getZoomedHorizontalFov(zoom); // In radians\n        const vFov = toVerticalFov(hFov, aspect);\n        return vFov * RAD_TO_DEG;\n    }\n    /**\r\n   * Calculate zoom value for the given fov.\r\n   * @ko 주어진 fov값을 zoom값으로 변환합니다.\r\n   * @param fov horizontal fov (in degrees, °) {@ko 수평 fov 값 (도 단위, °)}\r\n   * @since 4.0.0\r\n   */ fovToZoom(fov) {\n        const baseFov = this.fov;\n        const renderingWidth = Math.tan(DEG_TO_RAD * baseFov * 0.5);\n        const zoomedWidth = Math.tan(DEG_TO_RAD * fov * 0.5);\n        return renderingWidth / zoomedWidth;\n    }\n    /**\r\n   * Update inner matrixes.\r\n   * @ko 내부 행렬들을 업데이트합니다.\r\n   * @internal\r\n   * @since 4.0.0\r\n   */ updateMatrix() {\n        const up = this._up;\n        const aspect = this._aspect;\n        const viewMatrix = this.viewMatrix;\n        const projMatrix = this.projectionMatrix;\n        const position = this.position;\n        const rotation = this.quaternion;\n        const upDir = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\n        const viewDir = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, -1);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(viewDir, viewDir, rotation);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(upDir, up, rotation);\n        const hFov = this._getZoomedHorizontalFov(); // In radians\n        const vFov = toVerticalFov(hFov, aspect);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_3__.lookAt(viewMatrix, position, viewDir, upDir);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_3__.perspective(projMatrix, vFov, aspect, 0.1, 100);\n        this._changed = true;\n    }\n    /**\r\n   * @hidden\r\n   */ onFrameRender() {\n        this._changed = false;\n    }\n    _updateQuaternion() {\n        eulerToQuat(this.quaternion, this.yaw, this.pitch, this.rollOffset);\n    }\n    /**\r\n   * @param zoom Current zoom value\r\n   * @returns horizontal fov including zoom, in radian\r\n   */ _getZoomedHorizontalFov(zoom = this.zoom) {\n        return 2 * Math.atan(Math.tan(DEG_TO_RAD * this.fov * 0.5) / zoom);\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class MouseInput extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(){\n        super();\n        this._onMouseDown = (evt)=>{\n            const el = this._el;\n            if (!el || evt.button !== MOUSE_BUTTON.LEFT) return;\n            evt.preventDefault();\n            if (el.focus) {\n                el.focus();\n            } else {\n                window.focus();\n            }\n            this._prevPos[0] = evt.clientX;\n            this._prevPos[1] = evt.clientY;\n            window.addEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);\n            window.addEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);\n            this.trigger(CONTROL_EVENTS.INPUT_START, {\n                srcEvent: evt,\n                isTouch: false,\n                isKeyboard: false\n            });\n        };\n        this._onMouseMove = (evt)=>{\n            evt.preventDefault();\n            const x = evt.clientX;\n            const y = evt.clientY;\n            const prevPos = this._prevPos;\n            const deltaX = x - prevPos[0];\n            const deltaY = y - prevPos[1];\n            this.trigger(CONTROL_EVENTS.CHANGE, {\n                delta: {\n                    x: deltaX,\n                    y: deltaY\n                },\n                isTouch: false,\n                isKeyboard: false\n            });\n            prevPos[0] = x;\n            prevPos[1] = y;\n        };\n        this._onMouseUp = ()=>{\n            this._prevPos[0] = 0;\n            this._prevPos[1] = 0;\n            window.removeEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);\n            window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);\n            this.trigger(CONTROL_EVENTS.INPUT_END, {\n                isTouch: false,\n                isKeyboard: false,\n                scrolling: false\n            });\n        };\n        this._el = null;\n        this._prevPos = [\n            0,\n            0\n        ];\n    }\n    enable(element) {\n        if (this._el) return;\n        element.addEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown);\n        this._el = element;\n    }\n    disable() {\n        const element = this._el;\n        if (!element) return;\n        element.removeEventListener(EVENTS$1.MOUSE_DOWN, this._onMouseDown);\n        window.removeEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove, false);\n        window.removeEventListener(EVENTS$1.MOUSE_UP, this._onMouseUp, false);\n        this._el = null;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class TouchInput extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    get scrollable() {\n        return this._scrollable;\n    }\n    set scrollable(val) {\n        this._scrollable = val;\n    }\n    constructor(){\n        super();\n        this._onTouchStart = (evt)=>{\n            if (evt.touches.length > 1 || this._scrolling) return;\n            const touch = evt.touches[0];\n            this._isFirstTouch = true;\n            this._prevPos[0] = touch.clientX;\n            this._prevPos[1] = touch.clientY;\n            this.trigger(CONTROL_EVENTS.INPUT_START, {\n                srcEvent: evt,\n                isTouch: true,\n                isKeyboard: false\n            });\n        };\n        this._onTouchMove = (evt)=>{\n            // Only the one finger motion should be considered\n            if (evt.touches.length > 1 || this._scrolling) return;\n            const touch = evt.touches[0];\n            const scrollable = this._scrollable;\n            const prevPos = this._prevPos;\n            const x = touch.clientX;\n            const y = touch.clientY;\n            const deltaX = x - prevPos[0];\n            const deltaY = y - prevPos[1];\n            if (this._isFirstTouch) {\n                if (scrollable && !isFullscreen()) {\n                    if (Math.abs(deltaY) > Math.abs(deltaX)) {\n                        // Assume Scrolling\n                        this._scrolling = true;\n                        return;\n                    }\n                }\n                this._isFirstTouch = false;\n            }\n            if (evt.cancelable !== false) {\n                evt.preventDefault();\n            }\n            this.trigger(CONTROL_EVENTS.CHANGE, {\n                delta: {\n                    x: deltaX,\n                    y: deltaY\n                },\n                isTouch: true,\n                isKeyboard: false\n            });\n            prevPos[0] = x;\n            prevPos[1] = y;\n        };\n        this._onTouchEnd = (evt)=>{\n            if (evt.touches.length !== 0) return;\n            const touch = evt.touches[0];\n            const prevPos = this._prevPos;\n            if (touch) {\n                prevPos[0] = touch.clientX;\n                prevPos[1] = touch.clientY;\n            } else {\n                prevPos[0] = 0;\n                prevPos[1] = 0;\n                this.trigger(CONTROL_EVENTS.INPUT_END, {\n                    isTouch: true,\n                    isKeyboard: false,\n                    scrolling: this._scrolling\n                });\n            }\n            if (evt.cancelable !== false) {\n                evt.preventDefault();\n            }\n            this._scrolling = false;\n        };\n        this._el = null;\n        this._prevPos = [\n            0,\n            0\n        ];\n        this._isFirstTouch = false;\n        this._scrolling = false;\n        this._scrollable = false;\n    }\n    enable(element) {\n        if (this._el) return;\n        element.addEventListener(EVENTS$1.TOUCH_START, this._onTouchStart, {\n            passive: false\n        });\n        element.addEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, {\n            passive: false\n        });\n        element.addEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd);\n        this._el = element;\n    }\n    disable() {\n        const element = this._el;\n        if (!element) return;\n        element.removeEventListener(EVENTS$1.TOUCH_START, this._onTouchStart);\n        element.removeEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove);\n        element.removeEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd);\n        this._el = null;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class KeyboardInput extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    get active() {\n        const pressed = this._pressed;\n        return pressed.LEFT || pressed.UP || pressed.RIGHT || pressed.DOWN;\n    }\n    constructor(){\n        super();\n        this._onKeyDown = (evt)=>{\n            // Ignore all other keypress except main arrow keys\n            if (evt.location !== KeyboardEvent.DOM_KEY_LOCATION_STANDARD) return;\n            this._updateKeyPress(evt, true);\n            const pressedCount = this._getPressedKeyCount();\n            if (pressedCount <= 0) return;\n            evt.preventDefault();\n            if (pressedCount === 1 && !evt.repeat) {\n                // On first keydown\n                this.trigger(CONTROL_EVENTS.INPUT_START, {\n                    srcEvent: evt,\n                    isTouch: false,\n                    isKeyboard: true\n                });\n            }\n        };\n        this._onKeyUp = (evt)=>{\n            // Ignore all other keypress except main arrow keys\n            if (evt.location !== KeyboardEvent.DOM_KEY_LOCATION_STANDARD) return;\n            this._updateKeyPress(evt, false);\n            const pressedCount = this._getPressedKeyCount();\n            if (pressedCount > 0) return;\n            this.trigger(CONTROL_EVENTS.INPUT_END, {\n                isTouch: false,\n                isKeyboard: true,\n                scrolling: false\n            });\n        };\n        this._el = null;\n        this._clearPressedKeys();\n    }\n    enable(element) {\n        if (this._el) return;\n        element.addEventListener(EVENTS$1.KEY_DOWN, this._onKeyDown);\n        element.addEventListener(EVENTS$1.KEY_UP, this._onKeyUp);\n        this._el = element;\n        this._clearPressedKeys();\n    }\n    disable() {\n        const element = this._el;\n        if (!element) return;\n        element.removeEventListener(EVENTS$1.KEY_DOWN, this._onKeyDown);\n        element.removeEventListener(EVENTS$1.KEY_UP, this._onKeyUp);\n        this._el = null;\n        this._clearPressedKeys();\n    }\n    update() {\n        const delta = this._getDeltaByPressedKeys();\n        if (delta.x !== 0 || delta.y !== 0) {\n            this.trigger(CONTROL_EVENTS.CHANGE, {\n                delta,\n                isTouch: false,\n                isKeyboard: true\n            });\n        }\n    }\n    _clearPressedKeys() {\n        this._pressed = KEY_DIRECTION.reduce((obj, keyName)=>{\n            return Object.assign(Object.assign({}, obj), {\n                [keyName]: false\n            });\n        }, {});\n    }\n    _updateKeyPress(event, isEnable) {\n        const pressed = this._pressed;\n        const keyToUpdate = event.keyCode != null ? DIRECTION_KEY_CODE[event.keyCode] : DIRECTION_KEY_NAME[event.key];\n        if (!keyToUpdate) return;\n        pressed[keyToUpdate] = isEnable;\n    }\n    _getPressedKeyCount() {\n        return KEY_DIRECTION.filter((key)=>this._pressed[key]).length;\n    }\n    _getDeltaByPressedKeys() {\n        const pressed = this._pressed;\n        let x = 0;\n        let y = 0;\n        if (pressed.LEFT) {\n            x += 1;\n        }\n        if (pressed.RIGHT) {\n            x -= 1;\n        }\n        if (pressed.UP) {\n            y += 1;\n        }\n        if (pressed.DOWN) {\n            y -= 1;\n        }\n        return {\n            x,\n            y\n        };\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Camera's rotation control\r\n * @ko 카메라의 회전을 담당하는 컨트롤\r\n * @since 4.0.0\r\n */ class RotateControl extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   * @copy CameraControl#enabled\r\n   */ get enabled() {\n        return this._enabled;\n    }\n    /**\r\n   * @hidden\r\n   */ get enableBlocked() {\n        return this._enableBlocked;\n    }\n    /**\r\n   * @copy CameraControl#animating\r\n   */ get animating() {\n        return this._keyboardInput.active || this._xMotion.activated || this._yMotion.activated;\n    }\n    /**\r\n   * Current yaw value\r\n   * @ko 현재 yaw 값\r\n   * @readonly\r\n   * @since 4.0.0\r\n   */ get yaw() {\n        return this._xMotion;\n    }\n    /**\r\n   * Current pitch value\r\n   * @ko 현재 pitch 값\r\n   * @readonly\r\n   * @since 4.0.0\r\n   */ get pitch() {\n        return this._yMotion;\n    }\n    /**\r\n   * @copy View360#scrollable\r\n   */ get scrollable() {\n        return this._touchInput.scrollable;\n    }\n    set scrollable(val) {\n        this._touchInput.scrollable = val;\n    }\n    /**\r\n   * Scale factor for mouse/touch rotation\r\n   * @ko 마우스/터치를 통한 회전 배율\r\n   * @default [1, 1]\r\n   * @since 4.0.0\r\n   */ get pointerScale() {\n        return this._pointerScale;\n    }\n    set pointerScale(val) {\n        this._pointerScale = val;\n    }\n    /**\r\n   * Scale factor for keyboard rotation\r\n   * @ko 키보드를 통한 회전 배율\r\n   * @default [1, 1]\r\n   * @since 4.0.0\r\n   */ get keyboardScale() {\n        return this._keyboardScale;\n    }\n    set keyboardScale(val) {\n        this._keyboardScale = val;\n    }\n    /**\r\n   * Duration of the input animation (ms)\r\n   * @ko 회전 애니메이션의 시간 (ms)\r\n   * @default 300\r\n   */ get duration() {\n        return this._duration;\n    }\n    set duration(val) {\n        this._duration = val;\n        this._xMotion.duration = val;\n        this._yMotion.duration = val;\n    }\n    /**\r\n   * Easing function of the animation\r\n   * @ko 회전 애니메이션에 적용할 easing 함수\r\n   * @default EASING.EASE_OUT_CUBIC\r\n   * @see EASING\r\n   */ get easing() {\n        return this._easing;\n    }\n    set easing(val) {\n        this._easing = val;\n        this._xMotion.easing = val;\n        this._yMotion.easing = val;\n    }\n    /**\r\n   * Disable X-axis(pitch) rotation.\r\n   * @ko x축 회전(pitch)을 비활성화합니다.\r\n   * @default false\r\n   */ get disablePitch() {\n        return this._disablePitch;\n    }\n    set disablePitch(val) {\n        this._disablePitch = val;\n    }\n    /**\r\n   * Disable Y-axis(yaw) rotation.\r\n   * @ko y축 회전(yaw)을 비활성화합니다.\r\n   * @default false\r\n   */ get disableYaw() {\n        return this._disableYaw;\n    }\n    set disableYaw(val) {\n        this._disableYaw = val;\n    }\n    /**\r\n   * Disable rotation by keyboard.\r\n   * @ko 키보드를 이용한 회전을 비활성화합니다.\r\n   * @default false\r\n   */ get disableKeyboard() {\n        return this._disableKeyboard;\n    }\n    set disableKeyboard(val) {\n        this._disableKeyboard = val;\n    }\n    /**\r\n   * Create new RotateControl instance\r\n   * @ko RotateControl의 인스턴스를 생성합니다.\r\n   * @param controlEl - Element to attach handlers {@ko 입력을 받을 엘리먼트}\r\n   * @param enableBlocked - Whether to disable control on init {@ko 초기화 과정에서 컨트롤 활성화 여부}\r\n   * @param options - Options for control {@ko 컨트롤 옵션들}\r\n   */ constructor(controlEl, enableBlocked, { duration = DEFAULT_ANIMATION_DURATION, easing = DEFAULT_EASING, pointerScale = [\n        1,\n        1\n    ], keyboardScale = [\n        1,\n        1\n    ], disablePitch = false, disableYaw = false, disableKeyboard = false } = {}){\n        super();\n        this._onInputStart = (evt)=>{\n            this._changedWhileDragging = false;\n            this.trigger(CONTROL_EVENTS.INPUT_START, Object.assign(Object.assign({}, evt), {\n                inputType: \"rotate\"\n            }));\n        };\n        this._onChange = (evt)=>{\n            const delta = evt.delta;\n            const invZoomScale = 1 / this._zoomScale; // Reduce speed on zoom\n            const screenScale = this._screenScale;\n            const keyboardScale = this._keyboardScale;\n            const pointerScale = this._pointerScale;\n            let scale;\n            if (evt.isKeyboard) {\n                scale = [\n                    keyboardScale[0] * invZoomScale,\n                    keyboardScale[1] * invZoomScale\n                ];\n            } else {\n                scale = [\n                    pointerScale[0] * screenScale[0] * invZoomScale,\n                    pointerScale[1] * screenScale[1] * invZoomScale\n                ];\n            }\n            const scaledX = delta.x * scale[0];\n            const scaledY = delta.y * scale[1];\n            this._xMotion.setNewEndByDelta(scaledX);\n            this._yMotion.setNewEndByDelta(scaledY);\n            this._changedWhileDragging = true;\n        };\n        this._onInputEnd = (evt)=>{\n            this.trigger(CONTROL_EVENTS.INPUT_END, Object.assign(Object.assign({}, evt), {\n                inputType: \"rotate\"\n            }));\n            if (!this._changedWhileDragging && !evt.isKeyboard && !evt.scrolling) {\n                this.trigger(CONTROL_EVENTS.STATIC_CLICK, {\n                    isTouch: evt.isTouch\n                });\n            }\n            this._changedWhileDragging = false;\n        };\n        this._controlEl = controlEl;\n        this._pointerScale = pointerScale;\n        this._keyboardScale = keyboardScale;\n        this._duration = duration;\n        this._easing = easing;\n        this._disablePitch = disablePitch;\n        this._disableYaw = disableYaw;\n        this._disableKeyboard = disableKeyboard;\n        this._enableBlocked = enableBlocked;\n        this._mouseInput = new MouseInput();\n        this._touchInput = new TouchInput();\n        this._keyboardInput = new KeyboardInput();\n        this._xMotion = new Motion({\n            duration,\n            range: INFINITE_RANGE,\n            easing\n        });\n        this._yMotion = new Motion({\n            duration,\n            range: DEFAULT_PITCH_RANGE,\n            easing\n        });\n        this._screenScale = [\n            1,\n            1\n        ];\n        this._zoomScale = 1;\n        this._enabled = false;\n        this._changedWhileDragging = false;\n        this._bindInputs();\n    }\n    destroy() {\n        this.disable();\n        this._mouseInput.off();\n        this._touchInput.off();\n        this._keyboardInput.off();\n        this.off();\n        this._changedWhileDragging = false;\n    }\n    /**\r\n   * @hidden\r\n   */ update(delta) {\n        if (!this._enabled) return;\n        const xMotion = this._xMotion;\n        const yMotion = this._yMotion;\n        const keyboardInput = this._keyboardInput;\n        if (!this._disableKeyboard) {\n            keyboardInput.update();\n        }\n        if (!this._disablePitch) {\n            yMotion.update(delta);\n        }\n        if (!this._disableYaw) {\n            xMotion.update(delta);\n        }\n    }\n    /**\r\n   * @hidden\r\n   */ updateRange(camera, zoom) {\n        const yawRange = camera.getYawRange(zoom);\n        const pitchRange = camera.getPitchRange(zoom);\n        this._xMotion.setRange(yawRange.min, yawRange.max);\n        this._yMotion.setRange(pitchRange.min, pitchRange.max);\n    }\n    /**\r\n   * @hidden\r\n   */ setZoomScale(val) {\n        this._zoomScale = val;\n    }\n    /**\r\n   * Resize control to match target size.\r\n   * @ko 컨트롤의 내부 크기를 갱신합니다.\r\n   * @param hfov - Camera horizontal fov in degrees {@ko 카메라의 수평방향 fov값 (도 단위)}\r\n   * @param aspect - Camera aspect {@ko 카메라 가로/세로 비율}\r\n   * @param width - New width {@ko 갱신된 너비}\r\n   * @param height - New height {@ko 갱신된 높이}\r\n   */ resize(hfov, aspect, width, height) {\n        const vfov = toVerticalFov(hfov * DEG_TO_RAD, aspect) * RAD_TO_DEG;\n        this._screenScale[0] = hfov / width;\n        this._screenScale[1] = vfov / height;\n    }\n    enable() {\n        if (this._enabled) return;\n        const element = this._controlEl;\n        this._mouseInput.enable(element);\n        this._touchInput.enable(element);\n        this._keyboardInput.enable(element);\n        this._enabled = true;\n        this._enableBlocked = false;\n        this.trigger(CONTROL_EVENTS.ENABLE, {\n            control: this,\n            updateCursor: true\n        });\n    }\n    disable() {\n        if (!this._enabled) return;\n        this._mouseInput.disable();\n        this._touchInput.disable();\n        this._keyboardInput.disable();\n        this._enabled = false;\n        this.trigger(CONTROL_EVENTS.DISABLE, {\n            updateCursor: true\n        });\n    }\n    sync(camera) {\n        this.updateRange(camera, camera.zoom);\n        this._xMotion.reset(camera.yaw);\n        this._yMotion.reset(camera.pitch);\n    }\n    _bindInputs() {\n        const mouseInput = this._mouseInput;\n        const touchInput = this._touchInput;\n        const keyboardInput = this._keyboardInput;\n        mouseInput.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        mouseInput.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        mouseInput.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        touchInput.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        touchInput.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        touchInput.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        keyboardInput.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        keyboardInput.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        keyboardInput.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class WheelInput extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    get scrollable() {\n        return this._scrollable;\n    }\n    set scrollable(val) {\n        this._scrollable = val;\n    }\n    constructor(){\n        super();\n        this._onWheel = (evt)=>{\n            const scrollable = this._scrollable;\n            if (evt.deltaY === 0 || scrollable) return;\n            evt.preventDefault();\n            evt.stopPropagation();\n            if (this._inputTimer < 0) {\n                this.trigger(CONTROL_EVENTS.INPUT_START, {\n                    srcEvent: evt,\n                    isTouch: false,\n                    isKeyboard: false\n                });\n            } else {\n                this._clearTimer();\n            }\n            const delta = this._baseScale * evt.deltaY;\n            this.trigger(CONTROL_EVENTS.CHANGE, {\n                delta,\n                isTouch: false,\n                isKeyboard: false\n            });\n            this._inputTimer = window.setTimeout(()=>{\n                this.trigger(CONTROL_EVENTS.INPUT_END, {\n                    isTouch: false,\n                    isKeyboard: false,\n                    scrolling: false\n                });\n                this._inputTimer = -1;\n            }, DEFAULT_ANIMATION_DURATION);\n        };\n        this._el = null;\n        this._baseScale = 0.04;\n        this._scrollable = false;\n        this._inputTimer = -1;\n    }\n    enable(element) {\n        if (this._el) return;\n        element.addEventListener(EVENTS$1.WHEEL, this._onWheel, {\n            passive: false,\n            capture: false\n        });\n        this._el = element;\n        this._clearTimer();\n    }\n    disable() {\n        const element = this._el;\n        if (!element) return;\n        element.removeEventListener(EVENTS$1.WHEEL, this._onWheel, false);\n        this._el = null;\n        this._clearTimer();\n    }\n    _clearTimer() {\n        window.clearTimeout(this._inputTimer);\n        this._inputTimer = -1;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class PinchInput extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(){\n        super();\n        this._onTouchMove = (evt)=>{\n            const touches = evt.touches;\n            if (touches.length !== 2) return;\n            if (!evt.cancelable) return;\n            evt.preventDefault();\n            evt.stopPropagation();\n            const prevDistance = this._prevDistance;\n            const diff = [\n                touches[0].pageX - touches[1].pageX,\n                touches[0].pageY - touches[1].pageY\n            ];\n            const distance = Math.sqrt(diff[0] * diff[0] + diff[1] * diff[1]) * this._baseScale;\n            const delta = this._isFirstTouch ? 0 : distance - prevDistance;\n            if (this._isFirstTouch) {\n                this.trigger(CONTROL_EVENTS.INPUT_START, {\n                    srcEvent: evt,\n                    isTouch: true,\n                    isKeyboard: false\n                });\n            }\n            this._prevDistance = distance;\n            this._isFirstTouch = false;\n            this.trigger(CONTROL_EVENTS.CHANGE, {\n                delta,\n                isTouch: true,\n                isKeyboard: false\n            });\n        };\n        this._onTouchEnd = (evt)=>{\n            if (evt.touches.length !== 0) return;\n            if (!this._isFirstTouch) {\n                this.trigger(CONTROL_EVENTS.INPUT_END, {\n                    isTouch: true,\n                    isKeyboard: false,\n                    scrolling: false\n                });\n            }\n            this._prevDistance = -1;\n            this._isFirstTouch = true;\n        };\n        this._el = null;\n        this._baseScale = -0.2;\n        this._prevDistance = -1;\n        this._isFirstTouch = true;\n    }\n    enable(element) {\n        if (this._el) return;\n        element.addEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, {\n            passive: false,\n            capture: false\n        });\n        element.addEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd);\n        this._el = element;\n        this._prevDistance = -1;\n        this._isFirstTouch = true;\n    }\n    disable() {\n        const element = this._el;\n        if (!element) return;\n        element.removeEventListener(EVENTS$1.TOUCH_MOVE, this._onTouchMove, false);\n        element.removeEventListener(EVENTS$1.TOUCH_END, this._onTouchEnd);\n        this._el = null;\n    }\n}\n/*\r\n* Copyright (c) 2023-present NAVER Corp.\r\n* egjs projects are licensed under the MIT license\r\n*/ /**\r\n * Camera's zoom control\r\n * @ko 카메라의 줌 값을 담당하는 컨트롤\r\n * @since 4.0.0\r\n */ class ZoomControl extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   * @copy CameraControl#enabled\r\n   */ get enabled() {\n        return this._enabled;\n    }\n    /**\r\n   * @hidden\r\n   */ get enableBlocked() {\n        return this._enableBlocked;\n    }\n    /**\r\n   * @copy CameraControl#animating\r\n   */ get animating() {\n        return this._motion.activated;\n    }\n    /**\r\n   * Current zoom value\r\n   * @ko 현재 줌 값\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get zoom() {\n        return this._motion.val;\n    }\n    /**\r\n   * @copy View360#wheelScrollable\r\n   */ get scrollable() {\n        return this._wheelInput.scrollable;\n    }\n    set scrollable(val) {\n        this._wheelInput.scrollable = val;\n    }\n    /**\r\n   * @hidden\r\n   */ get range() {\n        return this._motion.range;\n    }\n    /**\r\n   * Scale factor of the zoom\r\n   * @ko 입력에 의한 줌 배율\r\n   * @default 1\r\n   * @since 4.0.0\r\n   */ get scale() {\n        return this._scale;\n    }\n    set scale(val) {\n        this._scale = val;\n    }\n    /**\r\n   * Duration of the input animation (ms)\r\n   * @ko 회전 애니메이션의 시간 (ms)\r\n   * @default 300\r\n   * @since 4.0.0\r\n   */ get duration() {\n        return this._motion.duration;\n    }\n    /**\r\n   * Easing function of the animation\r\n   * @ko 회전 애니메이션에 적용할 easing 함수\r\n   * @default EASING.EASE_OUT_CUBIC\r\n   * @see EASING\r\n   * @since 4.0.0\r\n   */ get easing() {\n        return this._motion.easing;\n    }\n    /**\r\n   * Create new ZoomControl instance\r\n   * @ko ZoomControl의 인스턴스를 생성합니다.\r\n   * @param controlEl - Element to attach handlers {@ko 입력을 받을 엘리먼트}\r\n   * @param enableBlocked - Whether to disable control on init {@ko 초기화 과정에서 컨트롤 활성화 여부}\r\n   * @param options - Options for control {@ko 컨트롤 옵션들}\r\n   */ constructor(controlEl, enableBlocked, { scale = 1, duration = DEFAULT_ANIMATION_DURATION, easing = DEFAULT_EASING } = {}){\n        super();\n        this._onInputStart = (evt)=>{\n            this.trigger(CONTROL_EVENTS.INPUT_START, Object.assign(Object.assign({}, evt), {\n                inputType: \"zoom\"\n            }));\n        };\n        this._onChange = ({ delta })=>{\n            const scale = this._scale;\n            const scaledDelta = delta * scale;\n            this._motion.setNewEndByDelta(scaledDelta);\n        };\n        this._onInputEnd = (evt)=>{\n            this.trigger(CONTROL_EVENTS.INPUT_END, Object.assign(Object.assign({}, evt), {\n                inputType: \"zoom\"\n            }));\n        };\n        this._scale = scale;\n        this._controlEl = controlEl;\n        this._enableBlocked = enableBlocked;\n        this._wheelInput = new WheelInput();\n        this._pinchInput = new PinchInput();\n        this._motion = new Motion({\n            duration,\n            easing,\n            range: INFINITE_RANGE\n        });\n        this._enabled = false;\n        this._bindInputs();\n    }\n    destroy() {\n        this.disable();\n        this._wheelInput.off();\n        this._pinchInput.off();\n        this.off();\n    }\n    /**\r\n   * @hidden\r\n   */ update(delta) {\n        if (!this._enabled) return;\n        const motion = this._motion;\n        motion.update(delta);\n    }\n    enable() {\n        if (this._enabled) return;\n        const element = this._controlEl;\n        this._wheelInput.enable(element);\n        this._pinchInput.enable(element);\n        this._enabled = true;\n        this._enableBlocked = false;\n        this.trigger(CONTROL_EVENTS.ENABLE, {\n            control: this,\n            updateCursor: false\n        });\n    }\n    disable() {\n        if (!this._enabled) return;\n        this._wheelInput.disable();\n        this._pinchInput.disable();\n        this._enabled = false;\n        this.trigger(CONTROL_EVENTS.DISABLE, {\n            updateCursor: false\n        });\n    }\n    sync(camera) {\n        const motion = this._motion;\n        const range = camera.getZoomRange();\n        motion.setRange(range.min, range.max);\n        motion.reset(range.current);\n    }\n    _bindInputs() {\n        const wheelInput = this._wheelInput;\n        const pinchInput = this._pinchInput;\n        wheelInput.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        wheelInput.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        wheelInput.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        pinchInput.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        pinchInput.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        pinchInput.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ const ROTATE_CONSTANT = {\n    PITCH_DELTA: 1,\n    YAW_DELTA_BY_ROLL: 2,\n    YAW_DELTA_BY_YAW: 3\n};\nROTATE_CONSTANT[ROTATE_CONSTANT.PITCH_DELTA] = {\n    targetAxis: [\n        0,\n        1,\n        0\n    ],\n    meshPoint: [\n        0,\n        0,\n        1\n    ]\n};\nROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_ROLL] = {\n    targetAxis: [\n        0,\n        1,\n        0\n    ],\n    meshPoint: [\n        1,\n        0,\n        0\n    ]\n};\nROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_YAW] = {\n    targetAxis: [\n        1,\n        0,\n        0\n    ],\n    meshPoint: [\n        0,\n        0,\n        1\n    ]\n};\nclass GyroInput extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    get enabled() {\n        return this._enabled;\n    }\n    get orientationUpdated() {\n        return this._orientationUpdated;\n    }\n    get ignoreRoll() {\n        return this._ignoreRoll;\n    }\n    set ignoreRoll(val) {\n        this._ignoreRoll = val;\n    }\n    constructor(){\n        super();\n        this._onDeviceOrientation = (evt)=>{\n            const prevOrientation = this._orientation;\n            const { alpha, beta, gamma } = evt;\n            if (alpha == null || beta == null || gamma == null) return;\n            prevOrientation.alpha = alpha;\n            prevOrientation.beta = beta;\n            prevOrientation.gamma = gamma;\n            this._orientationUpdated = true;\n            if (this._needsCalibrate) {\n                this._needsCalibrate = false;\n                this._calibrateSensor();\n            }\n        };\n        this._updateScreenOrientation = ()=>{\n            if (window.screen && window.screen.orientation && window.screen.orientation.angle !== undefined) {\n                this._screenOrientation = screen.orientation.angle;\n            } else if (window.orientation !== undefined) {\n                this._screenOrientation = window.orientation >= 0 ? window.orientation : 360 + window.orientation;\n            } else {\n                this._screenOrientation = 0;\n            }\n        };\n        this.quaternion = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n        this._orientation = {\n            alpha: 0,\n            beta: 90,\n            gamma: 0\n        };\n        this._yawOrigin = 0;\n        this._yawOffset = 0;\n        this._orientationUpdated = false;\n        this._screenOrientation = 0;\n        this._needsCalibrate = true;\n        this._enabled = false;\n    }\n    enable() {\n        if (this._enabled) return;\n        window.addEventListener(EVENTS$1.DEVICE_ORIENTATION, this._onDeviceOrientation);\n        window.addEventListener(EVENTS$1.ORIENTATION_CHANGE, this._updateScreenOrientation);\n        this._updateScreenOrientation();\n        this._orientationUpdated = false;\n        this._needsCalibrate = true;\n        this._enabled = true;\n    }\n    disable() {\n        if (!this._enabled) return;\n        window.removeEventListener(EVENTS$1.DEVICE_ORIENTATION, this._onDeviceOrientation);\n        window.removeEventListener(EVENTS$1.ORIENTATION_CHANGE, this._updateScreenOrientation);\n        this._enabled = false;\n    }\n    update() {\n        this._updateRotation();\n        this._orientationUpdated = false;\n    }\n    collectDelta() {\n        if (!this._orientationUpdated) {\n            return {\n                pitch: 0,\n                yaw: 0\n            };\n        }\n        const prevRotation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.clone(this.quaternion);\n        this._updateRotation();\n        this._orientationUpdated = false;\n        return this._toEulerDelta(prevRotation, this.quaternion);\n    }\n    setInitialRotation(yaw) {\n        this._yawOrigin = yaw;\n    }\n    _calibrateSensor() {\n        const yawOrigin = this._yawOrigin;\n        const rotation = this.quaternion;\n        this._yawOffset = 0;\n        this._updateRotation();\n        const { yaw: sensorYaw } = quatToEuler(rotation);\n        this._yawOffset = sensorYaw - yawOrigin;\n        this._updateRotation();\n        this._needsCalibrate = false;\n    }\n    _updateRotation() {\n        const rotation = this.quaternion;\n        const { alpha, beta, gamma } = this._orientation;\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.identity(rotation);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateY(rotation, rotation, (alpha - this._yawOffset) * DEG_TO_RAD);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateX(rotation, rotation, beta * DEG_TO_RAD);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateZ(rotation, rotation, -gamma * DEG_TO_RAD);\n        const screen1 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n        const screenAngle = -this._screenOrientation * 0.5 * DEG_TO_RAD;\n        const world = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromValues(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.set(screen1, 0, Math.sin(screenAngle), 0, Math.cos(screenAngle));\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.multiply(rotation, rotation, screen1);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.multiply(rotation, rotation, world);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(rotation, rotation);\n    }\n    _toEulerDelta(prevQuat, currentQuat) {\n        return {\n            yaw: this._getDeltaYaw(prevQuat, currentQuat),\n            pitch: this._getDeltaPitch(prevQuat, currentQuat)\n        };\n    }\n    _getDeltaYaw(prvQ, curQ) {\n        const yawDeltaByYaw = this._getRotationDelta(prvQ, curQ, ROTATE_CONSTANT.YAW_DELTA_BY_YAW);\n        const yawDeltaByRoll = this._getRotationDelta(prvQ, curQ, ROTATE_CONSTANT.YAW_DELTA_BY_ROLL) * Math.sin(this._extractPitchFromQuat(curQ));\n        return yawDeltaByRoll + yawDeltaByYaw;\n    }\n    _getDeltaPitch(prvQ, curQ) {\n        return this._getRotationDelta(prvQ, curQ, ROTATE_CONSTANT.PITCH_DELTA);\n    }\n    _getRotationDelta(prevQ, curQ, rotateKind) {\n        const targetAxis = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(ROTATE_CONSTANT[rotateKind].targetAxis[0], ROTATE_CONSTANT[rotateKind].targetAxis[1], ROTATE_CONSTANT[rotateKind].targetAxis[2]);\n        const meshPoint = ROTATE_CONSTANT[rotateKind].meshPoint;\n        const prevQuaternion = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.clone(prevQ);\n        const curQuaternion = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.clone(curQ);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(prevQuaternion, prevQuaternion);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.normalize(curQuaternion, curQuaternion);\n        let prevPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 1);\n        let curPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 1);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(prevPoint, prevPoint, prevQuaternion);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(curPoint, curPoint, curQuaternion);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(targetAxis, targetAxis, curQuaternion);\n        const rotateDistance = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.dot(targetAxis, gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), prevPoint, curPoint));\n        const rotateDirection = rotateDistance > 0 ? 1 : -1;\n        // when counter clock wise, use vec3.fromValues(0,1,0)\n        // when clock wise, use vec3.fromValues(0,-1,0)\n        // const meshPoint1 = vec3.fromValues(0, 0, 0);\n        const meshPoint2 = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);\n        let meshPoint3;\n        if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {\n            meshPoint3 = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, rotateDirection, 0);\n        } else {\n            meshPoint3 = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(rotateDirection, 0, 0);\n        }\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(meshPoint2, meshPoint2, curQuaternion);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(meshPoint3, meshPoint3, curQuaternion);\n        const vecU = meshPoint2;\n        const vecV = meshPoint3;\n        const vecN = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(vecN, vecU, vecV);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.normalize(vecN, vecN);\n        const coefficientA = vecN[0];\n        const coefficientB = vecN[1];\n        const coefficientC = vecN[2];\n        // a point on the plane\n        curPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(curPoint, curPoint, curQuaternion);\n        // a point should project on the plane\n        prevPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(prevPoint, prevPoint, prevQuaternion);\n        // distance between prevPoint and the plane\n        let distance = Math.abs(prevPoint[0] * coefficientA + prevPoint[1] * coefficientB + prevPoint[2] * coefficientC);\n        const projectedPrevPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.subtract(projectedPrevPoint, prevPoint, gl_matrix__WEBPACK_IMPORTED_MODULE_2__.scale(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), vecN, distance));\n        let trigonometricRatio = (projectedPrevPoint[0] * curPoint[0] + projectedPrevPoint[1] * curPoint[1] + projectedPrevPoint[2] * curPoint[2]) / (gl_matrix__WEBPACK_IMPORTED_MODULE_2__.length(projectedPrevPoint) * gl_matrix__WEBPACK_IMPORTED_MODULE_2__.length(curPoint));\n        // defensive block\n        if (trigonometricRatio > 1) {\n            trigonometricRatio = 1;\n        }\n        const theta = Math.acos(trigonometricRatio);\n        const crossVec = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.cross(gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create(), curPoint, projectedPrevPoint);\n        distance = coefficientA * crossVec[0] + coefficientB * crossVec[1] + coefficientC * crossVec[2];\n        let thetaDirection;\n        if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {\n            thetaDirection = distance > 0 ? 1 : -1;\n        } else {\n            thetaDirection = distance < 0 ? 1 : -1;\n        }\n        const deltaRadian = theta * thetaDirection * rotateDirection;\n        return deltaRadian * RAD_TO_DEG;\n    }\n    _extractPitchFromQuat(quaternion) {\n        const baseV = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 1);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformQuat(baseV, baseV, quaternion);\n        return -1 * Math.atan2(baseV[1], Math.sqrt(Math.pow(baseV[0], 2) + Math.pow(baseV[2], 2)));\n    }\n}\n/**\r\n * Camera's rotation control by gyroscope\r\n * @ko 자이로스코프를 이용한 회전 컨트롤\r\n * @since 4.0.0\r\n */ class GyroControl extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   * @copy CameraControl#enabled\r\n   */ get enabled() {\n        return this._input.enabled;\n    }\n    /**\r\n   * @hidden\r\n   */ get enableBlocked() {\n        return this._enableBlocked;\n    }\n    /**\r\n   * @copy CameraControl#animating\r\n   */ get animating() {\n        return this._input.enabled && this._input.orientationUpdated;\n    }\n    /**\r\n   * When `true`, ignore gyroscope's roll(z-axis rotation) value.\r\n   * :::caution\r\n   * Setting `false` will ignore camera's range limit.\r\n   * Options like {@link View360Options#yawRange}, {@link View360Options#pitchRange} are ignored, and {@link CylinderProjection} also can't force it's camera range limit.\r\n   * :::\r\n   * @ko `true`일 경우 자이로스코프 입력의 roll(z축 회전)값을 무시합니다.\r\n   * :::caution\r\n   * 이 값을 `false`로 설정할 경우 카메라 범위 제약을 무시합니다.\r\n   * {@link View360Options#yawRange}, {@link View360Options#pitchRange}와 같은 값은 무시되며, {@link CylinderProjection} 사용시에도 범위를 벗어날 수 있습니다.\r\n   * :::\r\n   * @default true\r\n   * @since 4.0.0\r\n   */ get ignoreRoll() {\n        return this._ignoreRoll;\n    }\n    set ignoreRoll(val) {\n        this._ignoreRoll = val;\n    }\n    /**\r\n   * Return availability of the gyroscope.\r\n   * :::caution\r\n   * This will always return false until user permission under environments like iOS which requires user permission when using gyroscope.\r\n   * :::\r\n   * @ko 자이로스코프 사용 가능 여부를 반환합니다.\r\n   * :::caution\r\n   * iOS와 같이 GyroScope 사용시 사용자 Permission을 요구하는 환경에서는 사용자 Permission을 받기 전까지 항상 `false`입니다.\r\n   * :::\r\n   * @example\r\n   * ```ts\r\n   * const gyroAvailable = await GyroControl.isAvailable();\r\n   * ```\r\n   */ static isAvailable() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!DeviceMotionEvent) {\n                return false;\n            }\n            let onDeviceMotionChange;\n            const listenDeviceMotion = ()=>new Promise((res)=>{\n                    onDeviceMotionChange = (evt)=>{\n                        res(evt.rotationRate && evt.rotationRate.alpha != null);\n                    };\n                    window.addEventListener(EVENTS$1.DEVICE_MOTION, onDeviceMotionChange);\n                });\n            const timeout = ()=>new Promise((res)=>{\n                    setTimeout(()=>res(false), 1000);\n                });\n            return Promise.race([\n                listenDeviceMotion(),\n                timeout()\n            ]).then((available)=>{\n                window.removeEventListener(EVENTS$1.DEVICE_MOTION, onDeviceMotionChange);\n                return available;\n            });\n        });\n    }\n    /**\r\n   * Request user permission for gyroscope sensor.\r\n   * This can be used in environments like iOS which requires user permission when using gyroscope sensors.\r\n   * @ko 사용자의 sensor permission 취득을 요청합니다.\r\n   * iOS와 같이 gyroscope 사용시 사용자 Permission을 요구하는 환경에서 사용 가능합니다.\r\n   * @returns Whether the permission is granted {@ko 사용자 permission 취득 여부}\r\n   */ static requestSensorPermission() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Request sensor permission, on iOS13+\n            if (sensorCanBeEnabledIOS()) {\n                return DeviceMotionEvent.requestPermission().then((permissionState)=>{\n                    return permissionState === \"granted\";\n                }).catch(()=>false);\n            }\n            return true;\n        });\n    }\n    /**\r\n   * Create new GyroControl instance\r\n   * @ko GyroControl의 인스턴스를 생성합니다.\r\n   * @param enableBlocked - Whether to disable control on init {@ko 초기화 과정에서 컨트롤 활성화 여부}\r\n   * @param options - Options for control {@ko 컨트롤 옵션들}\r\n   */ constructor(enableBlocked, { ignoreRoll = true } = {}){\n        super();\n        this._enableBlocked = enableBlocked;\n        this._ignoreRoll = ignoreRoll;\n        this._input = new GyroInput();\n    }\n    /**\r\n   * @copy CameraControl#destroy\r\n   */ destroy() {\n        this.disable();\n        this._input.off();\n        this.off();\n    }\n    /**\r\n   * @hidden\r\n   */ update(camera, yaw, pitch, zoom) {\n        if (!this._ignoreRoll) {\n            this._updateQuaternion(camera, zoom);\n        } else {\n            this._updateYawPitch(camera, yaw, pitch, zoom);\n        }\n    }\n    /**\r\n   * @copy CameraControl#enable\r\n   */ enable() {\n        if (this._input.enabled) return;\n        this._input.enable();\n        this._enableBlocked = false;\n        this.trigger(CONTROL_EVENTS.ENABLE, {\n            control: this,\n            updateCursor: false\n        });\n    }\n    /**\r\n   * @copy CameraControl#disable\r\n   */ disable() {\n        if (!this._input.enabled) return;\n        this._input.disable();\n        this.trigger(CONTROL_EVENTS.DISABLE, {\n            updateCursor: false\n        });\n    }\n    /**\r\n   * @copy CameraControl#sync\r\n   */ sync() {}\n    _updateYawPitch(camera, yaw, pitch, zoom) {\n        const input = this._input;\n        if (!input.enabled) return;\n        const { yaw: yawDelta, pitch: pitchDelta } = input.collectDelta();\n        yaw.add(yawDelta);\n        pitch.add(pitchDelta);\n        camera.lookAt({\n            yaw: yaw.val,\n            pitch: pitch.val,\n            zoom\n        });\n    }\n    _updateQuaternion(camera, zoom) {\n        const input = this._input;\n        if (!input.enabled) return;\n        input.update();\n        camera.rotate(input.quaternion, zoom);\n    }\n}\n/**\r\n * Panorama control for View360\r\n * @ko View360용 파노라마 컨트롤\r\n * @since 4.0.0\r\n */ class PanoControl {\n    /**\r\n   * @copy View360#useGrabCursor\r\n   */ get useGrabCursor() {\n        return this._useGrabCursor;\n    }\n    set useGrabCursor(val) {\n        if (val === this._useGrabCursor) return;\n        this._useGrabCursor = val;\n        if (val && this._enabled) {\n            this._setCursor(CURSOR.GRAB);\n        } else if (!val) {\n            this._setCursor(CURSOR.NONE);\n        }\n    }\n    /**\r\n   * @copy View360#disableContextMenu\r\n   */ get disableContextMenu() {\n        return this._disableContextMenu;\n    }\n    set disableContextMenu(val) {\n        if (val === this._disableContextMenu) return;\n        this._disableContextMenu = val;\n        if (val && this._enabled) {\n            this._blockContextMenu();\n        } else if (!val) {\n            this._restoreContextMenu();\n        }\n    }\n    /**\r\n   * @copy View360#disableContextMenu\r\n   */ get scrollable() {\n        return this._rotateControl.scrollable;\n    }\n    set scrollable(val) {\n        this._rotateControl.scrollable = val;\n    }\n    /**\r\n   * @copy View360#disableContextMenu\r\n   */ get wheelScrollable() {\n        return this._zoomControl.scrollable;\n    }\n    set wheelScrollable(val) {\n        this._zoomControl.scrollable = val;\n    }\n    /**\r\n   * When `true`, disables rotation slow-down by zoom-value.\r\n   * @ko `true`일 경우 줌 된 정도에 따라 회전속도를 늦추는 동작을 비활성화합니다.\r\n   * @since 4.0.0\r\n   */ get ignoreZoomScale() {\n        return this._ignoreZoomScale;\n    }\n    set ignoreZoomScale(val) {\n        this._ignoreZoomScale = val;\n    }\n    /**\r\n   * Whether the control is enabled or not\r\n   * @ko 컨트롤 활성화 여부를 가리키는 값\r\n   * @readonly\r\n   * @since 4.0.0\r\n   */ get enabled() {\n        return this._enabled;\n    }\n    /**\r\n   * @copy View360#rotate\r\n   */ get rotate() {\n        return this._rotateControl;\n    }\n    /**\r\n   * @copy View360#zoom\r\n   */ get zoom() {\n        return this._zoomControl;\n    }\n    /**\r\n   * @copy View360#gyro\r\n   */ get gyro() {\n        return this._gyroControl;\n    }\n    /**\r\n   * Whether one of the controls is animating at the moment\r\n   * @ko 현재 컨트롤 중 하나라도 동작중인지 여부를 나타내는 값\r\n   * @readonly\r\n   * @since 4.0.0\r\n   */ get animating() {\n        return this._rotateControl.animating || this._zoomControl.animating || this._gyroControl.animating;\n    }\n    /**\r\n   * Create new instance.\r\n   * @ko 새 인스턴스를 생성합니다.\r\n   * @param element - Canvas element {@ko 캔버스 엘리먼트}\r\n   * @param camera - Camera instance {@ko Camera 인스턴스}\r\n   * @param options - Options for PanoControl {@ko PanoControl 옵션들}\r\n   */ constructor(element, camera, { useGrabCursor, scrollable, wheelScrollable, disableContextMenu, rotate, zoom, gyro }){\n        this._preventContextMenu = (evt)=>{\n            evt.preventDefault();\n        };\n        this._onInputStart = (evt)=>{\n            if (this._useGrabCursor && !evt.isKeyboard) {\n                this._setCursor(CURSOR.GRABBING);\n            }\n        };\n        this._onInputEnd = (evt)=>{\n            if (this._useGrabCursor && !evt.isKeyboard) {\n                this._setCursor(CURSOR.GRAB);\n            }\n        };\n        this._onEnable = ({ control, updateCursor })=>{\n            if (updateCursor && this._useGrabCursor) {\n                this._setCursor(CURSOR.GRAB);\n            }\n            control.sync(this._camera);\n        };\n        this._onDisable = ({ updateCursor })=>{\n            if (updateCursor) {\n                this._setCursor(CURSOR.NONE);\n            }\n        };\n        this._onCameraAnimationEnd = ({ animation })=>{\n            animation.getFinishPromise().then(()=>{\n                this.sync();\n            });\n        };\n        // Bind Options\n        this._useGrabCursor = useGrabCursor;\n        this._disableContextMenu = disableContextMenu;\n        // Set internal values\n        this._camera = camera;\n        this._controlEl = element;\n        this._ignoreZoomScale = false;\n        this._enabled = false;\n        this._rotateControl = new RotateControl(element, !rotate, getObjectOption(rotate));\n        this._zoomControl = new ZoomControl(element, !zoom, getObjectOption(zoom));\n        this._gyroControl = new GyroControl(!gyro, getObjectOption(gyro));\n        this._rotateControl.scrollable = scrollable;\n        this._zoomControl.scrollable = wheelScrollable;\n        this._bindEvents();\n    }\n    /**\r\n   * Destroy the instance and remove all event listeners attached.\r\n   * This also will reset CSS cursor to initial.\r\n   * @ko 인스턴스를 삭제하고 부착된 모든 이벤트 리스너를 제거합니다.\r\n   * 또한, 캔버스에 적용된 CSS cursor도 제거합니다.\r\n   * @since 4.0.0\r\n   */ destroy() {\n        this.disable();\n        this._rotateControl.destroy();\n        this._zoomControl.destroy();\n        this._setCursor(CURSOR.NONE);\n    }\n    /**\r\n   * Resize control to match target size.\r\n   * @ko 컨트롤이 내부에 캐시하고 있는 크기값을 갱신합니다.\r\n   * @param width New width {@ko 변경된 너비}\r\n   * @param height New height {@ko 변경된 높이}\r\n   * @since 4.0.0\r\n   */ resize(width, height) {\n        const camera = this._camera;\n        this._rotateControl.resize(camera.fov, camera.aspect, width, height);\n    }\n    /**\r\n   * Enable this control and add event listeners.\r\n   * @ko 컨트롤을 활성화하고 이벤트 리스너들을 추가합니다.\r\n   * @since 4.0.0\r\n   */ enable() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._enabled) return;\n            if (!this._rotateControl.enableBlocked) {\n                this._rotateControl.enable();\n            }\n            if (!this._zoomControl.enableBlocked) {\n                this._zoomControl.enable();\n            }\n            if (!this._gyroControl.enableBlocked) {\n                if (yield GyroControl.isAvailable()) {\n                    this._gyroControl.enable();\n                }\n            }\n            this.sync();\n            if (this._disableContextMenu) {\n                this._blockContextMenu();\n            }\n            this._enabled = true;\n        });\n    }\n    /**\r\n   * Disable this control and remove all event listeners\r\n   * @ko 컨트롤을 비활성화하고 모든 이벤트 리스너들을 제거합니다.\r\n   * @since 4.0.0\r\n   */ disable() {\n        if (!this._enabled) return;\n        this._rotateControl.disable();\n        this._zoomControl.disable();\n        this._gyroControl.disable();\n        this._restoreContextMenu();\n        this._enabled = false;\n    }\n    /**\r\n   * Update control by given deltaTime\r\n   * @ko 컨트롤을 주어진 시간만큼 업데이트합니다.\r\n   * @param delta Number of milisec to update {@ko 업데이트할 시간, 밀리초 단위}\r\n   * @since 4.0.0\r\n   * @internal\r\n   */ update(delta) {\n        const camera = this._camera;\n        const rotateControl = this._rotateControl;\n        const zoomControl = this._zoomControl;\n        const gyroControl = this._gyroControl;\n        zoomControl.update(delta);\n        const zoom = hfovToZoom(camera.fov, zoomControl.zoom);\n        // Slow down rotation on zoom-in\n        const zoomScale = this._ignoreZoomScale ? 1 : Math.max(zoom, 1);\n        rotateControl.setZoomScale(zoomScale);\n        rotateControl.updateRange(camera, zoom);\n        rotateControl.update(delta);\n        const yaw = rotateControl.yaw;\n        const pitch = rotateControl.pitch;\n        if (gyroControl.enabled) {\n            gyroControl.update(camera, yaw, pitch, zoom);\n        } else {\n            camera.lookAt({\n                yaw: yaw.val,\n                pitch: pitch.val,\n                zoom\n            });\n        }\n    }\n    /**\r\n   * Synchronize this control's state to current camera state\r\n   * @ko 컨트롤을 카메라의 현재 상태와 동기화합니다.\r\n   * @since 4.0.0\r\n   */ sync() {\n        const camera = this._camera;\n        this._zoomControl.sync(camera);\n        this._rotateControl.sync(camera);\n    }\n    _blockContextMenu() {\n        const el = this._controlEl;\n        el.addEventListener(EVENTS$1.CONTEXT_MENU, this._preventContextMenu);\n    }\n    _restoreContextMenu() {\n        const el = this._controlEl;\n        el.removeEventListener(EVENTS$1.CONTEXT_MENU, this._preventContextMenu);\n    }\n    _setCursor(newCursor) {\n        if (!this._useGrabCursor && newCursor !== CURSOR.NONE) return;\n        const targetEl = this._controlEl;\n        targetEl.style.cursor = newCursor;\n    }\n    _bindEvents() {\n        const rotateControl = this._rotateControl;\n        const zoomControl = this._zoomControl;\n        rotateControl.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        rotateControl.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        rotateControl.on(CONTROL_EVENTS.ENABLE, this._onEnable);\n        rotateControl.on(CONTROL_EVENTS.DISABLE, this._onDisable);\n        zoomControl.on(CONTROL_EVENTS.ENABLE, this._onEnable);\n        zoomControl.on(CONTROL_EVENTS.DISABLE, this._onDisable);\n        this._camera.on(CAMERA_EVENTS.ANIMATION_END, this._onCameraAnimationEnd);\n    }\n}\n/**\r\n * @hidden\r\n */ class Texture {\n    constructor({ width, height, flipY }){\n        this.width = width;\n        this.height = height;\n        this.flipY = flipY;\n        this.wrapS = WebGLRenderingContext.CLAMP_TO_EDGE;\n        this.wrapT = WebGLRenderingContext.CLAMP_TO_EDGE;\n    }\n    destroy() {\n    // DO_NOTHING\n    }\n    isVideo() {\n        return false;\n    }\n    isCube() {\n        return false;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class Texture2D extends Texture {\n    constructor({ source, width, height, flipY }){\n        super({\n            width,\n            height,\n            flipY\n        });\n        this.source = source;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class TextureVideo extends Texture2D {\n    destroy() {\n        const video = this.source;\n        video.pause();\n        video.removeAttribute(\"src\");\n        video.load();\n    }\n    isVideo() {\n        return true;\n    }\n    isPaused() {\n        const video = this.source;\n        return video.paused || video.ended || video.readyState <= 2;\n    }\n    hasAudio() {\n        const video = this.source;\n        if (video.audioTracks) {\n            return video.audioTracks.length > 0;\n        }\n        if (video.webkitAudioDecodedByteCount != null) {\n            return video.webkitAudioDecodedByteCount > 0;\n        }\n        if (video.mozHasAudio != null) {\n            return video.mozHasAudio;\n        }\n        // We don't know whether the video has audio or not, return true\n        return true;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class TextureCube extends Texture {\n    constructor({ sources, width, height, flipY }){\n        super({\n            width,\n            height,\n            flipY\n        });\n        this.sources = sources;\n    }\n    isCube() {\n        return true;\n    }\n}\n/**\r\n * @hidden\r\n */ class TextureLoader {\n    constructor(){\n        this._loadChecker = new _egjs_imready__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n    }\n    load(src, video) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (video) {\n                return this.loadVideo(src, getObjectOption(video));\n            } else {\n                if (Array.isArray(src) && src.length > 1) {\n                    return this.loadCubeImage(src);\n                } else {\n                    const imgSrc = Array.isArray(src) ? src[0] : src;\n                    return this.loadImage(imgSrc);\n                }\n            }\n        });\n    }\n    loadImage(src) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const images = this._toImageArray(src);\n            return this._load(images, (resolve)=>{\n                const image = images[0];\n                resolve(new Texture2D({\n                    source: image,\n                    width: image.naturalWidth,\n                    height: image.naturalHeight,\n                    flipY: true\n                }));\n            });\n        });\n    }\n    loadCubeImage(src) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const images = this._toImageArray(src);\n            return this._load(images, (resolve)=>{\n                resolve(new TextureCube({\n                    sources: images,\n                    width: images[0].naturalWidth,\n                    height: images[0].naturalHeight,\n                    flipY: false\n                }));\n            });\n        });\n    }\n    loadVideo(src, videoConfig) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const config = Object.assign({\n                autoplay: true,\n                muted: true,\n                loop: false,\n                volume: 1\n            }, videoConfig);\n            const video = this._toVideoElement(src, config);\n            return this._load([\n                video\n            ], (resolve)=>{\n                const { autoplay, muted } = config;\n                video.currentTime = 0;\n                if (autoplay && muted) {\n                    video.play().catch(()=>void 0);\n                }\n                resolve(new TextureVideo({\n                    source: video,\n                    width: video.videoWidth,\n                    height: video.videoHeight,\n                    flipY: true\n                }));\n            });\n        });\n    }\n    _load(content, onLoad) {\n        const loader = this._loadChecker;\n        return new Promise((resolve, reject)=>{\n            loader.once(\"ready\", (evt)=>{\n                if (evt.errorCount > 0) return;\n                onLoad(resolve);\n            });\n            loader.once(\"error\", reject);\n            loader.check(content);\n        });\n    }\n    _toImageArray(src) {\n        const srcs = Array.isArray(src) ? src : [\n            src\n        ];\n        return srcs.map((source)=>{\n            if (isString(source)) {\n                const imgEl = new Image();\n                imgEl.crossOrigin = \"anonymous\";\n                imgEl.src = source;\n                return imgEl;\n            } else {\n                return source;\n            }\n        });\n    }\n    _toVideoElement(src, { muted, loop, volume }) {\n        if (src instanceof HTMLVideoElement) {\n            return src;\n        }\n        const video = document.createElement(\"video\");\n        video.crossOrigin = \"anonymous\";\n        video.playsInline = true;\n        video.setAttribute(\"webkit-playsinline\", \"\");\n        video.muted = muted;\n        video.volume = volume;\n        video.loop = loop;\n        if (Array.isArray(src)) {\n            src.forEach((source)=>this._appendSourceElement(video, source));\n        } else {\n            this._appendSourceElement(video, src);\n        }\n        const sourceCount = video.querySelectorAll(\"source\").length;\n        if (sourceCount > 0 && video.readyState < 1) {\n            video.load();\n        }\n        return video;\n    }\n    _appendSourceElement(video, src) {\n        if (src instanceof HTMLSourceElement) {\n            return src;\n        }\n        const sourceEl = document.createElement(\"source\");\n        sourceEl.src = src;\n        video.appendChild(sourceEl);\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @internal\r\n */ class FrameAnimator {\n    /** */ constructor(maxDeltaTime, context = window){\n        this.maxDeltaTime = maxDeltaTime;\n        this._context = context;\n        this._rafId = -1;\n        this._rafTimer = -1;\n        this._lastUpdateTime = -1;\n    }\n    start(callback) {\n        const context = this._context;\n        // No context / callback set\n        if (!context || !callback) return;\n        // Animation already started\n        if (this._rafId >= 0 || this._rafTimer >= 0) return;\n        const loop = (_time, frame)=>{\n            const time = Date.now();\n            const delta = Math.min(time - this._lastUpdateTime, this.maxDeltaTime * 1000);\n            callback(delta, frame);\n            this._lastUpdateTime = time;\n            this._rafId = context.requestAnimationFrame(loop);\n        };\n        this._lastUpdateTime = Date.now();\n        this._rafId = context.requestAnimationFrame(loop);\n    }\n    stop() {\n        if (this._rafId >= 0) {\n            this._context.cancelAnimationFrame(this._rafId);\n        }\n        if (this._rafTimer >= 0) {\n            clearTimeout(this._rafTimer);\n        }\n        this._rafId = -1;\n        this._rafTimer = -1;\n    }\n    changeContext(context) {\n        this.stop();\n        this._context = context;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Automatic resizer that uses both ResizeObserver and window resize event\r\n */ class AutoResizer {\n    get useResizeObserver() {\n        return this._useResizeObserver;\n    }\n    /**\r\n   * Returns whether AutoResizer is enabled\r\n   */ get enabled() {\n        return this._enabled;\n    }\n    /** */ constructor(useResizeObserver, onResize){\n        // eslint-disable-next-line @typescript-eslint/member-ordering\n        this._skipFirstResize = (()=>{\n            let isFirstResize = true;\n            return ()=>{\n                if (isFirstResize) {\n                    isFirstResize = false;\n                    return;\n                }\n                this._onResize();\n            };\n        })();\n        this._useResizeObserver = useResizeObserver;\n        this._enabled = false;\n        this._resizeObserver = null;\n        this._onResize = onResize;\n    }\n    /**\r\n   * Enable resizer\r\n   */ enable(element) {\n        if (this._enabled) {\n            this.disable();\n        }\n        if (this._useResizeObserver && !!window.ResizeObserver) {\n            const bbox = element.getBoundingClientRect();\n            const resizeImmediate = bbox.width !== 0 || bbox.height !== 0;\n            const resizeObserver = new ResizeObserver(resizeImmediate ? this._skipFirstResize : this._onResize);\n            resizeObserver.observe(element);\n            this._resizeObserver = resizeObserver;\n        } else {\n            window.addEventListener(EVENTS$1.RESIZE, this._onResize);\n        }\n        this._enabled = true;\n        return this;\n    }\n    /**\r\n   * Disable resizer\r\n   */ disable() {\n        if (!this._enabled) return this;\n        const resizeObserver = this._resizeObserver;\n        if (resizeObserver) {\n            resizeObserver.disconnect();\n            this._resizeObserver = null;\n        } else {\n            window.removeEventListener(EVENTS$1.RESIZE, this._onResize);\n        }\n        this._enabled = false;\n        return this;\n    }\n}\n/**\r\n * A manager class for autoplay feature.\r\n * @ko Autoplay 기능의 매니저 클래스.\r\n * @since 4.0.0\r\n */ class Autoplay {\n    /**\r\n   * Whether autoplay is enabled or not\r\n   * @ko 자동재생 활성화 여부를 나타내는 값\r\n   * @readonly\r\n   * @since 4.0.0\r\n   */ get enabled() {\n        return this._enabled;\n    }\n    /**\r\n   * @hidden\r\n   */ get enableBlocked() {\n        return this._enableBlocked;\n    }\n    /**\r\n   * Whether autoplay is updating the camera at the moment\r\n   * @ko 현재 자동재생이 동작중인지 여부를 나타내는 값\r\n   * @readonly\r\n   * @since 4.0.0\r\n   */ get playing() {\n        return this._enabled && !this._interrupted;\n    }\n    /**\r\n   * Reactivation delay after mouse input in milisecond.\r\n   * @ko 재활성화되기까지의 시간 (밀리초 단위)\r\n   * @default 2000\r\n   * @since 4.0.0\r\n   */ get delay() {\n        return this._delay;\n    }\n    set delay(val) {\n        this._delay = val;\n    }\n    /**\r\n   * Reactivation delay after mouse leave when using {@link AutoplayOptions#pauseOnHover}\r\n   * @ko {@link AutoplayOptions#pauseOnHover} 사용시 마우스가 캔버스 영역을 떠난 뒤 자동재생이 다시 활성화되기까지의 시간\r\n   * @default 0\r\n   * @since 4.0.0\r\n   */ get delayOnMouseLeave() {\n        return this._delayOnMouseLeave;\n    }\n    set delayOnMouseLeave(val) {\n        this._delayOnMouseLeave = val;\n    }\n    /**\r\n   * Y-axis(yaw) rotation speed\r\n   * @ko Y-축 회전(yaw)의 속도\r\n   * @default 1\r\n   * @since 4.0.0\r\n   */ get speed() {\n        return this._speed;\n    }\n    set speed(val) {\n        this._speed = val;\n    }\n    /**\r\n   * Whether to pause rotation on mouse hover\r\n   * @ko 마우스가 캔버스 영역에 들어왔을 때 자동재생을 정지할지 여부\r\n   * @default false\r\n   * @since 4.0.0\r\n   */ get pauseOnHover() {\n        return this._pauseOnHover;\n    }\n    set pauseOnHover(val) {\n        this._pauseOnHover = val;\n    }\n    /**\r\n   * Whether user can interrupt the rotation with click/wheel input\r\n   * @ko 클릭이나 휠같은 사용자 인터랙션시 자동재생을 멈출지 여부\r\n   * @default true\r\n   * @since 4.0.0\r\n   */ get canInterrupt() {\n        return this._canInterrupt;\n    }\n    set canInterrupt(val) {\n        this._canInterrupt = val;\n    }\n    /**\r\n   * Whether to disable autoplay on user interrupt\r\n   * @ko 사용자 동작에 의해 자동재생이 정지할 때, {@link Autoplay#disable}을 호출하여 자동재생을 영구히 정지할지 여부\r\n   * @default false\r\n   * @since 4.0.0\r\n   */ get disableOnInterrupt() {\n        return this._disableOnInterrupt;\n    }\n    set disableOnInterrupt(val) {\n        this._disableOnInterrupt = val;\n    }\n    /**\r\n   * Create new AutoPlayer instance\r\n   * @param camera - Instance of the {@link Camera} {@ko Camera의 인스턴스}\r\n   * @param element - Canvas element {@ko 캔버스 엘리먼트}\r\n   * @param options - Autoplay options {@ko 자동재생 옵션들}\r\n   * @since 4.0.0\r\n   */ constructor(viewer, element, options){\n        this._onInputStart = ()=>{\n            if (!this._canInterrupt) return;\n            this._interrupted = true;\n            this._clearTimeout();\n        };\n        this._onInputEnd = ()=>{\n            this._setUninterruptedAfterDelay(this._delay);\n        };\n        this._onGyroEnable = ()=>{\n            this.disable();\n        };\n        this._onMouseEnter = ()=>{\n            if (!this._pauseOnHover) return;\n            this._interrupted = true;\n            this._hovering = true;\n        };\n        this._onMouseLeave = ()=>{\n            if (!this._pauseOnHover) return;\n            this._hovering = false;\n            this._setUninterruptedAfterDelay(this._delayOnMouseLeave);\n        };\n        this._camera = viewer.camera;\n        this._control = viewer.control;\n        this._element = element;\n        this._enabled = false;\n        this._interrupted = false;\n        this._interruptionTimer = -1;\n        this._hovering = false;\n        const { delay = 2000, delayOnMouseLeave = 0, speed = 1, pauseOnHover = false, canInterrupt = true, disableOnInterrupt = false } = getObjectOption(options);\n        this._enableBlocked = !options;\n        this._delay = delay;\n        this._delayOnMouseLeave = delayOnMouseLeave;\n        this._speed = speed;\n        this._pauseOnHover = pauseOnHover;\n        this._canInterrupt = canInterrupt;\n        this._disableOnInterrupt = disableOnInterrupt;\n    }\n    /**\r\n   * Destroy the instance and remove all event listeners attached\r\n   * @ko 인스턴스를 제거하고 연결된 모든 이벤트 핸들러를 삭제합니다.\r\n   * @since 4.0.0\r\n   */ destroy() {\n        this.disable();\n    }\n    /**\r\n   * Rotate camera by given deltaTime\r\n   * @ko 주어진 deltaTime만큼 카메라를 회전시킵니다.\r\n   * @param deltaTime - Number of milisec to update {@ko 업데이트할 시간, 밀리초 단위}\r\n   * @since 4.0.0\r\n   */ update(deltaTime) {\n        if (!this._enabled) return;\n        if (this._interrupted) {\n            if (this._disableOnInterrupt) {\n                this.disable();\n            }\n            return;\n        }\n        const camera = this._camera;\n        const delta = -this._speed * deltaTime / 100;\n        camera.yaw = circulate(camera.yaw + delta, 0, 360);\n    }\n    /**\r\n   * Enable autoplay and add event listeners.\r\n   * @ko 자동재생을 활성화하고 이벤트리스너들을 추가합니다.\r\n   * @since 4.0.0\r\n   */ enable() {\n        const control = this._control;\n        const element = this._element;\n        if (this._enabled || control.gyro.enabled) return;\n        control.rotate.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        control.rotate.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        control.zoom.on(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        control.zoom.on(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        control.gyro.on(CONTROL_EVENTS.ENABLE, this._onGyroEnable);\n        element.addEventListener(EVENTS$1.MOUSE_ENTER, this._onMouseEnter, false);\n        element.addEventListener(EVENTS$1.MOUSE_LEAVE, this._onMouseLeave, false);\n        this._enabled = true;\n        this._enableBlocked = false;\n    }\n    /**\r\n   * Enable autoplay after current `delay` value.\r\n   * @ko 현재의 `delay`값만큼 시간이 지난 다음에 자동재생을 활성화합니다.\r\n   * @since 4.0.0\r\n   */ enableAfterDelay() {\n        this.enable();\n        this._interrupted = true;\n        this._setUninterruptedAfterDelay(this._delay);\n    }\n    /**\r\n   * Disable autoplay and remove all event handlers.\r\n   * @ko 자동재생을 비활성화하고 모든 이벤트 핸들러를 제거합니다.\r\n   * @since 4.0.0\r\n   */ disable() {\n        if (!this._enabled) return;\n        const control = this._control;\n        const element = this._element;\n        control.rotate.off(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        control.rotate.off(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        control.zoom.off(CONTROL_EVENTS.INPUT_START, this._onInputStart);\n        control.zoom.off(CONTROL_EVENTS.INPUT_END, this._onInputEnd);\n        control.gyro.off(CONTROL_EVENTS.ENABLE, this._onGyroEnable);\n        element.removeEventListener(EVENTS$1.MOUSE_ENTER, this._onMouseEnter, false);\n        element.removeEventListener(EVENTS$1.MOUSE_LEAVE, this._onMouseLeave, false);\n        this._enabled = false;\n        this._interrupted = false;\n        this._hovering = false;\n        this._clearTimeout();\n    }\n    _setUninterruptedAfterDelay(delay) {\n        if (this._hovering) return;\n        this._clearTimeout();\n        if (delay > 0) {\n            this._interruptionTimer = window.setTimeout(()=>{\n                this._interrupted = false;\n                this._interruptionTimer = -1;\n            }, delay);\n        } else {\n            this._interrupted = false;\n            this._interruptionTimer = -1;\n        }\n    }\n    _clearTimeout() {\n        if (this._interruptionTimer >= 0) {\n            window.clearTimeout(this._interruptionTimer);\n            this._interruptionTimer = -1;\n        }\n    }\n}\n/**\r\n * WebXR manager class\r\n * @ko WebXR 매니저 클래스\r\n * @since 4.0.0\r\n */ class XRManager extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   * Create new instance.\r\n   * 새 인스턴스를 생성합니다.\r\n   * @param ctx - Instance of WebGL context helper {@ko WebGL 콘텍스트 헬퍼의 인스턴스}\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor(ctx, options = {}){\n        super();\n        /**\r\n     * Destroy instance and end XR session if there was any.\r\n     * @ko 인스턴스를 제거하고, XR 세션이 존재할 경우 종료합니다.\r\n     * @since 4.0.0\r\n     */ this.destroy = ()=>{\n            this.exit();\n            this.off();\n        };\n        this._onSessionEnd = ()=>{\n            this.exit();\n            this.trigger(EVENTS.VR_END);\n        };\n        this._xrSession = null;\n        this._xrRefSpace = null;\n        this._ctx = ctx;\n        this._options = options;\n    }\n    /**\r\n   * Returns WebXR availability.\r\n   * @ko WebXR 사용 가능 여부를 반환합니다.\r\n   * @since 4.0.0\r\n   */ isAvailable() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // eslint-disable-next-line compat/compat\n            const xr = window.navigator.xr;\n            if (!xr) return false;\n            return xr.isSessionSupported(SESSION_VR).then((available)=>{\n                return available;\n            }).catch(()=>{\n                return false;\n            });\n        });\n    }\n    /**\r\n   * Enter VR session\r\n   * @ko VR 세션에 진입합니다.\r\n   * @since 4.0.0\r\n   */ enter() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const ctx = this._ctx;\n            // eslint-disable-next-line compat/compat\n            const xr = window.navigator.xr;\n            if (!xr) return;\n            yield GyroControl.requestSensorPermission();\n            const options = Object.assign({\n                requiredFeatures: [\n                    XR_REFERENCE_SPACE\n                ]\n            }, this._options);\n            yield ctx.makeXRCompatible();\n            const session = yield xr.requestSession(SESSION_VR, options);\n            ctx.bindXRLayer(session);\n            const refSpace = yield session.requestReferenceSpace(XR_REFERENCE_SPACE);\n            this._setSession(session, refSpace);\n            this.trigger(EVENTS.VR_START, {\n                session\n            });\n        });\n    }\n    /**\r\n   * Exit VR session\r\n   * @ko VR 세션에서 나갑니다.\r\n   * @since 4.0.0\r\n   */ exit() {\n        const xrSession = this._xrSession;\n        if (xrSession) {\n            xrSession.end().catch(()=>void 0);\n        }\n        this._xrSession = null;\n        this._xrRefSpace = null;\n    }\n    /**\r\n   * @hidden\r\n   */ canRender(frame) {\n        const refSpace = this._xrRefSpace;\n        if (!refSpace) return false;\n        const pose = frame.getViewerPose(refSpace);\n        return !!pose;\n    }\n    /**\r\n   * @hidden\r\n   */ getEyeParams(frame) {\n        const session = frame.session;\n        const pose = frame.getViewerPose(this._xrRefSpace);\n        if (!pose) return null;\n        const glLayer = session.renderState.baseLayer;\n        if (!glLayer) return null;\n        return pose.views.map((view)=>{\n            const viewport = glLayer.getViewport(view);\n            const vMatrix = view.transform.inverse.matrix;\n            return {\n                viewport,\n                vMatrix,\n                pMatrix: view.projectionMatrix\n            };\n        });\n    }\n    _setSession(session, refSpace) {\n        this._xrSession = session;\n        this._xrRefSpace = refSpace;\n        session.addEventListener(EVENTS$1.XR_END, this._onSessionEnd);\n    }\n}\n/**\r\n * Hotspot data\r\n * @ko 핫스팟 데이터\r\n * @since 4.0.0\r\n */ class Hotspot {\n    constructor(element, position){\n        this.element = element;\n        this.position = position;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Hotspot renderer\r\n * @ko Hotspot 렌더러\r\n * @since 4.0.0\r\n */ class HotspotRenderer {\n    /**\r\n   * Create new instance\r\n   * @ko 새 인스턴스를 생성합니다.\r\n   * @param rootEl - Container element for hotspots {@ko 핫스팟들의 컨테이너 엘리먼트}\r\n   * @param renderer - instance of WebGLRenderer {@ko WebGLRenderer의 인스턴스}\r\n   * @param options - Hotspot options {@ko Hotspot 옵션들 }\r\n   */ constructor(rootEl, renderer, { zoom = false }){\n        this._containerEl = getNullableElement(`.${DEFAULT_CLASS.HOTSPOT_CONTAINER}`, rootEl);\n        this._renderer = renderer;\n        this._hotspots = [];\n        this._zoom = zoom;\n    }\n    /**\r\n   * Refresh hotspots by collecting hotspot elements from current hotspot root element\r\n   * @ko 현재 핫스팟 루트 엘리먼트 내에서 핫스팟 엘리먼트들을 수집하여 갱신합니다.\r\n   * @throws {ERROR_CODES.INSUFFICIENT_ARGS} if data-position doesn't include all x, y, z values {@ko data-position이 x, y, z좌표를 전부 포함하고 있지 않을 때}\r\n   */ refresh() {\n        const container = this._containerEl;\n        if (!container) return;\n        const hotspotEls = [].slice.apply(container.querySelectorAll(`.${DEFAULT_CLASS.HOTSPOT}`));\n        this._hotspots = hotspotEls.map((el)=>this._parseHotspot(el));\n    }\n    /**\r\n   * Render hotspots\r\n   * @ko 핫스팟들을 렌더링합니다.\r\n   * @param camera - Instance of Camera {@ko Camera의 인스턴스}\r\n   */ render(camera) {\n        const hotspots = this._hotspots;\n        const halfWidth = this._renderer.width * 0.5;\n        const halfHeight = this._renderer.height * 0.5;\n        const zoom = camera.zoom;\n        const centerTransform = \"translate(-50%, -50%)\";\n        const zoomTransform = this._zoom ? `scale(${zoom})` : \"\";\n        hotspots.forEach((hotspot)=>{\n            const position = hotspot.position;\n            const relPos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\n            gl_matrix__WEBPACK_IMPORTED_MODULE_2__.copy(relPos, position);\n            gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformMat4(relPos, relPos, camera.viewMatrix);\n            gl_matrix__WEBPACK_IMPORTED_MODULE_2__.transformMat4(relPos, relPos, camera.projectionMatrix);\n            if (relPos[2] > 1 || relPos[2] < 0) {\n                hotspot.element.classList.remove(DEFAULT_CLASS.HOTSPOT_VISIBLE);\n                return;\n            }\n            const screenPos = gl_matrix__WEBPACK_IMPORTED_MODULE_5__.fromValues(relPos[0] * halfWidth + halfWidth, -relPos[1] * halfHeight + halfHeight);\n            hotspot.element.classList.add(DEFAULT_CLASS.HOTSPOT_VISIBLE);\n            hotspot.element.style.transform = [\n                centerTransform,\n                `translate(${screenPos[0]}px, ${screenPos[1]}px)`,\n                zoomTransform\n            ].join(\" \");\n        });\n    }\n    _parseHotspot(element) {\n        const yawStr = element.dataset.yaw;\n        const pitchStr = element.dataset.pitch;\n        const positionStr = element.dataset.position;\n        if (yawStr || pitchStr) {\n            const yaw = yawStr ? parseFloat(yawStr) : 0;\n            const pitch = pitchStr ? parseFloat(pitchStr) : 0;\n            const position = this._yawPitchToVec3(yaw, pitch);\n            return new Hotspot(element, position);\n        } else if (positionStr) {\n            const pos = positionStr.split(\" \").map((val)=>parseFloat(val));\n            if (pos.length < 3) {\n                throw new View360Error(ERROR.MESSAGES.INSUFFICIENT_ARGS(positionStr, 'hotspot attribute \"data-position\"'), ERROR.CODES.INSUFFICIENT_ARGS);\n            }\n            return new Hotspot(element, gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(pos[0], pos[1], pos[2]));\n        } else {\n            // Place hotspot at yaw: 0, pitch: 0\n            const defaultPos = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, -1);\n            return new Hotspot(element, defaultPos);\n        }\n    }\n    _yawPitchToVec3(yaw, pitch) {\n        const yawRad = yaw * DEG_TO_RAD;\n        const pitchRad = pitch * DEG_TO_RAD;\n        const position = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.create();\n        position[1] = Math.sin(pitchRad);\n        position[2] = Math.cos(pitchRad);\n        position[0] = position[2] * Math.sin(-yawRad);\n        position[2] = -position[2] * Math.cos(-yawRad);\n        return position;\n    }\n}\n/**\r\n * @hidden\r\n */ class VertexArrayObject {\n    get count() {\n        return this.geometry.indicies.count;\n    }\n    constructor(obj, geometry, buffers){\n        this.obj = obj;\n        this.geometry = geometry;\n        this.buffers = buffers;\n    }\n}\n/**\r\n * @hidden\r\n */ class WebGLContext {\n    get canvas() {\n        return this._canvas;\n    }\n    get maxTextureSize() {\n        return this._maxTextureSize;\n    }\n    get isWebGL2() {\n        return this._isWebGL2;\n    }\n    get supportVAO() {\n        return this._isWebGL2 || !!this._extensions.vao;\n    }\n    get lost() {\n        return this._contextLost;\n    }\n    get debug() {\n        return this._debug;\n    }\n    constructor(canvas, debug){\n        this._onContextLost = ()=>{\n            const canvas = this._canvas;\n            canvas.classList.add(DEFAULT_CLASS.CTX_LOST);\n            this._contextLost = true;\n        };\n        this._onContextRestore = ()=>{\n            const canvas = this._canvas;\n            canvas.classList.remove(DEFAULT_CLASS.CTX_LOST);\n            this._contextLost = false;\n        };\n        this._canvas = canvas;\n        this._contextLost = false;\n        this._debug = debug;\n        this._extensions = {\n            vao: null,\n            loseContext: null\n        };\n    }\n    init() {\n        const canvas = this._canvas;\n        const { gl, isWebGL2 } = this._getContext(canvas);\n        this._gl = gl;\n        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n        this._isWebGL2 = isWebGL2;\n        if (!this._isWebGL2) {\n            this._extensions.vao = gl.getExtension(\"OES_vertex_array_object\");\n        }\n        this._extensions.loseContext = gl.getExtension(\"WEBGL_lose_context\");\n        canvas.addEventListener(EVENTS$1.CONTEXT_LOST, this._onContextLost);\n        canvas.addEventListener(EVENTS$1.CONTEXT_RESTORED, this._onContextRestore);\n    // gl.enable(gl.DEPTH_TEST);\n    }\n    destroy() {\n        const gl = this._gl;\n        const canvas = this._canvas;\n        if (gl) {\n            // gl is not defined when destroy is called before init\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        }\n        canvas.removeEventListener(EVENTS$1.CONTEXT_LOST, this._onContextLost);\n        canvas.removeEventListener(EVENTS$1.CONTEXT_RESTORED, this._onContextRestore);\n    }\n    forceLoseContext() {\n        const extension = this._extensions.loseContext;\n        if (!extension) return;\n        extension.loseContext();\n    }\n    forceRestoreContext() {\n        const extension = this._extensions.loseContext;\n        if (!extension) return;\n        extension.restoreContext();\n    }\n    clear() {\n        const gl = this._gl;\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n    resize() {\n        const gl = this._gl;\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    }\n    viewport(x, y, width, height) {\n        const gl = this._gl;\n        gl.viewport(x, y, width, height);\n    }\n    createVAO(geometry, shaderProgram) {\n        const nativeVAO = this._createNativeVAO();\n        const vao = new VertexArrayObject(nativeVAO, geometry, {\n            indicies: this._createBuffer(),\n            position: this._createBuffer(),\n            uv: this._createBuffer()\n        });\n        if (nativeVAO) {\n            this._bindNativeVAO(nativeVAO);\n            this._supplyGeometryData(vao, shaderProgram);\n            this._bindNativeVAO(null);\n            this._unbindBuffers();\n        }\n        return vao;\n    }\n    draw(vao, shaderProgram) {\n        const gl = this._gl;\n        if (vao.obj) {\n            this._bindNativeVAO(vao.obj);\n        } else {\n            this._supplyGeometryData(vao, shaderProgram);\n        }\n        gl.drawElements(gl.TRIANGLES, vao.count, gl.UNSIGNED_SHORT, 0);\n        if (vao.obj) {\n            this._bindNativeVAO(null);\n        } else {\n            this._unbindBuffers();\n        }\n    }\n    releaseVAO(vao) {\n        if (vao.obj) {\n            this._deleteNativeVAO(vao.obj);\n        }\n        this._deleteBuffer(vao.buffers.indicies);\n        this._deleteBuffer(vao.buffers.position);\n        this._deleteBuffer(vao.buffers.uv);\n    }\n    getUniformLocations(program, uniforms) {\n        const gl = this._gl;\n        const uniformLocations = Object.keys(uniforms).reduce((locations, key)=>{\n            locations[key] = gl.getUniformLocation(program, key);\n            return locations;\n        }, {});\n        return Object.assign(Object.assign({}, this._getCommonUniformLocations(program)), uniformLocations);\n    }\n    updateCommonUniforms(entity, camera, shaderProgram) {\n        const gl = this._gl;\n        const uniformLocations = shaderProgram.uniformLocations;\n        // We're using \"matrix\"(=local matrix) here for efficiency\n        // As projection doesn't require world matrix, as it doesn't have any parent or child\n        const matrix = entity.matrix;\n        const mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();\n        gl_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply(mvMatrix, camera.viewMatrix, matrix);\n        gl.uniformMatrix4fv(uniformLocations.uMVMatrix, false, mvMatrix);\n        gl.uniformMatrix4fv(uniformLocations.uPMatrix, false, camera.projectionMatrix);\n    }\n    updateVRUniforms(shaderProgram, mvMatrix, pMatrix, eyeIndex) {\n        const gl = this._gl;\n        const uniformLocations = shaderProgram.uniformLocations;\n        gl.uniformMatrix4fv(uniformLocations.uMVMatrix, false, mvMatrix);\n        gl.uniformMatrix4fv(uniformLocations.uPMatrix, false, pMatrix);\n        if (uniformLocations.uEye) {\n            gl.uniform1f(uniformLocations.uEye, eyeIndex);\n        }\n    }\n    updateUniforms(shaderProgram) {\n        const gl = this._gl;\n        const uniforms = shaderProgram.uniforms;\n        const uniformLocations = shaderProgram.uniformLocations;\n        for(const key in uniforms){\n            const uniform = uniforms[key];\n            const location = uniformLocations[key];\n            if (!uniform) continue;\n            if (uniform.needsUpdate) {\n                uniform.update(gl, location, this._isWebGL2);\n            }\n        }\n    }\n    releaseShaderResources(shaderProgram) {\n        const gl = this._gl;\n        const uniforms = shaderProgram.uniforms;\n        for(const key in uniforms){\n            const uniform = uniforms[key];\n            if (!uniform) continue;\n            if (uniform.needsUpdate) {\n                uniform.destroy(gl);\n            }\n        }\n        gl.deleteProgram(shaderProgram.program);\n    }\n    useProgram(shaderProgram) {\n        const gl = this._gl;\n        gl.useProgram(shaderProgram.program);\n    }\n    createProgram(vertexShader, fragmentShader) {\n        const gl = this._gl;\n        const program = gl.createProgram();\n        const vs = this._compileShader(gl.VERTEX_SHADER, vertexShader);\n        const fs = this._compileShader(gl.FRAGMENT_SHADER, fragmentShader);\n        gl.attachShader(program, vs);\n        gl.attachShader(program, fs);\n        gl.bindAttribLocation(program, 0, \"position\");\n        gl.bindAttribLocation(program, 1, \"uv\");\n        gl.linkProgram(program);\n        if (this._debug && !gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            let shaderLog = null;\n            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n                shaderLog = gl.getShaderInfoLog(vs);\n            } else if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n                shaderLog = gl.getShaderInfoLog(fs);\n            }\n            throw new View360Error(ERROR.MESSAGES.FAILED_LINKING_PROGRAM(gl.getProgramInfoLog(program), shaderLog), ERROR.CODES.FAILED_LINKING_PROGRAM);\n        }\n        gl.deleteShader(vs);\n        gl.deleteShader(fs);\n        return program;\n    }\n    createWebGLTexture(texData) {\n        const gl = this._gl;\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texData.wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texData.wrapT);\n        if (!texData.isVideo() && this._isWebGL2) {\n            const gl2 = gl;\n            gl2.texStorage2D(gl2.TEXTURE_2D, 1, gl2.RGBA8, texData.width, texData.height);\n        }\n        return texture;\n    }\n    createWebGLCubeTexture(texData, size) {\n        const gl = this._gl;\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, texData.wrapS);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, texData.wrapT);\n        if (this._isWebGL2) {\n            const gl2 = gl;\n            gl2.texStorage2D(gl2.TEXTURE_CUBE_MAP, 1, gl2.RGBA8, size, size);\n        }\n        return texture;\n    }\n    makeXRCompatible() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const gl = this._gl;\n            const attributes = gl.getContextAttributes();\n            if (attributes && attributes.xrCompatible !== true) {\n                yield gl.makeXRCompatible();\n            }\n        });\n    }\n    bindXRLayer(session) {\n        const gl = this._gl;\n        const xrLayer = new XRWebGLLayer(session, gl);\n        session.updateRenderState({\n            baseLayer: xrLayer\n        });\n    }\n    bindXRFrame(frame) {\n        const gl = this._gl;\n        const session = frame.session;\n        const baseLayer = session.renderState.baseLayer;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, baseLayer.framebuffer);\n    }\n    useDefaultFrameBuffer() {\n        const gl = this._gl;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    }\n    _createBuffer() {\n        return this._gl.createBuffer();\n    }\n    _deleteBuffer(buffer) {\n        return this._gl.deleteBuffer(buffer);\n    }\n    _createNativeVAO() {\n        const gl = this._gl;\n        if (this._isWebGL2) {\n            return gl.createVertexArray();\n        } else {\n            const ext = this._extensions.vao;\n            return (ext === null || ext === void 0 ? void 0 : ext.createVertexArrayOES()) || null;\n        }\n    }\n    _bindNativeVAO(vao) {\n        const gl = this._gl;\n        if (this._isWebGL2) {\n            gl.bindVertexArray(vao);\n        } else {\n            const ext = this._extensions.vao;\n            ext === null || ext === void 0 ? void 0 : ext.bindVertexArrayOES(vao);\n        }\n    }\n    _deleteNativeVAO(vao) {\n        const gl = this._gl;\n        if (this._isWebGL2) {\n            gl.deleteVertexArray(vao);\n        } else {\n            const ext = this._extensions.vao;\n            ext === null || ext === void 0 ? void 0 : ext.deleteVertexArrayOES(vao);\n        }\n    }\n    _supplyGeometryData(vao, shaderProgram) {\n        const geometry = vao.geometry;\n        this._supplyIndiciesData(geometry.indicies, vao.buffers.indicies);\n        this._supplyAttributeData(geometry.vertices, shaderProgram.program, \"position\", vao.buffers.position);\n        this._supplyAttributeData(geometry.uvs, shaderProgram.program, \"uv\", vao.buffers.uv);\n    }\n    _unbindBuffers() {\n        const gl = this._gl;\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n    _supplyIndiciesData(indicies, buffer) {\n        const gl = this._gl;\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicies.data, gl.STATIC_DRAW);\n    }\n    _supplyAttributeData(attribute, program, name, buffer) {\n        const gl = this._gl;\n        const attribLocation = gl.getAttribLocation(program, name);\n        // Attribute not used\n        if (attribLocation < 0) return;\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, attribute.data, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(attribLocation, attribute.itemSize, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(attribLocation);\n    }\n    _compileShader(type, src) {\n        const gl = this._gl;\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        return shader;\n    }\n    _getCommonUniformLocations(program) {\n        const gl = this._gl;\n        return {\n            uMVMatrix: gl.getUniformLocation(program, \"uMVMatrix\"),\n            uPMatrix: gl.getUniformLocation(program, \"uPMatrix\")\n        };\n    }\n    _getContext(canvas) {\n        const webglIdentifiers = [\n            \"webgl2\",\n            \"webgl\",\n            \"experimental-webgl\",\n            \"webkit-3d\",\n            \"moz-webgl\"\n        ];\n        let context = null;\n        let isWebGL2 = false;\n        const contextAttributes = {\n            preserveDrawingBuffer: false,\n            antialias: false\n        };\n        const onWebglContextCreationError = (e)=>e.statusMessage;\n        canvas.addEventListener(EVENTS$1.CONTEXT_CREATE_ERROR, onWebglContextCreationError);\n        for (const identifier of webglIdentifiers){\n            try {\n                context = canvas.getContext(identifier, contextAttributes);\n                isWebGL2 = identifier === \"webgl2\";\n            } catch (t) {} // eslint-disable-line no-empty\n            if (context) {\n                break;\n            }\n        }\n        canvas.removeEventListener(EVENTS$1.CONTEXT_CREATE_ERROR, onWebglContextCreationError);\n        if (!context) {\n            throw new View360Error(ERROR.MESSAGES.WEBGL_NOT_SUPPORTED, ERROR.CODES.WEBGL_NOT_SUPPORTED);\n        }\n        return {\n            gl: context,\n            isWebGL2\n        };\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Projection renderer, based on WebGL\r\n * @ko WebGL 기반의 프로젝션 렌더러\r\n * @since 4.0.0\r\n */ class WebGLRenderer {\n    /**\r\n   * Canvas element\r\n   * @ko 캔버스 엘리먼트\r\n   * @since 4.0.0\r\n   */ get canvas() {\n        return this._canvas;\n    }\n    /**\r\n   * Canvas's width (`devicePixelRatio` is not applied)\r\n   * @ko 캔버스의 보이는 너비 (`devicePixelRatio`가 적용되지 않은)\r\n   * @since 4.0.0\r\n   */ get width() {\n        return this._elementSize.x;\n    }\n    /**\r\n   * Canvas's height (`devicePixelRatio` is not applied)\r\n   * @ko 캔버스의 높이 (`devicePixelRatio`가 적용되지 않은)\r\n   * @since 4.0.0\r\n   */ get height() {\n        return this._elementSize.y;\n    }\n    /**\r\n   * Current `devicePixelRatio` value.\r\n   * @ko 현재 `devicePixelRatio` 값.\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```js\r\n   * cosnt renderingWidth = view360.renderer.width * view360.renderer.pixelRatio;\r\n   * ```\r\n   */ get pixelRatio() {\n        return this._pixelRatio;\n    }\n    /**\r\n   * Width / height ratio (= width / height)\r\n   * @ko 너비 / 높이의 비율 (= width / height)\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```js\r\n   * const aspect = view360.renderer.width / view360.renderer.pixelRatio;\r\n   * assert(aspect === view360.renderer.aspect);\r\n   * ```\r\n   */ get aspect() {\n        return this._elementSize.x / this._elementSize.y;\n    }\n    /**\r\n   * Create new instance\r\n   * @ko 새 인스턴스를 생성합니다.\r\n   * @param canvas - Canvas element {@ko 캔버스 엘리먼트}\r\n   * @param debug - Whether to enable WebGL debugging {@ko WebGL debug 활성화 여부 }\r\n   */ constructor(canvas, debug){\n        this._canvas = canvas;\n        this._elementSize = {\n            x: 0,\n            y: 0\n        };\n        this._pixelRatio = 1;\n        this.ctx = new WebGLContext(canvas, debug);\n    }\n    /**\r\n   * Destroy instance and release all resources.\r\n   * @ko 인스턴스를 제거하고 사용된 리소스를 전부 해제합니다.\r\n   * @since 4.0.0\r\n   */ destroy() {\n        const canvas = this._canvas;\n        this.ctx.destroy();\n        canvas.width = 1;\n        canvas.height = 1;\n    }\n    /**\r\n   * Resize canvas and renew inner size cache.\r\n   * @ko 캔버스의 크기를 재계산해서 내부의 사이즈 캐시값을 갱신합니다.\r\n   * @since 4.0.0\r\n   */ resize() {\n        const canvas = this._canvas;\n        const canvasSize = this._elementSize;\n        const devicePixelRatio = window.devicePixelRatio;\n        canvasSize.x = canvas.clientWidth;\n        canvasSize.y = canvas.clientHeight;\n        canvas.width = canvasSize.x * devicePixelRatio;\n        canvas.height = canvasSize.y * devicePixelRatio;\n        this._pixelRatio = devicePixelRatio;\n        this.ctx.resize();\n    }\n    /**\r\n   * Render projection\r\n   * @ko 프로젝션을 렌더링합니다.\r\n   * @param projection - Projection to render {@ko 렌더링할 프로젝션}\r\n   * @param cameraa - Camera instance {@ko 카메라의 인스턴스}\r\n   * @since 4.0.0\r\n   */ render(mesh, camera) {\n        const ctx = this.ctx;\n        if (ctx.lost) return;\n        ctx.clear();\n        ctx.useProgram(mesh.program);\n        ctx.updateCommonUniforms(mesh, camera, mesh.program);\n        mesh.update({\n            camera\n        });\n        ctx.updateUniforms(mesh.program);\n        ctx.draw(mesh.vao, mesh.program);\n    }\n    /**\r\n   * Render VR frame, only used for rendering frames inside VR sessions.\r\n   * @ko VR 프레임을 렌더링합니다. VR 세션 진입 도중에만 사용됩니다.\r\n   * @internal\r\n   * @param mesh - Triangle mesh to render {@ko 렌더링할 메쉬}\r\n   * @param vr - Instance of XRManager {@ko XRManager의 인스턴스}\r\n   * @param frame - VR frame {@ko VR 프레임}\r\n   * @since 4.0.0\r\n   */ renderVR(mesh, vr, frame) {\n        const ctx = this.ctx;\n        const eyeParams = vr.getEyeParams(frame);\n        if (!eyeParams || !mesh) return;\n        ctx.bindXRFrame(frame);\n        ctx.useProgram(mesh.program);\n        ctx.updateUniforms(mesh.program);\n        eyeParams.forEach((eye, eyeIndex)=>{\n            const viewport = eye.viewport;\n            // We're using \"mesh.matrix\"(=local matrix) here for efficiency\n            // As projection doesn't require world matrix, as it doesn't have any parent or child\n            const mvMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.multiply(gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create(), eye.vMatrix, mesh.matrix);\n            ctx.viewport(viewport.x, viewport.y, viewport.width, viewport.height);\n            ctx.updateVRUniforms(mesh.program, mvMatrix, eye.pMatrix, eyeIndex);\n            ctx.draw(mesh.vao, mesh.program);\n        });\n    }\n}\n/**\r\n * Panorama 360 image viewer\r\n * @ko 파노라마 360 이미지 뷰어\r\n * @since 4.0.0\r\n * @see View360Options\r\n * @see View360Events\r\n */ class View360 extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   * Root element (`.view360-container`)\r\n   * @ko 루트 엘리먼트 (`.view360-container`)\r\n   * @since 4.0.0\r\n   * @readonly\r\n   * @example\r\n   * ```html\r\n   * <div id=\"viewer\" class=\"view360-container\">\r\n   *   <canvas class=\"view360-canvas\"></canvas>\r\n   * </div>\r\n   * ```\r\n   * ```ts\r\n   * import View360 from \"@egjs/view360\";\r\n   *\r\n   * const viewer = new View360(\"#viewer\");\r\n   * console.log(viewer.rootEl); // Element with id \"viewer\"\r\n   * ```\r\n   */ get rootEl() {\n        return this._rootEl;\n    }\n    /**\r\n   * Projection renderer.\r\n   * @ko 프로젝션 렌더러.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get renderer() {\n        return this._renderer;\n    }\n    /**\r\n   * Projection camera.\r\n   * @ko 프로젝션 카메라.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get camera() {\n        return this._camera;\n    }\n    /**\r\n   * Rotate/Zoom Controller.\r\n   * @ko 회전/줌 컨트롤러.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get control() {\n        return this._control;\n    }\n    /**\r\n   * WebXR-based VR manager.\r\n   * @ko WebXR 기반의 VR 기능 매니저 인스턴스.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   * @example\r\n   * ```ts\r\n   * // Example: Enter VR\r\n   * // This must be called on user interaction, else will be rejected.\r\n   * viewer.vr.enter();\r\n   * ```\r\n   */ get vr() {\n        return this._vr;\n    }\n    /**\r\n   * Hotspot renderer.\r\n   * You can also change options of {@link View360Options#hotspot} with this.\r\n   * @ko 핫스팟 렌더러 인스턴스.\r\n   * {@link View360Options#hotspot} 옵션 변경도 가능합니다.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get hotspot() {\n        return this._hotspot;\n    }\n    /**\r\n   * An array of plugins added.\r\n   * @ko 추가된 플러그인의 배열\r\n   * @since 4.0.0\r\n   * @readonly\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   plugins: [new ControlBar()]\r\n   * });\r\n   *\r\n   * console.log(viewer.plugins); // [ControlBar]\r\n   *\r\n   * viewer.addPlugins(new LoadingSpinner()) // [ControlBar, LoadingSpinner];\r\n   * ```\r\n   */ get plugins() {\n        return this._plugins;\n    }\n    /**\r\n   * An instance of {@link Projection} that currently enabled. `null` if not initialized yet.\r\n   * You should call {@link View360#load} to change panorama src or projection type.\r\n   * @ko 현재 사용중인 {@link Projection}의 인스턴스. 프로젝션을 활성화하지 않았을 경우 `null`입니다.\r\n   * 파노라마 이미지 소스나 프로젝션 타입을 변경하려면 {@link View360#load}를 호출하면 됩니다.\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360\r\n   * ```\r\n   */ get projection() {\n        return this._projection;\n    }\n    set projection(val) {\n        if (this._initialized && val) {\n            this.load(val);\n        } else {\n            this._projection = val;\n        }\n    }\n    /**\r\n   * An instance of triangle mesh to render.\r\n   * @ko 렌더링할 triangle mesh의 인스턴스\r\n   * @internal\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get mesh() {\n        return this._mesh;\n    }\n    /**\r\n   * A boolean value whether {@link View360#init init()} is called before.\r\n   * @ko {@link View360#init init()}이 호출되었는지 여부를 가리키는 값\r\n   * @since 4.0.0\r\n   * @readonly\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el\", { autoInit: false });\r\n   *\r\n   * console.log(viewer.initialized); // false\r\n   *\r\n   * await viewer.init();\r\n   *\r\n   * console.log(viewer.initialized); // true\r\n   * ```\r\n   */ get initialized() {\n        return this._initialized;\n    }\n    /**\r\n   * Instance of the Autoplay manager.\r\n   * You can also change {@link View360Options#autoplay} options with this.\r\n   * @ko Autoplay 기능의 매니저 인스턴스.\r\n   * 이 인스턴스를 통해 {@link View360Options#autoplay} 옵션을 변경하는 것도 가능합니다.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   * @example\r\n   * ```ts\r\n   * // Disable autoplay\r\n   * viewer.autoplay.disable();\r\n   * ```\r\n   */ get autoplay() {\n        return this._autoplay;\n    }\n    /**\r\n   * When this value is `true` and {@link View360Options#projection} is set, {@link View360#init init()} will be called automatically when instance is created.\r\n   * @ko 이 값이 `true`이고, {@link View360Options#projection}이 설정되었으면, 인스턴스 생성 시점에 자동으로 {@link View360#init init()}을 호출합니다.\r\n   * @default true\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * import View360, { EquirectProjection, EVENTS } from \"@egjs/view360\";\r\n   *\r\n   * // viewer.init() is called on instance creation\r\n   * // But as `init` is asynchronous, you should wait for \"ready\" event if you want to do something after initialization.\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   autoInit: true,\r\n   *   projection: new EquirectProjection({ src: \"SRC_TO_URL\" })\r\n   * });\r\n   *\r\n   * console.log(viewer.initialized); // false, as `init` is asynchronous\r\n   *\r\n   * viewer.once(EVENTS.READY, () => {\r\n   *   console.log(viewer.initialized); // true\r\n   * });\r\n   * ```\r\n   */ get autoInit() {\n        return this._autoInit;\n    }\n    /**\r\n   * When `true`, {@link View360#resize} is called when the canvas size is changed.\r\n   * @ko `true`일 경우, 캔버스의 크기가 변경되었을 때 자동으로 {@link View360#resize}를 호출합니다.\r\n   * @default true\r\n   * @since 4.0.0\r\n   * @see View360#useResizeObserver\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   autoResize: true\r\n   * });\r\n   *\r\n   * // This can trigger `viewer.resize()` if the canvas size was not 400px\r\n   * const canvas = viewer.renderer.canvas;\r\n   * canvas.style.width = \"400px\";\r\n   * ```\r\n   */ get autoResize() {\n        return this._autoResize;\n    }\n    /**\r\n   * CSS selector for canvas element to render panorama image/video.\r\n   * The canvas element should be placed inside the root element. (Dont' have to be direct child)\r\n   * @ko 파노라마 이미지/비디오를 렌더링할 canvas 엘리먼트의 CSS 선택자\r\n   * 캔버스 엘리먼트는 루트 엘리먼트 내부에 있어야합니다. 루트 엘리먼트의 직계 자식 엘리먼트(Direct child element)일 필요는 없습니다.\r\n   * @default \"canvas\"\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```html\r\n   * <div class=\"view360-container\">\r\n   *   <canvas id=\"not_this_one\"></canvas>\r\n   *   <!-- This will be selected -->\r\n   *   <canvas id=\"canvas_to_select\"></canvas>\r\n   * </div>\r\n   * ```\r\n   *\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   canvasSelector: \"#canvas_to_select\"\r\n   * });\r\n   * ```\r\n   */ get canvasSelector() {\n        return this._canvasSelector;\n    }\n    /**\r\n   * When `true`, it will use {@link ResizeObserver} API to detect canvas size change when {@link View360Options#autoResize} is enabled.\r\n   * @ko `true`일 때 {@link View360Options#autoResize}가 활성화되었으면, 사용 가능한 환경에서 {@link ResizeObserver} API를 사용해서 캔버스 크기 변화를 추적합니다.\r\n   * @default true\r\n   * @since 4.0.0\r\n   */ get useResizeObserver() {\n        return this._useResizeObserver;\n    }\n    /**\r\n   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex tabindex} attribute for the canvas element.\r\n   * This is necessary for the keyboard controls.\r\n   * By default, `0` will be assigned. `null` to disable.\r\n   * @ko 캔버스 엘리먼트에 적용할 {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex tabindex} 어트리뷰트의 값.\r\n   * 이 값을 설정해야만 키보드 컨트롤을 사용 가능합니다.\r\n   * 기본값으로 `0`이 설정됩니다. `null`로 지정하면 `tabindex`를 설정하지 않습니다.\r\n   * @see RotateControlOptions#disableKeyboard\r\n   * @default 0\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   tabindex: 5\r\n   * });\r\n   * ```\r\n   *\r\n   * ```html\r\n   * <!-- After init -->\r\n   * <div class=\"view360-container\">\r\n   *   <canvas class=\"view360-canvas\" tabindex=\"5\"></canvas>\r\n   * </div>\r\n   * ```\r\n   */ get tabIndex() {\n        return this._tabIndex;\n    }\n    set tabIndex(val) {\n        const canvas = this._renderer.canvas;\n        this._tabIndex = val;\n        if (val != null) {\n            canvas.tabIndex = val;\n        } else {\n            canvas.removeAttribute(\"tabindex\");\n        }\n    }\n    /**\r\n   * A maximum delta time between frames in seconds.\r\n   * It can prevent camera or control changing too fast when frame being late.\r\n   * @ko 프레임간 시간 차이의 최대값. (초 단위)\r\n   * 퍼포먼스 등의 이유로 프레임 렌더링이 늦어졌을 때, 화면이 갑작스럽게 바뀌는 것을 막아줍니다.\r\n   * @default 1 / 30\r\n   * @since 4.0.0\r\n   */ get maxDeltaTime() {\n        return this._animator.maxDeltaTime;\n    }\n    set maxDeltaTime(val) {\n        this._animator.maxDeltaTime = val;\n    }\n    /**\r\n   * Enable WebGL debugging. Setting this to `true` can decrease performance.\r\n   * This is used internally on developing View360.\r\n   * @ko WebGL 디버깅을 활성화합니다. 이 값을 `true`로 할 경우 성능이 하락할 수 있습니다.\r\n   * 이 옵션은 View360을 개발하기 위해 내부적으로 사용됩니다.\r\n   * @default false\r\n   */ get debug() {\n        return this._debug;\n    }\n    set debug(val) {\n        this._debug = val;\n    }\n    // Camera options\n    /**\r\n   * Initial yaw (y-axis rotation) value for camera. (in degrees, °)\r\n   * As View360 uses right-handed coordinate system internally, camera will rotate counter-clockwise by this value.\r\n   * @ko 카메라의 초기 yaw(y축 회전)값 (도 단위, °)\r\n   * View360은 오른손 좌표계를 사용하기 때문에, 카메라가 해당 값만큼 시계 반대방향으로 회전합니다.\r\n   * @default 0\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   initialYaw: 30\r\n   * });\r\n   *\r\n   * viewer.on(\"ready\", () => {\r\n   *   console.log(viewer.camera.yaw); // 30\r\n   * });\r\n   * ```\r\n   */ get initialYaw() {\n        return this._camera.initialYaw;\n    }\n    set initialYaw(val) {\n        this._camera.initialYaw = val;\n    }\n    /**\r\n   * Initial pitch (x-axis rotation) value for camera. (in degrees, °)\r\n   * As View360 uses right-handed coordinate system internally, positive value will make camera to look upside, while negative value will look down.\r\n   * @ko 카메라의 초기 pitch(x축 회전)값 (도 단위, °)\r\n   * View360은 오른손 좌표계를 사용하기 때문에, 양(+)의 값은 카메라가 위를 보게 하고, 음(-)의 값은 카메라가 아래를 보게 합니다.\r\n   * @default 0\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   initialPitch: 60\r\n   * });\r\n   *\r\n   * viewer.on(\"ready\", () => {\r\n   *   console.log(viewer.camera.pitch); // 60\r\n   * });\r\n   * ```\r\n   */ get initialPitch() {\n        return this._camera.initialPitch;\n    }\n    set initialPitch(val) {\n        this._camera.initialPitch = val;\n    }\n    /**\r\n   * Initial zoom value for camera.\r\n   * Setting this value to `2` will enlarge panorama 200% by width.\r\n   * @ko 카메라의 초기 줌 값.\r\n   * 이 값을 `2`로 설정할 경우 파노라마 이미지를 가로 기준 200%만큼 확대합니다.\r\n   * @default 1\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   initialZoom: 2\r\n   * });\r\n   *\r\n   * viewer.on(\"ready\", () => {\r\n   *   console.log(viewer.camera.zoom); // 2\r\n   * });\r\n   * ```\r\n   */ get initialZoom() {\n        return this._camera.initialZoom;\n    }\n    set initialZoom(val) {\n        this._camera.initialZoom = val;\n    }\n    /**\r\n   * Restrict yaw(y-axis rotation) range. (in degrees, °)\r\n   * @ko yaw(y축 회전) 범위를 제한합니다. (도 단위, °)\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   yawRange: [-30, 30]\r\n   * });\r\n   *\r\n   * viewer.on(\"ready\", () => {\r\n   *   console.log(viewer.camera.yaw); // 0\r\n   *   viewer.camera.lookAt({ yaw: 60  });\r\n   *   console.log(viewer.camera.yaw); // 30\r\n   * });\r\n   * ```\r\n   */ get yawRange() {\n        return this._camera.yawRange;\n    }\n    set yawRange(val) {\n        this._camera.yawRange = val;\n        if (this._projection) this._projection.updateCamera(this._camera);\n    }\n    /**\r\n   * Restrict pitch(x-axis rotation) range. (in degrees, °)\r\n   * @ko pitch(x축 회전) 범위를 제한합니다. (도 단위, °)\r\n   * @default null\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   pitchRange: [-45, 45]\r\n   * });\r\n   *\r\n   * viewer.on(\"ready\", () => {\r\n   *   console.log(viewer.camera.pitch); // 0\r\n   *   viewer.camera.lookAt({ pitch: 60  });\r\n   *   console.log(viewer.camera.pitch); // 45\r\n   * });\r\n   * ```\r\n   */ get pitchRange() {\n        return this._camera.pitchRange;\n    }\n    set pitchRange(val) {\n        this._camera.pitchRange = val;\n        if (this._projection) this._projection.updateCamera(this._camera);\n    }\n    /**\r\n   * Restrict camera zoom range.\r\n   * If `null`, a default zoom range from `0.6` to `10` will be used.\r\n   * @ko 카메라 줌 범위를 제한합니다.\r\n   * `null`일 경우 기본값으로 `0.6`에서 `10`의 범위를 사용합니다.\r\n   * @default null\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * const viewer = new View360(\"#el_id\", {\r\n   *   zoomRange: [0.5, 4]\r\n   * });\r\n   *\r\n   * viewer.on(\"ready\", () => {\r\n   *   console.log(viewer.camera.zoom); // 1\r\n   *   viewer.camera.lookAt({ zoom: 6  });\r\n   *   console.log(viewer.camera.zoom); // 4\r\n   * });\r\n   * ```\r\n   */ get zoomRange() {\n        return this._camera.zoomRange;\n    }\n    set zoomRange(val) {\n        this._camera.zoomRange = val;\n        if (this._projection) this._projection.updateCamera(this._camera);\n    }\n    /**\r\n   * Camera's horizontal FOV(Field of View). (in degrees, °)\r\n   * @ko 카메라의 수평 FOV(Field of View) 값. (도 단위, °)\r\n   * @default 90\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * // Init with fov: 120\r\n   * const viewer = new View360(\"#el_id\", { fov: 120 });\r\n   *\r\n   * // Back to 90\r\n   * viewer.fov = 90;\r\n   * ```\r\n   */ get fov() {\n        return this._camera.fov;\n    }\n    set fov(val) {\n        const camera = this._camera;\n        const control = this._control;\n        camera.fov = val;\n        camera.updateMatrix();\n        control.sync();\n    }\n    // Control options\n    /**\r\n   * A control for camera rotation.\r\n   * You can also change options of {@link View360Options#rotate} with this.\r\n   * @ko 카메라 회전을 담당하는 컨트롤.\r\n   * {@link View360Options#rotate} 옵션 변경도 가능합니다.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get rotate() {\n        return this._control.rotate;\n    }\n    /**\r\n   * A control for camera zoom.\r\n   * You can also change options of {@link View360Options#zoom} with this.\r\n   * @ko 카메라 줌을 담당하는 컨트롤.\r\n   * {@link View360Options#zoom} 옵션 변경도 가능합니다.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get zoom() {\n        return this._control.zoom;\n    }\n    /**\r\n   * A control for camera rotation with gyroscope input.\r\n   * You can also change options of {@link View360Options#gyro} with this.\r\n   * @ko 자이로스코프를 통한 카메라 회전을 담당하는 컨트롤.\r\n   * {@link View360Options#gyro} 옵션 변경도 가능합니다.\r\n   * @since 4.0.0\r\n   * @readonly\r\n   */ get gyro() {\n        return this._control.gyro;\n    }\n    /**\r\n   * Apply CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor cursor} by current state of input when using mouse.\r\n   * If `true`, this will add CSS style to canvas element. It'll apply `cursor: \"grab\"` by default and `cursor: \"grabbing\"` when holding the mouse button.\r\n   * @ko 마우스 사용시 CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor cursor}값을 자동으로 변경할지 여부.\r\n   * `true`일 경우 기본 상태에서 `cursor: \"grab\"`을, 입력 도중에 `cursor: \"grabbing\"`을 캔버스에 적용합니다.\r\n   * @default true\r\n   * @since 4.0.0\r\n   */ get useGrabCursor() {\n        return this._control.useGrabCursor;\n    }\n    set useGrabCursor(val) {\n        this._control.useGrabCursor = val;\n    }\n    /**\r\n   * Disable context menu which pops up on mouse right click.\r\n   * @ko 마우스 우클릭시 표시되는 컨텍스트 메뉴를 비활성화합니다.\r\n   * @default false\r\n   * @since 4.0.0\r\n   */ get disableContextMenu() {\n        return this._control.disableContextMenu;\n    }\n    set disableContextMenu(val) {\n        this._control.disableContextMenu = val;\n    }\n    /**\r\n   * If `true`, enables scroll on mobile(touch) devices on canvas.\r\n   * :::caution\r\n   * When this option is enabled, users must swipe horizontally first then vertically to change view up or down.\r\n   * :::\r\n   * @ko `true`로 설정할 경우, 모바일(터치) 환경의 캔버스 영역 내에서 스크롤을 가능하게 합니다.\r\n   * :::caution\r\n   * 이 값을 활성화할 경우, 사용자가 카메라 뷰를 위/아래로 바꾸기 위해서는 먼저 가로로 스와이프한 이후에 세로로 스와이프해야만 합니다.\r\n   * :::\r\n   * @since 4.0.0\r\n   * @default true\r\n   */ get scrollable() {\n        return this._control.scrollable;\n    }\n    set scrollable(val) {\n        this._control.scrollable = val;\n    }\n    /**\r\n   * If `true`, enables scroll by mouse wheel on canvas.\r\n   * :::caution\r\n   * When this option is enabled, zoom by mouse wheel will be disabled.\r\n   * :::\r\n   * @ko `true`로 설정할 경우, 캔버스 영역 내에서 마우스 휠을 이용한 페이지 스크롤이 가능해집니다.\r\n   * :::caution\r\n   * 이 값을 활성화할 경우, 마우스 휠을 통한 줌이 불가능하게 됩니다.\r\n   * :::\r\n   * @since 4.0.0\r\n   * @default false\r\n   */ get wheelScrollable() {\n        return this._control.wheelScrollable;\n    }\n    set wheelScrollable(val) {\n        this._control.wheelScrollable = val;\n    }\n    /**\r\n   * Create new instance of View360\r\n   * @ko View360의 새로운 인스턴스를 생성합니다\r\n   * @param root - Root element(`.view360-container`) to mount View360\r\n   * Can be either a CSS selector or HTMLElement.\r\n   * {@ko View360을 마운트할 루트 엘리먼트, CSS 셀렉터나 HTMLElement를 지정 가능합니다.}\r\n   * @param options - Options to apply\r\n   * {@ko 적용할 옵션들}\r\n   * @example\r\n   * ```ts\r\n   * import View360, { EquirectProjection } from \"@egjs/view360\";\r\n   *\r\n   * // Create new View360 instance\r\n   * const viewer = new View360(\"#id-of-a-container\", {\r\n   *   projection: new EquirectProjection({\r\n   *     src: \"URL_TO_PANORAMA_IMAGE_OR_VIDEO\",\r\n   *   })\r\n   * });\r\n   * ```\r\n   */ constructor(root, { projection = null, initialYaw = 0, initialPitch = 0, initialZoom = 1, yawRange = null, pitchRange = null, zoomRange = null, fov = 90, useGrabCursor = true, disableContextMenu = false, rotate = true, zoom = true, gyro = false, scrollable = true, wheelScrollable = false, autoplay = false, hotspot = {}, autoInit = true, autoResize = true, canvasSelector = \"canvas\", useResizeObserver = true, on = {}, plugins = [], maxDeltaTime = 1 / 30, tabIndex = 0, debug = false } = {}){\n        super();\n        /**\r\n     * Render a single panorama image/video frame.\r\n     * Rendering is performed automatically on demand, so you usually don't have to call this.\r\n     * Call this when a frame is not renewed after changing options.\r\n     * @ko 파노라마 이미지/비디오의 한 프레임을 렌더링합니다.\r\n     * 프레임 갱신은 보통 필요한 때에만 자동적으로 이루어지기 때문에, 보통은 이 메소드를 호출할 필요는 없습니다.\r\n     * 옵션 변경 이후에도 프레임 갱신이 이루어지지 않는다면, 이 메소드를 호출해주세요.\r\n     * @param delta Delta time in milisec. {@ko 프레임간 시간 차이, 밀리초 단위}\r\n     * @since 4.0.0\r\n     */ this.renderFrame = (delta)=>{\n            const camera = this._camera;\n            const renderer = this._renderer;\n            const control = this._control;\n            const hotspot = this._hotspot;\n            const autoPlayer = this._autoplay;\n            const mesh = this._mesh;\n            if (!mesh) return;\n            this._emit(EVENTS.BEFORE_RENDER);\n            if (autoPlayer.playing) {\n                autoPlayer.update(delta);\n                control.sync();\n            }\n            if (camera.animation) {\n                camera.animation.update(delta);\n            } else {\n                control.update(delta);\n            }\n            renderer.render(mesh, camera);\n            hotspot.render(camera);\n            if (camera.changed) {\n                this._emit(EVENTS.VIEW_CHANGE, {\n                    yaw: camera.yaw,\n                    pitch: camera.pitch,\n                    zoom: camera.zoom,\n                    quaternion: [\n                        camera.quaternion[0],\n                        camera.quaternion[1],\n                        camera.quaternion[2],\n                        camera.quaternion[3]\n                    ]\n                });\n            }\n            camera.onFrameRender();\n            this._emit(EVENTS.RENDER);\n        };\n        this._renderFrameOnDemand = (delta)=>{\n            const camera = this._camera;\n            const control = this._control;\n            const autoplay = this._autoplay;\n            const mesh = this._mesh;\n            const texture = mesh === null || mesh === void 0 ? void 0 : mesh.getTexture();\n            if (!this._initialized || !texture) return;\n            if (!camera.animation && !control.animating && !autoplay.playing && !texture.isVideo()) return;\n            this.renderFrame(delta);\n        };\n        this._renderVRFrame = (_delta, frame)=>{\n            const vr = this._vr;\n            const mesh = this._mesh;\n            const renderer = this._renderer;\n            if (!mesh) return;\n            this._emit(EVENTS.BEFORE_RENDER);\n            renderer.renderVR(mesh, vr, frame);\n            this._emit(EVENTS.RENDER);\n        };\n        this._rootEl = getElement(root);\n        this._plugins = plugins;\n        this._initialized = false;\n        // Options\n        this._autoInit = autoInit;\n        this._autoResize = autoResize;\n        this._canvasSelector = canvasSelector;\n        this._useResizeObserver = useResizeObserver;\n        this._tabIndex = tabIndex;\n        this._debug = debug;\n        // Core components\n        const canvas = findCanvas(this._rootEl, canvasSelector);\n        this._renderer = new WebGLRenderer(canvas, debug);\n        this._camera = new Camera({\n            initialYaw,\n            initialPitch,\n            initialZoom,\n            fov,\n            yawRange,\n            pitchRange,\n            zoomRange\n        });\n        this._control = new PanoControl(canvas, this._camera, {\n            useGrabCursor,\n            scrollable,\n            wheelScrollable,\n            disableContextMenu,\n            rotate,\n            zoom,\n            gyro\n        });\n        this._animator = new FrameAnimator(maxDeltaTime);\n        this._autoplay = new Autoplay(this, canvas, autoplay);\n        this._projection = projection;\n        this._mesh = null;\n        this._autoResizer = new AutoResizer(useResizeObserver, ()=>this.resize());\n        this._vr = new XRManager(this._renderer.ctx);\n        this._hotspot = new HotspotRenderer(this._rootEl, this._renderer, hotspot);\n        this._addEventHandlers(on);\n        if (projection && autoInit) {\n            this.init();\n        }\n    }\n    /**\r\n   * Destroy instance and release all resources.\r\n   * @ko 인스턴스를 제거하고 모든 리소스를 해제합니다.\r\n   * @since 4.0.0\r\n   */ destroy() {\n        this._camera.destroy();\n        this._animator.stop();\n        this._renderer.destroy();\n        this._control.destroy();\n        this._autoResizer.disable();\n        if (this._mesh) {\n            this._mesh.destroy(this._renderer.ctx);\n            this._mesh = null;\n        }\n        this._plugins.forEach((plugin)=>plugin.destroy(this));\n        this._initialized = false;\n    }\n    /**\r\n   * Initialize inner components and load projection src.\r\n   * @ko 내부 컴포넌트들을 초기화하고 프로젝션 소스를 로드합니다.\r\n   * @since 4.0.0\r\n   */ init() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._projection) {\n                throw new View360Error(ERROR.MESSAGES.PROVIDE_PROJECTION_FIRST, ERROR.CODES.PROVIDE_PROJECTION_FIRST);\n            }\n            const renderer = this._renderer;\n            const camera = this._camera;\n            const control = this._control;\n            const animator = this._animator;\n            const hotspot = this._hotspot;\n            const projection = this._projection;\n            const canvas = renderer.canvas;\n            this._bindComponentEvents();\n            renderer.ctx.init();\n            this._resizeComponents();\n            camera.updateMatrix();\n            if (this._autoResize) {\n                this._autoResizer.enable(canvas);\n            }\n            if (!this._autoplay.enableBlocked) {\n                this._autoplay.enable();\n            }\n            this._plugins.forEach((plugin)=>{\n                plugin.init(this);\n            });\n            const texture = yield this._loadTexture(projection);\n            this._applyProjection(projection, texture);\n            hotspot.refresh();\n            animator.start(this._renderFrameOnDemand);\n            yield control.enable();\n            if (this._tabIndex != null && !canvas.hasAttribute(\"tabIndex\")) {\n                canvas.tabIndex = this._tabIndex;\n            }\n            this._initialized = true;\n            this.renderFrame(0);\n            this._emit(EVENTS.READY);\n        });\n    }\n    /**\r\n   * Load new panorama image/video and display it.\r\n   * This will {@link View360#init init()} View360 if it's not initialized yet.\r\n   * @ko 새로운 파노라마 이미지 혹은 비디오를 로드하고 표시합니다.\r\n   * 만약 View360이 아직 초기화되지 않았다면, {@link View360#init init()}을 호출합니다.\r\n   * @param projection - Projection & video options for new source. {@ko 새로운 파노라마 이미지/비디오에 적용할 옵션들}\r\n   * @returns `Promise<true>` if load was successful. {@ko 프로젝션 로드에 성공했을 경우 `Promise<true>`를 반환합니다. }\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * // Change to video\r\n   * viewer.load({\r\n   *   src: \"URL_TO_NEW_VIDEO\",\r\n   *   video: true\r\n   * });\r\n   * ```\r\n   */ load(projection) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!projection) return false;\n            if (this._initialized) {\n                const texture = yield this._loadTexture(projection);\n                this._applyProjection(projection, texture);\n                this.renderFrame(0);\n            } else {\n                // Should update internal options before init\n                this._projection = projection;\n                this.init();\n            }\n            return true;\n        });\n    }\n    /**\r\n   * Refresh component's size by current\r\n   * @ko View360이 내부적으로 캐시하고 있는 엘리먼트 크기를 현재 크기로 갱신합니다.\r\n   * @since 4.0.0\r\n   */ resize() {\n        if (!this._initialized) return;\n        this._resizeComponents();\n        // To prevent flickering, render immediately after resizing components\n        this.renderFrame(0);\n        const { width, height } = this._renderer;\n        this._emit(EVENTS.RESIZE, {\n            width,\n            height\n        });\n    }\n    /**\r\n   * Add new plugins\r\n   * @ko 새로운 플러그인을 추가합니다.\r\n   * @param plugins Plugins to add {@ko 추가할 플러그인들}\r\n   * @see View360Options#plugins\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * // Add a single plugin\r\n   * viewer.addPlugins(new ControlBar());\r\n   *\r\n   * // Add multiple plugins\r\n   * viewer.addPlugins(new ControlBar(), new LoadingSpinner());\r\n   * ```\r\n   */ addPlugins(...plugins) {\n        if (this._initialized) {\n            plugins.forEach((plugin)=>{\n                plugin.init(this);\n            });\n        }\n        this._plugins.push(...plugins);\n    }\n    /**\r\n   * Remove plugins.\r\n   * @ko 플러그인을 제거합니다.\r\n   * @param plugins Plugins to remove {@ko 제거할 플러그인들}\r\n   * @since 4.0.0\r\n   * @example\r\n   * ```ts\r\n   * // Remove a single plugin\r\n   * viewer.removePlugins(plugin1);\r\n   *\r\n   * // Remove multiple plugins\r\n   * viewer.removePlugins(plugin2, plugin3);\r\n   * ```\r\n   */ removePlugins(...plugins) {\n        plugins.forEach((plugin)=>{\n            const pluginIdx = this._plugins.indexOf(plugin);\n            if (pluginIdx < 0) return;\n            plugin.destroy(this);\n            this._plugins.splice(pluginIdx, 1);\n        });\n    }\n    _emit(eventName, ...params) {\n        const evtParams = params ? params[0] : {};\n        this.trigger(eventName, Object.assign({\n            type: eventName,\n            target: this\n        }, evtParams));\n    }\n    _applyProjection(projection, texture) {\n        const camera = this._camera;\n        const control = this._control;\n        const renderer = this._renderer;\n        const mesh = this._mesh;\n        // Remove previous context\n        if (mesh) {\n            mesh.destroy(renderer.ctx);\n        }\n        const newMesh = projection.createMesh(renderer.ctx, texture);\n        projection.updateCamera(camera);\n        projection.updateControl(control);\n        this._mesh = newMesh;\n        this._emit(EVENTS.PROJECTION_CHANGE, {\n            projection\n        });\n    }\n    _loadTexture(projection) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const contentLoader = new TextureLoader();\n            const { src, video } = projection;\n            this._emit(EVENTS.LOAD_START, {\n                src,\n                video\n            });\n            const texture = yield contentLoader.load(src, video);\n            this._emit(EVENTS.LOAD, {\n                src,\n                video\n            });\n            return texture;\n        });\n    }\n    _resizeComponents() {\n        const renderer = this._renderer;\n        const camera = this._camera;\n        const control = this._control;\n        renderer.resize();\n        camera.resize(renderer.width, renderer.height);\n        control.resize(renderer.width, renderer.height);\n    }\n    _addEventHandlers(events) {\n        // Bind option \"on\"\n        Object.keys(events).forEach((evtName)=>{\n            this.on(evtName, events[evtName]);\n        });\n    }\n    _bindComponentEvents() {\n        // Bind internal component events\n        const root = this._rootEl;\n        const control = this._control;\n        const animator = this._animator;\n        const renderer = this._renderer;\n        const vr = this._vr;\n        const controlEventsToPropagate = [\n            CONTROL_EVENTS.STATIC_CLICK,\n            CONTROL_EVENTS.INPUT_START,\n            CONTROL_EVENTS.INPUT_END\n        ];\n        controlEventsToPropagate.forEach((evtName)=>{\n            control.rotate.on(evtName, (evt)=>{\n                this._emit(evtName, evt);\n            });\n            control.zoom.on(evtName, (evt)=>{\n                this._emit(evtName, evt);\n            });\n        });\n        vr.on(EVENTS.VR_START, (evt)=>{\n            root.classList.add(DEFAULT_CLASS.IN_VR);\n            animator.changeContext(evt.session);\n            animator.start(this._renderVRFrame);\n            this._emit(EVENTS.VR_START);\n        });\n        vr.on(EVENTS.VR_END, ()=>{\n            root.classList.remove(DEFAULT_CLASS.IN_VR);\n            renderer.ctx.useDefaultFrameBuffer();\n            animator.changeContext(window);\n            animator.start(this._renderFrameOnDemand);\n            this.resize();\n            this._emit(EVENTS.VR_END);\n        });\n    }\n}\n/**\r\n * Current version string of the View360\r\n * @ko View360의 현재 버젼 문자열\r\n * @since 4.0.0\r\n * @readonly\r\n * @example\r\n * ```ts\r\n * // If the installed version of the View360 is v4.0.0, View360.VERSION is equal to \"4.0.0\"\r\n * console.log(View360.VERSION) // 4.0.0\r\n * ```\r\n */ View360.VERSION = \"4.0.0-beta.7\";\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Base class for 3D objects\r\n * @ko 3D 오브젝트의 베이스 클래스\r\n * @since 4.0.0\r\n * @internal\r\n */ class Object3D extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   * Create new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   */ constructor(){\n        super();\n        this.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_3__.create();\n        this.rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n        this.position = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(0, 0, 0);\n        this.scale = gl_matrix__WEBPACK_IMPORTED_MODULE_2__.fromValues(1, 1, 1);\n    }\n    /**\r\n   * Update local matrix of the object.\r\n   * @ko 오브젝트의 local matrix를 갱신합니다.\r\n   * @since 4.0.0\r\n   */ updateMatrix() {\n        gl_matrix__WEBPACK_IMPORTED_MODULE_3__.fromRotationTranslationScale(this.matrix, this.rotation, this.position, this.scale);\n    }\n    update(ctx) {\n        this.trigger(OBJECT_3D_EVENTS.UPDATE, ctx);\n    }\n}\n/**\r\n * A plugin that displays loading spinner while loading the projection.\r\n * @ko 프로젝션 로딩중에 로딩 스피너를 보여주는 플러그인\r\n * @since 4.0.0\r\n * @category Plugin\r\n */ class LoadingSpinner {\n    /**\r\n   * Create a new instance of LoadingSpinner. {@ko LoadingSpinner의 새 인스턴스를 생성합니다.}\r\n   * @param options Options {@ko 옵션들}\r\n   */ constructor({ className = {} } = {}){\n        this._startLoading = ({ target: viewer })=>{\n            viewer.rootEl.appendChild(this._container);\n            if (viewer.initialized) {\n                viewer.once(EVENTS.LOAD, this._detachElements);\n            } else {\n                viewer.once(EVENTS.READY, this._detachElements);\n            }\n        };\n        this._detachElements = ({ target: viewer })=>{\n            const container = this._container;\n            if (!container) return;\n            if (container.parentElement === viewer.rootEl) {\n                viewer.rootEl.removeChild(container);\n            }\n        };\n        this.className = className;\n        this._container = this._createElements();\n    }\n    init(viewer) {\n        viewer.on(EVENTS.LOAD_START, this._startLoading);\n    }\n    destroy(viewer) {\n        viewer.off(EVENTS.LOAD_START, this._startLoading);\n        this._detachElements({\n            target: viewer\n        });\n    }\n    _createElements() {\n        const className = Object.assign(Object.assign({}, this.className), LoadingSpinner.DEFAULT_CLASS);\n        const container = createElement(className.CONTAINER);\n        const ring = createElement(className.RING);\n        container.appendChild(ring);\n        return container;\n    }\n}\n/**\r\n * Default class names that LoadingSpinner uses\r\n * @ko LoadingSpinner가 사용하는 디폴트 클래스 이름\r\n * @since 4.0.0\r\n */ LoadingSpinner.DEFAULT_CLASS = {\n    /**\r\n   * A class name for the container element\r\n   * @ko 컨테이너 엘리먼트의 클래스 이름\r\n   * @since 4.0.0\r\n   */ CONTAINER: \"view360-spinner\",\n    /**\r\n   * A class name for the spinning ring element\r\n   * @ko 돌아가는 링 엘리먼트의 클래스 이름\r\n   * @since 4.0.0\r\n   */ RING: \"view360-spinner-ring\"\n};\n/**\r\n * Interface of the ControlBar items\r\n * @ko 컨트롤바 아이템의 인터페이스\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class ControlBarItem {\n    /**\r\n   * Create new instance of the ControlBarItem\r\n   * @ko ControlBarItem의 새로운 인스턴스를 생성합니다.\r\n   * @param options Options {@ko 옵션들}\r\n   */ constructor(options){\n        this.position = options.position;\n        this.order = options.order;\n    }\n}\nconst CONTROL_BAR_DEFAULT_CLASS = {\n    CONTROLS_ROOT: \"view360-controls\",\n    CONTROLS_BG: \"view360-controls-background\",\n    CONTROLS_MAIN: \"view360-controls-main\",\n    CONTROLS_TOP: \"view360-controls-top\",\n    CONTROLS_BOTTOM: \"view360-controls-bottom\",\n    CONTROLS_MID: \"view360-controls-mid\",\n    CONTROLS_LEFT: \"view360-controls-left\",\n    CONTROLS_RIGHT: \"view360-controls-right\",\n    CONTROLS_FLOAT_LEFT: \"view360-controls-float-left\",\n    CONTROLS_FLOAT_RIGHT: \"view360-controls-float-right\",\n    CONTROLS_BUTTON: \"view360-controls-button\",\n    PROGRESS_ROOT: \"view360-controls-progress\",\n    VOLUME_ROOT: \"view360-controls-volume\",\n    RANGE_ROOT: \"view360-range\",\n    RANGE_TRACK: \"view360-range-track\",\n    RANGE_THUMB: \"view360-range-thumb\",\n    RANGE_FILLER: \"view360-range-filler\",\n    PLAY_BUTTON: \"view360-controls-play\",\n    PAUSE_BUTTON: \"view360-controls-pause\",\n    UNMUTED_BUTTON: \"view360-controls-unmuted\",\n    MUTED_BUTTON: \"view360-controls-muted\",\n    FULLSCREEN_BUTTON: \"view360-controls-fullscreen\",\n    FULLSCREEN_EXIT_BUTTON: \"view360-controls-fullscreen-exit\",\n    VR_BUTTON: \"view360-controls-vr\",\n    GYRO_ENABLED: \"view360-controls-gyro-enabled\",\n    GYRO_DISABLED: \"view360-controls-gyro-disabled\",\n    VIDEO_TIME_DISPLAY: \"view360-controls-time\",\n    PIEVIEW_ROOT: \"view360-controls-pie\",\n    FIXED: \"view360-controls-fixed\",\n    UNAVAILABLE: \"view360-controls-unavailable\",\n    HIDDEN: \"view360-controls-hidden\"\n};\nconst CONTROL_BAR_ITEM_POSITION = {\n    /**\r\n   * Place control bar item floating at top-left corner\r\n   * @ko 아이템을 왼쪽 위 구석에 표시합니다.\r\n   * @since 4.0.0\r\n   */ TOP_LEFT: \"top-left\",\n    /**\r\n   * Place control bar item floating at top-right corner\r\n   * @ko 아이템을 오른쪽 위 구석에 표시합니다.\r\n   * @since 4.0.0\r\n   */ TOP_RIGHT: \"top-right\",\n    /**\r\n   * Place control bar item at upper block inside the bottom control bar.\r\n   * @ko 아이템을 하단에 표시되는 컨트롤바 내에서 위쪽 블럭에 표시합니다.\r\n   * @since 4.0.0\r\n   */ MAIN_TOP: \"main-top\",\n    /**\r\n   * Place control bar item at lower block inside the bottom control bar.\r\n   * @ko 아이템을 하단에 표시되는 컨트롤바 내에서 하단 블럭에 표시합니다.\r\n   * @since 4.0.0\r\n   */ MAIN_BOTTOM: \"main-bottom\",\n    /**\r\n   * Place control bar item at center-left block inside the bottom control bar.\r\n   * @ko 아이템을 하단에 표시되는 컨트롤바 내에서 중간 왼쪽 블럭에 표시합니다.\r\n   * @since 4.0.0\r\n   */ MAIN_LEFT: \"main-left\",\n    /**\r\n   * Place control bar item at center-right block inside the bottom control bar.\r\n   * @ko 아이템을 하단에 표시되는 컨트롤바 내에서 중간 오른쪽 블럭에 표시합니다.\r\n   * @since 4.0.0\r\n   */ MAIN_RIGHT: \"main-right\"\n};\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class RangeControl extends _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\r\n   *\r\n   */ constructor(){\n        super();\n        this._onHold = ({ srcEvent, isTouch })=>{\n            var _a;\n            const bbox = this._bbox;\n            if (!bbox) return;\n            const x = isTouch ? srcEvent.touches[0].pageX : srcEvent.pageX;\n            const elX = bbox.x + ((_a = window.scrollX) !== null && _a !== void 0 ? _a : window.pageXOffset);\n            const clamepdX = clamp(x, elX, elX + bbox.width);\n            const progress = (clamepdX - elX) / bbox.width;\n            this._motion.reset(clamepdX);\n            this.thumbEl.classList.add(this._fixedClass);\n            this.trigger(CONTROL_EVENTS.INPUT_START, progress);\n        };\n        this._onChange = ({ delta })=>{\n            var _a;\n            const motion = this._motion;\n            const bbox = this._bbox;\n            if (!bbox) return;\n            motion.setNewEndByDelta(delta.x);\n            motion.update(1);\n            const elX = bbox.x + ((_a = window.scrollX) !== null && _a !== void 0 ? _a : window.pageXOffset);\n            const clampedX = clamp(motion.val, elX, elX + bbox.width);\n            const progress = (clampedX - elX) / bbox.width;\n            this.trigger(CONTROL_EVENTS.CHANGE, progress);\n        };\n        this._onRelease = ()=>{\n            const bbox = this._bbox;\n            if (!bbox) return;\n            this.thumbEl.classList.remove(this._fixedClass);\n            this.trigger(CONTROL_EVENTS.INPUT_END);\n        };\n        const root = document.createElement(EL_DIV);\n        const track = document.createElement(EL_DIV);\n        const thumb = document.createElement(EL_DIV);\n        const filler = document.createElement(EL_DIV);\n        root.draggable = false;\n        track.appendChild(filler);\n        track.appendChild(thumb);\n        root.appendChild(track);\n        this.rootEl = root;\n        this.trackEl = track;\n        this.thumbEl = thumb;\n        this.fillerEl = filler;\n        this._mouseInput = new MouseInput();\n        this._touchInput = new TouchInput();\n        this._motion = new Motion({\n            duration: 1,\n            range: INFINITE_RANGE,\n            easing: (x)=>x\n        });\n        this._bbox = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            top: 0\n        };\n        this._fixedClass = CONTROL_BAR_DEFAULT_CLASS.FIXED;\n    }\n    init(className) {\n        const mouseInput = this._mouseInput;\n        const touchInput = this._touchInput;\n        this.rootEl.classList.add(className.RANGE_ROOT);\n        this.trackEl.classList.add(className.RANGE_TRACK);\n        this.thumbEl.classList.add(className.RANGE_THUMB);\n        this.fillerEl.classList.add(className.RANGE_FILLER);\n        this._fixedClass = className.FIXED;\n        mouseInput.on(CONTROL_EVENTS.INPUT_START, this._onHold);\n        touchInput.on(CONTROL_EVENTS.INPUT_START, this._onHold);\n        mouseInput.on(CONTROL_EVENTS.INPUT_END, this._onRelease);\n        touchInput.on(CONTROL_EVENTS.INPUT_END, this._onRelease);\n        mouseInput.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        touchInput.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        mouseInput.enable(this.rootEl);\n        touchInput.enable(this.rootEl);\n        this.resize();\n    }\n    destroy() {\n        const mouseInput = this._mouseInput;\n        const touchInput = this._touchInput;\n        this.rootEl.className = \"\";\n        this.trackEl.className = \"\";\n        this.thumbEl.className = \"\";\n        this.fillerEl.className = \"\";\n        mouseInput.off();\n        touchInput.off();\n        mouseInput.disable();\n        touchInput.disable();\n    }\n    resize() {\n        this._bbox = this.trackEl.getBoundingClientRect();\n    }\n    updateStyle(progress) {\n        const width = this._bbox.width;\n        const clampedProgress = clamp(progress, 0, 1);\n        this.fillerEl.style.width = `${clampedProgress * 100}%`;\n        this.thumbEl.style.transform = `translateX(${clampedProgress * width}px)`;\n    }\n}\n/**\r\n * Show video progress bar.\r\n * @ko 비디오의 프로그레스 바를 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class ProgressBar extends ControlBarItem {\n    get element() {\n        return this._rangeControl.rootEl;\n    }\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ position = CONTROL_BAR_ITEM_POSITION.MAIN_TOP, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onResize = ()=>{\n            this._rangeControl.resize();\n        };\n        this._onTimeUpdate = ()=>{\n            const video = this._video;\n            if (!video) return;\n            this._currentTime = video.source.currentTime;\n            this._rangeControl.updateStyle(this._currentTime / this._duration);\n        };\n        this._onDurationChange = ()=>{\n            const video = this._video;\n            if (!video) return;\n            this._duration = video.source.duration;\n            this._rangeControl.updateStyle(this._currentTime / this._duration);\n        };\n        this._onHold = (progress)=>{\n            const video = this._video;\n            const controlBar = this._controlBar;\n            if (!video || !controlBar) return;\n            const paused = video.isPaused();\n            video.source.pause();\n            const time = video.source.duration * progress;\n            video.source.currentTime = time;\n            video.source.dispatchEvent(new CustomEvent(VIDEO_TIME_CHANGE_EVENT, {\n                detail: {\n                    time\n                }\n            }));\n            controlBar.rootEl.classList.add(controlBar.className.FIXED);\n            this._wasPaused = !this._playPromise && paused;\n        };\n        this._onControl = (progress)=>{\n            const video = this._video;\n            if (!video) return;\n            const time = video.source.duration * progress;\n            video.source.currentTime = time;\n            video.source.dispatchEvent(new CustomEvent(VIDEO_TIME_CHANGE_EVENT, {\n                detail: {\n                    time\n                }\n            }));\n        };\n        this._onRelease = ()=>{\n            const video = this._video;\n            const controlBar = this._controlBar;\n            if (video && controlBar) {\n                if (!this._wasPaused && !this._playPromise) {\n                    this._playPromise = video.source.play().catch(()=>void 0);\n                    // This should not be chained\n                    this._playPromise.then(()=>{\n                        this._playPromise = null;\n                    });\n                    controlBar.rootEl.classList.remove(controlBar.className.FIXED);\n                }\n            }\n            this._wasPaused = false;\n        };\n        this.position = position;\n        this.order = order;\n        this._controlBar = null;\n        this._rangeControl = new RangeControl();\n        this._video = null;\n        this._wasPaused = false;\n        this._currentTime = 0;\n        this._duration = 0;\n        this._playPromise = null;\n    }\n    init(viewer, controlBar) {\n        var _a;\n        const video = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n        const element = this.element;\n        const rangeControl = this._rangeControl;\n        const unavailableClass = controlBar.className.UNAVAILABLE;\n        if (!video || !video.isVideo()) {\n            element.classList.add(unavailableClass);\n            return;\n        }\n        element.classList.remove(unavailableClass);\n        element.classList.add(controlBar.className.PROGRESS_ROOT);\n        viewer.on(EVENTS.RESIZE, this._onResize);\n        video.source.addEventListener(EVENTS$1.VIDEO_TIME_UPDATE, this._onTimeUpdate);\n        video.source.addEventListener(EVENTS$1.VIDEO_DURATION_CHANGE, this._onDurationChange);\n        video.source.addEventListener(VIDEO_TIME_CHANGE_EVENT, this._onTimeUpdate);\n        rangeControl.init(controlBar.className);\n        rangeControl.on(CONTROL_EVENTS.INPUT_START, this._onHold);\n        rangeControl.on(CONTROL_EVENTS.CHANGE, this._onControl);\n        rangeControl.on(CONTROL_EVENTS.INPUT_END, this._onRelease);\n        this._video = video;\n        this._currentTime = video.source.currentTime;\n        this._duration = video.source.duration;\n        this._controlBar = controlBar;\n        rangeControl.updateStyle(this._currentTime / this._duration);\n    }\n    destroy(viewer) {\n        const video = this._video;\n        viewer.off(EVENTS.RESIZE, this._onResize);\n        if (video) {\n            video.source.removeEventListener(EVENTS$1.VIDEO_TIME_UPDATE, this._onTimeUpdate);\n            video.source.removeEventListener(EVENTS$1.VIDEO_DURATION_CHANGE, this._onDurationChange);\n            video.source.removeEventListener(VIDEO_TIME_CHANGE_EVENT, this._onTimeUpdate);\n        }\n        this._rangeControl.destroy();\n        this._video = null;\n        this._playPromise = null;\n    }\n}\n/**\r\n * Show video play / pause button.\r\n * @ko 비디오 재생 / 일시정지 버튼을 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class PlayButton extends ControlBarItem {\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ position = CONTROL_BAR_ITEM_POSITION.MAIN_LEFT, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onClick = ()=>{\n            const video = this._video;\n            if (!video) return;\n            if (this._paused) {\n                video.source.play();\n            } else {\n                video.source.pause();\n            }\n        };\n        this._onPlay = ()=>{\n            if (!this._controlBar) return;\n            const element = this.element;\n            const className = this._controlBar.className;\n            element.classList.add(className.PAUSE_BUTTON);\n            element.classList.remove(className.PLAY_BUTTON);\n            element.title = \"Pause Video\";\n            this._paused = false;\n        };\n        this._onPause = ()=>{\n            if (!this._controlBar) return;\n            const element = this.element;\n            const className = this._controlBar.className;\n            element.classList.add(className.PLAY_BUTTON);\n            element.classList.remove(className.PAUSE_BUTTON);\n            element.title = \"Play Video\";\n            this._paused = true;\n        };\n        this.element = document.createElement(EL_BUTTON);\n        this._video = null;\n        this._paused = true;\n        this._controlBar = null;\n    }\n    init(viewer, controlBar) {\n        var _a;\n        const element = this.element;\n        const video = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n        const className = controlBar.className;\n        const unavailableClass = className.UNAVAILABLE;\n        if (!video || !video.isVideo()) {\n            element.classList.add(unavailableClass);\n            return;\n        }\n        element.classList.add(className.CONTROLS_BUTTON);\n        element.classList.remove(unavailableClass);\n        const paused = video.isPaused();\n        this._video = video;\n        this._paused = paused;\n        this._controlBar = controlBar;\n        if (paused) {\n            this._onPause();\n        } else {\n            this._onPlay();\n        }\n        element.addEventListener(EVENTS$1.CLICK, this._onClick);\n        video.source.addEventListener(EVENTS$1.VIDEO_PLAY, this._onPlay);\n        video.source.addEventListener(EVENTS$1.VIDEO_PAUSE, this._onPause);\n    }\n    destroy() {\n        const video = this._video;\n        const element = this.element;\n        if (!video) return;\n        element.className = \"\";\n        element.removeEventListener(EVENTS$1.CLICK, this._onClick);\n        video.source.removeEventListener(EVENTS$1.VIDEO_PLAY, this._onPlay);\n        video.source.removeEventListener(EVENTS$1.VIDEO_PAUSE, this._onPause);\n        this._video = null;\n        this._paused = true;\n        this._controlBar = null;\n    }\n}\n/**\r\n * Show video volume control.\r\n * @ko 비디오 볼륨 조절 버튼을 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class VolumeControl extends ControlBarItem {\n    get element() {\n        return this._rootEl;\n    }\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ position = CONTROL_BAR_ITEM_POSITION.MAIN_RIGHT, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onResize = ()=>{\n            this._rangeControl.resize();\n            this._updateDisplay();\n        };\n        this._onClick = ()=>{\n            const video = this._video;\n            if (!video || this._rootEl.disabled) return;\n            video.source.muted = !video.source.muted;\n        };\n        this._onVolumeChange = ()=>{\n            const button = this._buttonEl;\n            const video = this._video;\n            const controlBar = this._controlBar;\n            if (!video || !controlBar) return;\n            const className = controlBar.className;\n            if (video.source.muted || video.source.volume === 0) {\n                button.classList.add(className.MUTED_BUTTON);\n                button.classList.remove(className.UNMUTED_BUTTON);\n            } else {\n                button.classList.add(className.UNMUTED_BUTTON);\n                button.classList.remove(className.MUTED_BUTTON);\n            }\n            this._updateDisplay();\n        };\n        this._onHold = (progress)=>{\n            const video = this._video;\n            const controlBar = this._controlBar;\n            if (!video || !controlBar) return;\n            const className = controlBar.className;\n            video.source.volume = progress;\n            this._rootEl.classList.add(className.FIXED);\n            controlBar.containerEl.classList.add(className.FIXED);\n            this._updateDisplay();\n        };\n        this._onChange = (progress)=>{\n            const video = this._video;\n            if (!video) return;\n            video.source.volume = progress;\n            if (progress > 0) {\n                video.source.muted = false;\n            } else {\n                video.source.muted = true;\n            }\n            this._updateDisplay();\n        };\n        this._onRelease = ()=>{\n            const controlBar = this._controlBar;\n            if (!controlBar) return;\n            const className = controlBar.className;\n            this._rootEl.classList.remove(className.FIXED);\n            controlBar.containerEl.classList.remove(className.FIXED);\n        };\n        this._updateDisplay = ()=>{\n            const video = this._video;\n            const root = this._rootEl;\n            if (!video) return;\n            if (!video.hasAudio()) {\n                root.disabled = true;\n                return;\n            }\n            root.disabled = false;\n            const volume = video.source.muted ? 0 : video.source.volume;\n            this._rangeControl.updateStyle(volume);\n        };\n        this._controlBar = null;\n        this._rangeControl = new RangeControl();\n        this._createElements();\n        this._video = null;\n    }\n    init(viewer, controlBar) {\n        var _a;\n        const video = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n        const root = this._rootEl;\n        const button = this._buttonEl;\n        const rangeControl = this._rangeControl;\n        const className = controlBar.className;\n        const unavailableClass = className.UNAVAILABLE;\n        if (!video || !video.isVideo()) {\n            root.classList.add(unavailableClass);\n            return;\n        }\n        root.classList.remove(unavailableClass);\n        root.classList.add(className.CONTROLS_BUTTON);\n        root.classList.add(className.VOLUME_ROOT);\n        button.classList.add(className.CONTROLS_BUTTON);\n        if (video.source.muted) {\n            button.classList.add(className.MUTED_BUTTON);\n        } else {\n            button.classList.add(className.UNMUTED_BUTTON);\n        }\n        viewer.on(EVENTS.RESIZE, this._onResize);\n        root.addEventListener(EVENTS$1.TRANSITION_END, this._onResize);\n        button.addEventListener(EVENTS$1.CLICK, this._onClick);\n        video.source.addEventListener(EVENTS$1.VIDEO_VOLUME_CHANGE, this._onVolumeChange);\n        video.source.addEventListener(EVENTS$1.VIDEO_LOADED_DATA, this._updateDisplay);\n        video.source.addEventListener(EVENTS$1.VIDEO_CAN_PLAYTHROUGH, this._updateDisplay);\n        rangeControl.init(className);\n        rangeControl.on(CONTROL_EVENTS.INPUT_START, this._onHold);\n        rangeControl.on(CONTROL_EVENTS.CHANGE, this._onChange);\n        rangeControl.on(CONTROL_EVENTS.INPUT_END, this._onRelease);\n        this._controlBar = controlBar;\n        this._video = video;\n        this._updateDisplay();\n    }\n    destroy(viewer) {\n        const video = this._video;\n        const button = this._buttonEl;\n        const root = this._rootEl;\n        root.className = \"\";\n        button.className = \"\";\n        viewer.off(EVENTS.RESIZE, this._onResize);\n        root.removeEventListener(EVENTS$1.TRANSITION_END, this._onResize);\n        button.removeEventListener(EVENTS$1.CLICK, this._onClick);\n        if (video) {\n            video.source.removeEventListener(EVENTS$1.VIDEO_VOLUME_CHANGE, this._onVolumeChange);\n            video.source.removeEventListener(EVENTS$1.VIDEO_LOADED_DATA, this._updateDisplay);\n            video.source.removeEventListener(EVENTS$1.VIDEO_CAN_PLAYTHROUGH, this._updateDisplay);\n        }\n        this._controlBar = null;\n        this._rangeControl.destroy();\n        this._video = null;\n    }\n    _createElements() {\n        const root = document.createElement(EL_BUTTON);\n        const buttonEl = document.createElement(EL_DIV);\n        root.appendChild(this._rangeControl.rootEl);\n        root.appendChild(buttonEl);\n        root.title = \"Toggle Mute\";\n        this._rootEl = root;\n        this._buttonEl = buttonEl;\n    }\n}\n/**\r\n * Show fullscreen enter / exit button.\r\n * @ko 풀스크린 진입 / 해제 버튼을 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class FullscreenButton extends ControlBarItem {\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ position = CONTROL_BAR_ITEM_POSITION.MAIN_RIGHT, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onClick = ()=>{\n            const target = this._targetEl;\n            if (!target) return;\n            if (isFullscreen()) {\n                this._exitFullscreen();\n            } else {\n                this._requestFullscreen(target);\n            }\n        };\n        this._onFullscreenChange = ()=>{\n            const element = this.element;\n            const controlBar = this._controlBar;\n            if (!controlBar) return;\n            const className = controlBar.className;\n            if (isFullscreen()) {\n                element.classList.add(className.FULLSCREEN_EXIT_BUTTON);\n                element.classList.remove(className.FULLSCREEN_BUTTON);\n            } else {\n                element.classList.add(className.FULLSCREEN_BUTTON);\n                element.classList.remove(className.FULLSCREEN_EXIT_BUTTON);\n            }\n        };\n        this.element = document.createElement(EL_BUTTON);\n        this.element.title = \"Toggle Fullscreen\";\n        this._controlBar = null;\n        this._targetEl = null;\n    }\n    init(viewer, controlBar) {\n        const element = this.element;\n        const className = controlBar.className;\n        if (!this._fullscreenAvailable()) {\n            element.classList.add(className.UNAVAILABLE);\n            return;\n        }\n        element.classList.add(className.CONTROLS_BUTTON);\n        element.classList.remove(className.UNAVAILABLE);\n        element.addEventListener(EVENTS$1.CLICK, this._onClick);\n        this._addFullscreenHandlers();\n        if (isFullscreen()) {\n            element.classList.add(className.FULLSCREEN_EXIT_BUTTON);\n        } else {\n            element.classList.add(className.FULLSCREEN_BUTTON);\n        }\n        this._controlBar = controlBar;\n        this._targetEl = viewer.rootEl;\n    }\n    destroy() {\n        const element = this.element;\n        element.className = \"\";\n        element.removeEventListener(EVENTS$1.CLICK, this._onClick);\n        this._removeFullscreenHandlers();\n        this._controlBar = null;\n        this._targetEl = null;\n    }\n    _fullscreenAvailable() {\n        return FULLSCREEN_REQUEST.some((key)=>!!document[key]);\n    }\n    _requestFullscreen(el) {\n        for (const key of FULLSCREEN_REQUEST){\n            const request = el[key];\n            if (request) {\n                request.call(el);\n                return;\n            }\n        }\n    }\n    _exitFullscreen() {\n        for (const key of FULLSCREEN_EXIT){\n            const exit = document[key];\n            if (exit) {\n                exit.call(document);\n                return;\n            }\n        }\n    }\n    _addFullscreenHandlers() {\n        FULLSCREEN_CHANGE.forEach((evtName)=>{\n            document.addEventListener(evtName, this._onFullscreenChange);\n        });\n    }\n    _removeFullscreenHandlers() {\n        FULLSCREEN_CHANGE.forEach((evtName)=>{\n            document.removeEventListener(evtName, this._onFullscreenChange);\n        });\n    }\n}\n/**\r\n * Show video current / total time.\r\n * @ko 비디오의 현재 / 총 재생시간을 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class VideoTime extends ControlBarItem {\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ position = CONTROL_BAR_ITEM_POSITION.MAIN_LEFT, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onTimeUpdate = ()=>{\n            const video = this._video;\n            if (!video) return;\n            this._currentTime = video.source.currentTime;\n            this._updateDisplay();\n        };\n        this._onDurationChange = ()=>{\n            const video = this._video;\n            if (!video) return;\n            this._duration = video.source.duration;\n            this._updateDisplay();\n        };\n        this._onCustomTimeChange = (evt)=>{\n            this._currentTime = evt.detail.time;\n            this._updateDisplay();\n        };\n        this.element = document.createElement(EL_DIV);\n        this._video = null;\n        this._currentTime = 0;\n        this._duration = 0;\n    }\n    init(viewer, controlBar) {\n        var _a;\n        const video = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n        const element = this.element;\n        const className = controlBar.className;\n        if (!video || !video.isVideo()) {\n            element.classList.add(className.UNAVAILABLE);\n            return;\n        }\n        element.classList.add(className.VIDEO_TIME_DISPLAY);\n        element.classList.remove(className.UNAVAILABLE);\n        video.source.addEventListener(EVENTS$1.VIDEO_TIME_UPDATE, this._onTimeUpdate);\n        video.source.addEventListener(EVENTS$1.VIDEO_DURATION_CHANGE, this._onDurationChange);\n        video.source.addEventListener(VIDEO_TIME_CHANGE_EVENT, this._onCustomTimeChange);\n        this._video = video;\n        this._currentTime = video.source.currentTime;\n        this._duration = video.source.duration;\n        this._updateDisplay();\n    }\n    destroy() {\n        const video = this._video;\n        if (!video) return;\n        this.element.className = \"\";\n        video.source.removeEventListener(EVENTS$1.VIDEO_TIME_UPDATE, this._onTimeUpdate);\n        video.source.removeEventListener(EVENTS$1.VIDEO_DURATION_CHANGE, this._onDurationChange);\n        video.source.removeEventListener(VIDEO_TIME_CHANGE_EVENT, this._onCustomTimeChange);\n        this._video = null;\n    }\n    _updateDisplay() {\n        const time = this._currentTime;\n        const timeMinute = Math.floor(time / 60);\n        const timeSeconds = Math.floor(time - timeMinute * 60);\n        const timeSecondsFormatted = timeSeconds < 10 ? `0${timeSeconds}` : timeSeconds;\n        const duration = this._duration;\n        const durationMinute = Math.floor(duration / 60);\n        const durationSeconds = Math.floor(duration - durationMinute * 60);\n        const durationSecondsFormatted = durationSeconds < 10 ? `0${durationSeconds}` : durationSeconds;\n        this.element.innerText = `${timeMinute}:${timeSecondsFormatted} / ${durationMinute}:${durationSecondsFormatted}`;\n    }\n}\n/**\r\n * Show camera direction/fov indicator.\r\n * @ko 카메라가 향하는 방향 및 FOV를 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class PieView extends ControlBarItem {\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ resetCamera = true, position = CONTROL_BAR_ITEM_POSITION.TOP_RIGHT, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onClick = ()=>{\n            const viewer = this._viewer;\n            const resetCamera = this.resetCamera;\n            if (!viewer || !resetCamera) return;\n            const { yaw = viewer.initialYaw, pitch = viewer.initialPitch, zoom = viewer.initialZoom, duration = 500 } = getObjectOption(resetCamera);\n            viewer.camera.animateTo({\n                yaw,\n                pitch,\n                zoom,\n                duration\n            });\n        };\n        this._updatePie = ({ target: viewer })=>{\n            const piePath = this._piePathEl;\n            const rangeCircle = this._rangeCircleEl;\n            const camera = viewer.camera;\n            const fov = camera.getHorizontalFov();\n            const yawRange = camera.getYawRange(camera.zoom);\n            const halfFov = fov * 0.5;\n            const pieRadius = 24 * Math.PI;\n            const pieDeg = pieRadius * fov / 360;\n            const pieOffset = pieRadius * (camera.yaw + halfFov + 90) / 360;\n            piePath.setAttribute(\"stroke-dasharray\", `${pieDeg} ${pieRadius - pieDeg}`);\n            piePath.setAttribute(\"stroke-dashoffset\", `${pieOffset}`);\n            if (isFinite(yawRange.min) && isFinite(yawRange.max)) {\n                const radius = 45 * Math.PI; // 2 * PI * r\n                const min = (circulate(yawRange.min, -180, 180) - halfFov) / 360;\n                const max = (circulate(yawRange.max, -180, 180) + halfFov) / 360;\n                const rangeDiff = radius * Math.abs(max - min);\n                const offset = -radius * (min - 0.25);\n                rangeCircle.setAttribute(\"stroke-dasharray\", `${rangeDiff} ${radius - rangeDiff}`);\n                rangeCircle.setAttribute(\"stroke-dashoffset\", `${offset}`);\n            } else {\n                rangeCircle.setAttribute(\"stroke-dasharray\", \"\");\n                rangeCircle.setAttribute(\"stroke-dashoffset\", \"\");\n            }\n        };\n        this.element = document.createElement(EL_DIV);\n        this.element.title = \"Reset view\";\n        this.resetCamera = resetCamera;\n        this._createPieElements();\n        this._viewer = null;\n    }\n    init(viewer, controlBar) {\n        const element = this.element;\n        if (!viewer.initialized) {\n            viewer.once(EVENTS.READY, this._updatePie);\n        } else {\n            this._updatePie({\n                target: viewer\n            });\n        }\n        const rootClass = controlBar.className.PIEVIEW_ROOT;\n        element.classList.add(rootClass);\n        if (this.resetCamera) {\n            element.addEventListener(EVENTS$1.CLICK, this._onClick);\n        }\n        viewer.on(EVENTS.VIEW_CHANGE, this._updatePie);\n        this._viewer = viewer;\n    }\n    destroy(viewer) {\n        const element = this.element;\n        element.removeEventListener(EVENTS$1.CLICK, this._onClick);\n        element.className = \"\";\n        viewer.off(EVENTS.READY, this._updatePie);\n        viewer.off(EVENTS.VIEW_CHANGE, this._updatePie);\n        this._viewer = null;\n    }\n    _createPieElements() {\n        const root = this.element;\n        const pieSVG = document.createElementNS(SVG_NAMESPACE, \"svg\");\n        pieSVG.setAttribute(\"viewBox\", \"0 0 48 48\");\n        pieSVG.setAttribute(\"width\", \"100%\");\n        pieSVG.setAttribute(\"height\", \"100%\");\n        const piePath = document.createElementNS(SVG_NAMESPACE, \"circle\");\n        piePath.setAttribute(\"stroke\", \"currentColor\");\n        piePath.setAttribute(\"fill\", \"transparent\");\n        piePath.setAttribute(\"cx\", \"24\");\n        piePath.setAttribute(\"cy\", \"24\");\n        piePath.setAttribute(\"r\", \"12\");\n        piePath.setAttribute(\"stroke-width\", \"24\");\n        pieSVG.appendChild(piePath);\n        const rangeCircle = document.createElementNS(SVG_NAMESPACE, \"circle\");\n        rangeCircle.setAttribute(\"stroke\", \"currentColor\");\n        rangeCircle.setAttribute(\"fill\", \"transparent\");\n        rangeCircle.setAttribute(\"cx\", \"24\");\n        rangeCircle.setAttribute(\"cy\", \"24\");\n        rangeCircle.setAttribute(\"r\", \"22.5\");\n        rangeCircle.setAttribute(\"stroke-width\", \"3\");\n        pieSVG.appendChild(rangeCircle);\n        root.appendChild(pieSVG);\n        this._piePathEl = piePath;\n        this._rangeCircleEl = rangeCircle;\n    }\n}\n/**\r\n * Show VR enter button.\r\n * @ko VR 진입 버튼을 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class VRButton extends ControlBarItem {\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ position = CONTROL_BAR_ITEM_POSITION.MAIN_RIGHT, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onClick = ()=>{\n            const viewer = this._viewer;\n            if (!viewer) return;\n            viewer.vr.enter();\n        };\n        this.element = document.createElement(EL_BUTTON);\n        this.element.title = \"Enter VR\";\n        this._viewer = null;\n    }\n    init(viewer, controlBar) {\n        const element = this.element;\n        const className = controlBar.className;\n        element.classList.add(className.UNAVAILABLE);\n        element.classList.add(className.VR_BUTTON);\n        element.classList.add(className.CONTROLS_BUTTON);\n        viewer.vr.isAvailable().then((available)=>{\n            if (available) {\n                element.classList.remove(className.UNAVAILABLE);\n            }\n        });\n        element.addEventListener(EVENTS$1.CLICK, this._onClick);\n        this._viewer = viewer;\n    }\n    destroy() {\n        const element = this.element;\n        element.className = \"\";\n        element.removeEventListener(EVENTS$1.CLICK, this._onClick);\n        this._viewer = null;\n    }\n}\n/**\r\n * Show gyroscope control enable / disable button\r\n * @ko 자이로스코프 컨트롤 활성화 / 비활성화 버튼을 표시합니다.\r\n * @category Plugin\r\n * @group ControlBar\r\n * @since 4.0.0\r\n */ class GyroButton extends ControlBarItem {\n    /**\r\n   * Create a new instance.\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ position = CONTROL_BAR_ITEM_POSITION.MAIN_RIGHT, order = 9999 } = {}){\n        super({\n            position,\n            order\n        });\n        this._onClick = ()=>{\n            const viewer = this._viewer;\n            const controlBar = this._controlBar;\n            if (!viewer || !controlBar) return;\n            const gyroControl = viewer.control.gyro;\n            if (gyroControl.enabled) {\n                gyroControl.disable();\n            } else {\n                GyroControl.requestSensorPermission().then((available)=>{\n                    if (available) {\n                        gyroControl.enable();\n                    } else {\n                        this.element.classList.add(controlBar.className.UNAVAILABLE);\n                    }\n                });\n            }\n        };\n        this._updateStyle = ()=>{\n            const element = this.element;\n            const viewer = this._viewer;\n            const controlBar = this._controlBar;\n            if (!viewer || !controlBar) return;\n            const gyroControl = viewer.control.gyro;\n            const className = controlBar.className;\n            if (gyroControl.enabled) {\n                element.classList.add(className.GYRO_ENABLED);\n                element.classList.remove(className.GYRO_DISABLED);\n            } else {\n                element.classList.add(className.GYRO_DISABLED);\n                element.classList.remove(className.GYRO_ENABLED);\n            }\n        };\n        this.element = document.createElement(EL_DIV);\n        this.element.title = \"Toggle gyroscope control\";\n    }\n    init(viewer, controlBar) {\n        const element = this.element;\n        const className = controlBar.className;\n        element.addEventListener(EVENTS$1.CLICK, this._onClick);\n        element.classList.add(className.CONTROLS_BUTTON);\n        element.classList.add(className.UNAVAILABLE);\n        const enableButton = ()=>{\n            element.classList.remove(className.UNAVAILABLE);\n            viewer.control.gyro.on(CONTROL_EVENTS.ENABLE, this._updateStyle);\n            viewer.control.gyro.on(CONTROL_EVENTS.DISABLE, this._updateStyle);\n        };\n        if (sensorCanBeEnabledIOS()) {\n            enableButton();\n        } else {\n            GyroControl.isAvailable().then((available)=>{\n                if (!available) return;\n                enableButton();\n            });\n        }\n        this._controlBar = controlBar;\n        this._viewer = viewer;\n        this._updateStyle();\n    }\n    destroy(viewer) {\n        const element = this.element;\n        viewer.control.gyro.off(CONTROL_EVENTS.ENABLE, this._updateStyle);\n        viewer.control.gyro.off(CONTROL_EVENTS.DISABLE, this._updateStyle);\n        element.removeEventListener(EVENTS$1.CLICK, this._onClick);\n        element.className = \"\";\n        this._controlBar = null;\n        this._viewer = null;\n    }\n}\nclass AutoHide {\n    get enabled() {\n        return !!this._targetEl;\n    }\n    get hidden() {\n        return this._controlBar.containerEl.classList.contains(this._hiddenClass);\n    }\n    get _hiddenClass() {\n        return this._controlBar.className.HIDDEN;\n    }\n    get _fixedClass() {\n        return this._controlBar.className.FIXED;\n    }\n    constructor(controlBar, { initialDelay = 3000, delay = 0, idleDelay: activationDelay = 3000 }){\n        this._onMouseEnter = ()=>{\n            this._isCursorInside = true;\n            this.show();\n        };\n        this._onMouseLeave = ()=>{\n            this._isCursorInside = false;\n            this._hideAfterDelay();\n        };\n        this._onMouseMove = ()=>{\n            if (!this._isFullscreen) return;\n            this.showTemporaliy();\n        };\n        this._onHold = (evt)=>{\n            this._isGrabbing = true;\n            if (evt.pointerType === \"mouse\") {\n                this._isCursorInside = true;\n            }\n            window.addEventListener(EVENTS$1.MOUSE_UP, this._onRelease);\n            this.show();\n        };\n        this._onRelease = ()=>{\n            this._isGrabbing = false;\n            window.removeEventListener(EVENTS$1.MOUSE_UP, this._onRelease);\n            this._hideAfterDelay();\n        };\n        this._onVideoPlay = ()=>{\n            const root = this._targetEl;\n            if (!root) return;\n            this._controlBar.containerEl.classList.remove(this._fixedClass);\n        };\n        this._onVideoPause = ()=>{\n            const root = this._targetEl;\n            if (!root) return;\n            this._controlBar.containerEl.classList.add(this._fixedClass);\n        };\n        this._onFullscreenChange = ()=>{\n            this._isFullscreen = isFullscreen();\n            if (this._isFullscreen) {\n                this._hideAfterDelay();\n            }\n        };\n        this._controlBar = controlBar;\n        this._initialDelay = initialDelay;\n        this._delay = delay;\n        this._idleDelay = activationDelay;\n        this._timer = -1;\n        this._isCursorInside = false;\n        this._isGrabbing = false;\n        this._isFullscreen = false;\n        this._video = null;\n        this._targetEl = null;\n    }\n    enable(viewer) {\n        var _a;\n        if (this._targetEl) {\n            this.disable(viewer);\n        }\n        const initialDelay = this._initialDelay;\n        const root = viewer.rootEl;\n        this._targetEl = viewer.rootEl;\n        this._timer = window.setTimeout(()=>{\n            this.hide();\n        }, initialDelay);\n        root.addEventListener(EVENTS$1.MOUSE_DOWN, this._onHold);\n        root.addEventListener(EVENTS$1.MOUSE_ENTER, this._onMouseEnter);\n        root.addEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove);\n        root.addEventListener(EVENTS$1.MOUSE_LEAVE, this._onMouseLeave);\n        this._addFullscreenHandlers();\n        const video = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n        if (!video || !video.isVideo()) {\n            return;\n        }\n        if (video.isPaused()) {\n            this._controlBar.containerEl.classList.add(this._fixedClass);\n        }\n        video.source.addEventListener(EVENTS$1.VIDEO_PLAY, this._onVideoPlay);\n        video.source.addEventListener(EVENTS$1.VIDEO_PAUSE, this._onVideoPause);\n        this._video = video;\n    }\n    disable(viewer) {\n        if (!this._targetEl) return;\n        const controlBar = this._controlBar;\n        const root = viewer.rootEl;\n        const video = this._video;\n        root.removeEventListener(EVENTS$1.MOUSE_DOWN, this._onHold);\n        window.removeEventListener(EVENTS$1.MOUSE_UP, this._onRelease);\n        root.removeEventListener(EVENTS$1.MOUSE_ENTER, this._onMouseEnter);\n        root.removeEventListener(EVENTS$1.MOUSE_MOVE, this._onMouseMove);\n        root.removeEventListener(EVENTS$1.MOUSE_LEAVE, this._onMouseLeave);\n        this._removeFullscreenHandlers();\n        window.clearTimeout(this._timer);\n        controlBar.containerEl.classList.remove(this._fixedClass);\n        if (video) {\n            video.source.removeEventListener(EVENTS$1.VIDEO_PLAY, this._onVideoPlay);\n            video.source.removeEventListener(EVENTS$1.VIDEO_PAUSE, this._onVideoPause);\n        }\n        this._isCursorInside = false;\n        this._isGrabbing = false;\n        this._video = null;\n        this._targetEl = null;\n    }\n    show() {\n        this._clearHideTimer();\n        this._controlBar.containerEl.classList.remove(this._hiddenClass);\n    }\n    showTemporaliy() {\n        this.show();\n        this._hideAfterDelay(this._idleDelay);\n    }\n    hide() {\n        this._clearHideTimer();\n        this._controlBar.containerEl.classList.add(this._hiddenClass);\n    }\n    _clearHideTimer() {\n        if (this._timer) {\n            window.clearTimeout(this._timer);\n            this._timer = -1;\n        }\n    }\n    _hideAfterDelay(delay = this._delay) {\n        if (this._isGrabbing || !this._isFullscreen && this._isCursorInside) return;\n        this._clearHideTimer();\n        if (delay <= 0) {\n            this.hide();\n        } else {\n            this._timer = window.setTimeout(()=>{\n                this.hide();\n            }, delay);\n        }\n    }\n    _addFullscreenHandlers() {\n        FULLSCREEN_CHANGE.forEach((evtName)=>{\n            document.addEventListener(evtName, this._onFullscreenChange);\n        });\n    }\n    _removeFullscreenHandlers() {\n        FULLSCREEN_CHANGE.forEach((evtName)=>{\n            document.removeEventListener(evtName, this._onFullscreenChange);\n        });\n    }\n}\nclass VideoControl {\n    constructor(){\n        this._onKeyDown = (event)=>{\n            const video = this._video;\n            if (!video) return;\n            event.preventDefault();\n            event.stopPropagation();\n            const videoEl = video.source;\n            const keyPressed = event.keyCode != null ? DIRECTION_KEY_CODE[event.keyCode] : DIRECTION_KEY_NAME[event.key];\n            switch(keyPressed){\n                case \"LEFT\":\n                case \"RIGHT\":\n                    return this._changeVideoTime(videoEl, keyPressed === \"RIGHT\");\n                case \"UP\":\n                case \"DOWN\":\n                    return this._changeVideoVolume(videoEl, keyPressed === \"UP\");\n            }\n            const spacePressed = event.keyCode === SPACE_KEY_CODE || event.key === SPACE_KEY_NAME;\n            if (spacePressed) {\n                this._toggleVideo(video);\n            }\n        };\n    }\n    enable(root, video) {\n        this._video = video;\n        // capture is needed for resolving conflict with keyboard control\n        root.addEventListener(EVENTS$1.KEY_DOWN, this._onKeyDown, true);\n    }\n    disable(root) {\n        this._video = null;\n        root.removeEventListener(EVENTS$1.KEY_DOWN, this._onKeyDown, true);\n    }\n    _changeVideoTime(video, forward) {\n        const delta = forward ? 5 : -5;\n        video.currentTime += delta;\n        video.dispatchEvent(new CustomEvent(VIDEO_TIME_CHANGE_EVENT, {\n            detail: {\n                time: video.currentTime\n            }\n        }));\n    }\n    _changeVideoVolume(video, increase) {\n        const delta = increase ? 0.1 : -0.1;\n        if (video.muted) {\n            video.volume = clamp(delta, 0, 1);\n        } else {\n            video.volume = clamp(video.volume + delta, 0, 1);\n        }\n        if (video.volume > 0) {\n            video.muted = false;\n        } else {\n            video.muted = true;\n        }\n    }\n    _toggleVideo(video) {\n        if (video.isPaused()) {\n            video.source.play();\n        } else {\n            video.source.pause();\n        }\n    }\n}\n/**\r\n * A plugin that displays extra buttons & controls that controls {@link View360}.\r\n * @ko {@link View360}에 부가적인 버튼과 컨트롤을 추가해주는 플러그인.\r\n * @category Plugin\r\n * @since 4.0.0\r\n */ class ControlBar {\n    /**\r\n   * Root element of the control bar\r\n   * @ko 컨트롤바의 루트 엘리먼트\r\n   * @since 4.0.0\r\n   */ get rootEl() {\n        return this._rootEl;\n    }\n    /**\r\n   * Container element of the control bar\r\n   * @ko 컨트롤바의 컨테이너 엘리먼트\r\n   * @since 4.0.0\r\n   */ get containerEl() {\n        return this._containerEl;\n    }\n    /**\r\n   * Background element of the control bar\r\n   * @ko 컨트롤바의 배경 엘리먼트\r\n   * @since 4.0.0\r\n   */ get backgroundEl() {\n        return this._bgEl;\n    }\n    /**\r\n   * Control bar's default items created by {@link ControlBarOptions}\r\n   * @ko 주어진 {@link ControlBarOptions}에 의해 생성된 디폴트 아이템들\r\n   * @since 4.0.0\r\n   */ get items() {\n        return this._items;\n    }\n    /**\r\n   * Custom control bar items\r\n   * @ko 커스텀 컨트롤바 아이템들을 추가합니다.\r\n   * @since 4.0.0\r\n   */ get customItems() {\n        return this._customItems;\n    }\n    /**\r\n   * Create new instance of ControlBar.\r\n   * @ko ControlBar의 새 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ autoHide, showBackground, clickToPlay = true, keyboardControls = true, progressBar = true, playButton = true, volumeButton = true, fullscreenButton = true, videoTime = true, pieView = true, vrButton = true, gyroButton = true, className = {}, customItems = [] } = {}){\n        var _a;\n        this._onStaticClick = ({ target: viewer, isTouch })=>{\n            var _a;\n            const autoHider = this._autoHider;\n            if (isTouch) {\n                if (!autoHider.enabled) return;\n                if (autoHider.hidden) {\n                    autoHider.showTemporaliy();\n                } else {\n                    autoHider.hide();\n                }\n            } else {\n                if (!this.clickToPlay) return;\n                const video = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n                if (!video || !video.isVideo()) return;\n                if (video.isPaused()) {\n                    video.source.play();\n                } else {\n                    video.source.pause();\n                }\n            }\n        };\n        this._onNewSrcLoad = ({ target: viewer })=>{\n            const items = this._items;\n            this._updateBackground(viewer);\n            this._updateAutoHide(viewer);\n            this._updateKeyboardHandler(viewer);\n            Object.keys(items).forEach((key)=>{\n                const category = items[key];\n                category.forEach((item)=>{\n                    item.destroy(viewer, this);\n                    item.init(viewer, this);\n                });\n            });\n        };\n        this.autoHide = autoHide;\n        this.showBackground = showBackground;\n        this.clickToPlay = clickToPlay;\n        this.keyboardControls = keyboardControls;\n        this.progressBar = progressBar;\n        this.playButton = playButton;\n        this.volumeButton = volumeButton;\n        this.fullscreenButton = fullscreenButton;\n        this.videoTime = videoTime;\n        this.pieView = pieView;\n        this.vrButton = vrButton;\n        this.gyroButton = gyroButton;\n        this.className = Object.assign(Object.assign({}, ControlBar.DEFAULT_CLASS), className);\n        const rootClass = (_a = className.CONTROLS_ROOT) !== null && _a !== void 0 ? _a : ControlBar.DEFAULT_CLASS.CONTROLS_ROOT;\n        this._rootEl = createElement(rootClass);\n        this._createPositionWrappers();\n        this._items = Object.keys(ControlBar.POSITION).reduce((items, key)=>{\n            items[ControlBar.POSITION[key]] = [];\n            return items;\n        }, {});\n        this._customItems = customItems;\n        this._autoHider = new AutoHide(this, getObjectOption(autoHide));\n        this._videoControl = new VideoControl();\n        customItems.forEach((item)=>{\n            this._items[item.position].push(item);\n        });\n    }\n    init(viewer) {\n        const panoRoot = viewer.rootEl;\n        const controlsRoot = this._rootEl;\n        const defaultItems = this._createDefaultItems();\n        this._updateBackground(viewer);\n        this._updateAutoHide(viewer);\n        this._updateKeyboardHandler(viewer);\n        panoRoot.appendChild(controlsRoot);\n        this._addItem(viewer, defaultItems);\n        this._addItem(viewer, this._customItems);\n        viewer.on(EVENTS.PROJECTION_CHANGE, this._onNewSrcLoad);\n        viewer.on(EVENTS.STATIC_CLICK, this._onStaticClick);\n    }\n    destroy(viewer) {\n        // Remove controls root from pano root\n        const panoRoot = viewer.rootEl;\n        const controlsRoot = this._rootEl;\n        const items = this._items;\n        if (controlsRoot.parentElement === panoRoot) {\n            panoRoot.removeChild(controlsRoot);\n        }\n        Object.keys(items).forEach((key)=>{\n            const category = items[key];\n            category.forEach((item)=>{\n                item.destroy(viewer, this);\n            });\n            items[key] = [];\n        });\n        this._clearItemElements();\n        this._autoHider.disable(viewer);\n        this._videoControl.disable(panoRoot);\n        viewer.off(EVENTS.PROJECTION_CHANGE, this._onNewSrcLoad);\n        viewer.off(EVENTS.STATIC_CLICK, this._onStaticClick);\n    }\n    _addItem(viewer, items) {\n        for (const item of items){\n            const category = this._items[item.position];\n            const wrapper = this._wrapperEl[item.position];\n            const nextSiblingIndex = findIndex(category, (sibling)=>sibling.order > item.order);\n            if (nextSiblingIndex >= 0) {\n                const nextSibling = category[nextSiblingIndex].element;\n                category.splice(nextSiblingIndex, 0, item);\n                wrapper.insertBefore(item.element, nextSibling);\n            } else {\n                category.push(item);\n                wrapper.appendChild(item.element);\n            }\n            item.init(viewer, this);\n        }\n    }\n    _createPositionWrappers() {\n        const className = Object.assign(Object.assign({}, ControlBar.DEFAULT_CLASS), this.className);\n        const rootEl = this._rootEl;\n        // BG & FLOATING CONTROLS\n        const backgroundEl = createElement(className.CONTROLS_BG);\n        const floatLeftEl = createElement(className.CONTROLS_FLOAT_LEFT);\n        const floatRightEl = createElement(className.CONTROLS_FLOAT_RIGHT);\n        rootEl.appendChild(floatLeftEl);\n        rootEl.appendChild(floatRightEl);\n        // BOTTOM CONTROLS\n        const container = createElement(className.CONTROLS_MAIN);\n        const topWrapper = createElement(className.CONTROLS_TOP);\n        const bottomWrapper = createElement(className.CONTROLS_BOTTOM);\n        const midWrapper = createElement(className.CONTROLS_MID);\n        const leftControlsWrapper = createElement(className.CONTROLS_LEFT);\n        const rightControlsWrapper = createElement(className.CONTROLS_RIGHT);\n        midWrapper.appendChild(leftControlsWrapper);\n        midWrapper.appendChild(rightControlsWrapper);\n        container.appendChild(backgroundEl);\n        container.appendChild(topWrapper);\n        container.appendChild(midWrapper);\n        container.appendChild(bottomWrapper);\n        rootEl.appendChild(container);\n        this._bgEl = backgroundEl;\n        this._containerEl = container;\n        this._wrapperEl = {\n            [ControlBar.POSITION.MAIN_TOP]: topWrapper,\n            [ControlBar.POSITION.MAIN_LEFT]: leftControlsWrapper,\n            [ControlBar.POSITION.MAIN_RIGHT]: rightControlsWrapper,\n            [ControlBar.POSITION.MAIN_BOTTOM]: bottomWrapper,\n            [ControlBar.POSITION.TOP_LEFT]: floatLeftEl,\n            [ControlBar.POSITION.TOP_RIGHT]: floatRightEl\n        };\n    }\n    _clearItemElements() {\n        const wrappers = Object.keys(ControlBar.POSITION).map((key)=>ControlBar.POSITION[key]).map((pos)=>this._wrapperEl[pos]);\n        // Remove all elements inside wrappers\n        wrappers.forEach((wrapper)=>{\n            while(wrapper.firstChild){\n                wrapper.removeChild(wrapper.firstChild);\n            }\n        });\n    }\n    _updateAutoHide(viewer) {\n        var _a;\n        const autoHide = this.autoHide;\n        const autoHider = this._autoHider;\n        if (autoHide != null) {\n            if (autoHide) {\n                autoHider.enable(viewer);\n            } else {\n                autoHider.disable(viewer);\n            }\n        } else {\n            // Automatically choose whether to show background by content type\n            const texture = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n            if (texture && texture.isVideo()) {\n                // Enable auto hide when content type is video\n                autoHider.enable(viewer);\n            } else {\n                autoHider.disable(viewer);\n            }\n        }\n    }\n    _updateBackground(viewer) {\n        var _a, _b;\n        const background = this._bgEl;\n        const showBackground = this.showBackground;\n        const hiddenClass = (_a = this.className.HIDDEN) !== null && _a !== void 0 ? _a : ControlBar.DEFAULT_CLASS.HIDDEN;\n        if (showBackground != null) {\n            if (showBackground) {\n                background.classList.remove(hiddenClass);\n            } else {\n                background.classList.add(hiddenClass);\n            }\n        } else {\n            // Automatically choose whether to show background by content type\n            const texture = (_b = viewer.mesh) === null || _b === void 0 ? void 0 : _b.getTexture();\n            if (texture && texture.isVideo()) {\n                // Show bg when content type is video\n                background.classList.remove(hiddenClass);\n            } else {\n                background.classList.add(hiddenClass);\n            }\n        }\n    }\n    _updateKeyboardHandler(viewer) {\n        var _a;\n        const panoRoot = viewer.rootEl;\n        const videoControl = this._videoControl;\n        const texture = (_a = viewer.mesh) === null || _a === void 0 ? void 0 : _a.getTexture();\n        if (this.keyboardControls && texture && texture.isVideo()) {\n            videoControl.enable(panoRoot, texture);\n        } else {\n            videoControl.disable(panoRoot);\n        }\n    }\n    _createDefaultItems() {\n        const items = [];\n        if (this.progressBar) {\n            items.push(new ProgressBar(getObjectOption(this.progressBar)));\n        }\n        if (this.playButton) {\n            items.push(new PlayButton(getObjectOption(this.playButton)));\n        }\n        if (this.volumeButton) {\n            items.push(new VolumeControl(getObjectOption(this.volumeButton)));\n        }\n        if (this.gyroButton) {\n            items.push(new GyroButton(getObjectOption(this.gyroButton)));\n        }\n        if (this.vrButton) {\n            items.push(new VRButton(getObjectOption(this.vrButton)));\n        }\n        if (this.fullscreenButton) {\n            items.push(new FullscreenButton(getObjectOption(this.fullscreenButton)));\n        }\n        if (this.videoTime) {\n            items.push(new VideoTime(getObjectOption(this.videoTime)));\n        }\n        if (this.pieView) {\n            items.push(new PieView(getObjectOption(this.pieView)));\n        }\n        return items;\n    }\n}\n/**\r\n * Default class names that ControlBar uses\r\n * @ko ControlBar가 사용하는 디폴트 클래스 이름들\r\n * @since 4.0.0\r\n */ ControlBar.DEFAULT_CLASS = CONTROL_BAR_DEFAULT_CLASS;\n/**\r\n * Constants for {@link ControlBarItemOptions#position}\r\n * @ko {@link ControlBarItemOptions#position}에 사용 가능한 값들\r\n */ ControlBar.POSITION = CONTROL_BAR_ITEM_POSITION;\n/**\r\n * Base class for projections.\r\n * @ko 프로젝션 베이스 클래스.\r\n * @category Projection\r\n * @since 4.0.0\r\n */ class Projection {\n    /**\r\n   * Create new instance\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor({ src, video = false }){\n        this.src = src;\n        this.video = video;\n    }\n    /**\r\n   * Update camera to match projection's settings.\r\n   * @ko 현재 프로젝션의 세팅으로 카메라를 업데이트합니다.\r\n   * @param camera - Instance of the camera to update {@ko 업데이트할 카메라의 인스턴스}\r\n   * @since 4.0.0\r\n   */ updateCamera(camera) {\n        // Use default mode & no view restriction\n        camera.resetRange();\n    }\n    /**\r\n   * Update control to match projection's settings.\r\n   * @ko 현재 프로젝션의 세팅으로 컨트롤을 업데이트합니다.\r\n   * @param control - Instance of the control to update {@ko 업데이트할 컨트롤의 인스턴스}\r\n   * @since 4.0.0\r\n   */ updateControl(control) {\n        control.ignoreZoomScale = false;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class Uniform {\n    constructor(){\n        this.needsUpdate = true;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    destroy(gl) {\n    // DO_NOTHING\n    }\n}\nclass UniformTextureCube extends Uniform {\n    constructor(ctx, texture, cubemapOrder){\n        super();\n        this.texture = texture;\n        this._webglTexture = ctx.createWebGLCubeTexture(texture, texture.width);\n        this._cubemapOrder = cubemapOrder;\n    }\n    destroy(gl) {\n        this.texture.destroy();\n        gl.deleteTexture(this._webglTexture);\n    }\n    update(gl, location, isWebGL2) {\n        const texture = this.texture;\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n        gl.uniform1i(location, 0);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._webglTexture);\n        const sources = reorderCube(texture.sources, this._cubemapOrder);\n        sources.forEach((src, idx)=>{\n            if (isWebGL2) {\n                gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + idx, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, src);\n            } else {\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + idx, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);\n            }\n        });\n        if (!texture.isVideo()) {\n            this.needsUpdate = false;\n        }\n    }\n}\n/** @hidden */ class CubeTexturePainter {\n    get size() {\n        return this._size;\n    }\n    constructor(texture, cubemapOrder){\n        this.texture = texture;\n        this._renderingOrder = reorderCube(range(6), cubemapOrder);\n        const canvas = document.createElement(\"canvas\");\n        this._calcRenderingSize();\n        canvas.width = this._size;\n        canvas.height = this._size;\n        this._canvas = canvas;\n        this._ctx = canvas.getContext(\"2d\");\n    }\n    destroy() {\n        const canvas = this._canvas;\n        // release memories\n        canvas.width = 1;\n        canvas.height = 1;\n        this._canvas = null;\n    }\n    draw(gl, isWebGL2) {\n        const size = this._size;\n        const texture = this.texture;\n        let surfaceIdx = 0;\n        for(let row = 0; row < this._row; row++){\n            for(let column = 0; column < this._column; column++){\n                const x = size * column;\n                const y = size * row;\n                const renderingFace = this._renderingOrder[surfaceIdx];\n                this._ctx.drawImage(texture.source, x, y, size, size, 0, 0, size, size);\n                if (isWebGL2) {\n                    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderingFace, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this._canvas);\n                } else {\n                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderingFace, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._canvas);\n                }\n                surfaceIdx++;\n            }\n        }\n    }\n    _calcRenderingSize() {\n        const { width, height } = this.texture;\n        const aspect = width / height;\n        if (aspect === 1 / 6) {\n            this._size = width;\n            this._row = 6;\n            this._column = 1;\n        } else if (aspect === 6) {\n            this._size = height;\n            this._row = 1;\n            this._column = 6;\n        } else if (aspect === 2 / 3) {\n            this._size = width * 0.5;\n            this._row = 3;\n            this._column = 2;\n        } else {\n            this._size = width / 3;\n            this._row = 2;\n            this._column = 3;\n        }\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class UniformCanvasCube extends Uniform {\n    get texture() {\n        return this._painter.texture;\n    }\n    constructor(ctx, texture, cubemapOrder){\n        super();\n        this._painter = new CubeTexturePainter(texture, cubemapOrder);\n        this._webglTexture = ctx.createWebGLCubeTexture(texture, this._painter.size);\n    }\n    destroy(gl) {\n        gl.deleteTexture(this._webglTexture);\n        this._painter.destroy();\n    }\n    update(gl, location, isWebGL2) {\n        const texture = this.texture;\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n        gl.uniform1i(location, 0);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._webglTexture);\n        this._painter.draw(gl, isWebGL2);\n        if (!texture.isVideo()) {\n            this.needsUpdate = false;\n        }\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class TriangleMesh extends Object3D {\n    constructor(vao, program){\n        super();\n        this.vao = vao;\n        this.program = program;\n    }\n    destroy(ctx) {\n        ctx.releaseVAO(this.vao);\n        ctx.releaseShaderResources(this.program);\n    }\n    getTexture() {\n        return this.program.uniforms.uTexture.texture;\n    }\n}\nclass ShaderProgram {\n    constructor(ctx, vertexShader, fragmentShader, uniforms){\n        this.program = ctx.createProgram(vertexShader, fragmentShader);\n        this.uniforms = uniforms;\n        this.uniformLocations = ctx.getUniformLocations(this.program, uniforms);\n    }\n}\n/**\r\n * @hidden\r\n */ class VertexData {\n    /** */ constructor(data, itemSize){\n        this.data = data;\n        this.itemSize = itemSize;\n        this.count = data.length / itemSize;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class Geometry {\n    /** */ constructor(vertices, indicies, uvs){\n        this.vertices = new VertexData(new Float32Array(vertices), 3);\n        this.indicies = new VertexData(new Uint16Array(indicies), 1);\n        this.uvs = new VertexData(new Float32Array(uvs), 2);\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class CubeGeometry extends Geometry {\n    constructor({ order, rotateUV }){\n        const vertices = [\n            // back\n            1,\n            -1,\n            1,\n            -1,\n            -1,\n            1,\n            -1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            // front\n            -1,\n            -1,\n            -1,\n            1,\n            -1,\n            -1,\n            1,\n            1,\n            -1,\n            -1,\n            1,\n            -1,\n            // up\n            -1,\n            1,\n            -1,\n            1,\n            1,\n            -1,\n            1,\n            1,\n            1,\n            -1,\n            1,\n            1,\n            // down\n            -1,\n            -1,\n            1,\n            1,\n            -1,\n            1,\n            1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            // right\n            1,\n            -1,\n            -1,\n            1,\n            -1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            -1,\n            // left\n            -1,\n            -1,\n            1,\n            -1,\n            -1,\n            -1,\n            -1,\n            1,\n            -1,\n            -1,\n            1,\n            1\n        ];\n        const indicies = [\n            0,\n            1,\n            2,\n            0,\n            2,\n            3,\n            4,\n            5,\n            6,\n            4,\n            6,\n            7,\n            8,\n            9,\n            10,\n            8,\n            10,\n            11,\n            12,\n            13,\n            14,\n            12,\n            14,\n            15,\n            16,\n            17,\n            18,\n            16,\n            18,\n            19,\n            20,\n            21,\n            22,\n            20,\n            22,\n            23\n        ];\n        const oneThird = 1 / 3;\n        const coords = [];\n        for(let r = 1; r >= 0; r--){\n            for(let c = 0; c < 3; c++){\n                const coord = [\n                    c * oneThird,\n                    r * 0.5,\n                    (c + 1) * oneThird,\n                    r * 0.5,\n                    (c + 1) * oneThird,\n                    (r + 1) * 0.5,\n                    c * oneThird,\n                    (r + 1) * 0.5\n                ];\n                coords.push(coord);\n            }\n        }\n        if (rotateUV) {\n            rotateUV.forEach((degree, idx)=>{\n                if (degree === ROTATE.ZERO) return;\n                const coord = coords[idx];\n                let newOrder;\n                if (degree === ROTATE.CW_90) {\n                    newOrder = [\n                        1,\n                        2,\n                        3,\n                        0\n                    ];\n                } else if (degree === ROTATE.CCW_90) {\n                    newOrder = [\n                        3,\n                        0,\n                        1,\n                        2\n                    ];\n                } else {\n                    newOrder = [\n                        2,\n                        3,\n                        0,\n                        1\n                    ];\n                }\n                const newCoords = Array(coord.length);\n                for(let uvIdx = 0; uvIdx < coord.length / 2; uvIdx++){\n                    newCoords[uvIdx * 2 + 0] = coord[newOrder[uvIdx] * 2 + 0];\n                    newCoords[uvIdx * 2 + 1] = coord[newOrder[uvIdx] * 2 + 1];\n                }\n                coords[idx] = newCoords;\n            });\n        }\n        const uvs = reorderCube(coords, order, \"BFUDRL\").reduce((acc, val)=>acc.concat(val), []);\n        super(vertices, indicies, uvs);\n    }\n}\nvar vs$3 = \"#define GLSLIFY 1\\nattribute vec3 position;attribute vec2 uv;uniform mat4 uMVMatrix;uniform mat4 uPMatrix;varying highp vec3 vPos;void main(){vPos=position;gl_Position=uPMatrix*uMVMatrix*vec4(position,1.0);}\"; // eslint-disable-line\nvar fs$3 = \"#define GLSLIFY 1\\nuniform samplerCube uTexture;varying highp vec3 vPos;void main(){gl_FragColor=textureCube(uTexture,vec3(vPos.x,vPos.y,-vPos.z));}\"; // eslint-disable-line\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Projection based on cubemap images, accepts both multiple or single images.\r\n * @ko 큐브맵 이미지 기반의 프로젝션, 단일 혹은 여러 장의 이미지를 모두 사용 가능합니다.\r\n * @since 4.0.0\r\n * @category Projection\r\n */ class CubemapProjection extends Projection {\n    /**\r\n   * Create new instance.\r\n   * @ko 새 인스턴스를 생성합니다.\r\n   * @param options Options {@ko Options}\r\n   */ constructor(options){\n        super(options);\n        const { cubemapOrder = \"RLUDFB\", cubemapFlipX = false } = options;\n        this._cubemapOrder = cubemapOrder;\n        this._cubemapFlipX = cubemapFlipX;\n    }\n    createMesh(ctx, texture) {\n        const cubemapOrder = this._cubemapOrder;\n        const cubemapFlipX = this._cubemapFlipX;\n        const uniforms = {\n            uTexture: texture.isCube() ? new UniformTextureCube(ctx, texture, cubemapOrder) : new UniformCanvasCube(ctx, texture, cubemapOrder)\n        };\n        const geometry = new CubeGeometry({\n            order: cubemapOrder\n        });\n        const program = new ShaderProgram(ctx, vs$3, fs$3, uniforms);\n        const vao = ctx.createVAO(geometry, program);\n        const mesh = new TriangleMesh(vao, program);\n        if (cubemapFlipX) {\n            mesh.scale[0] = -1;\n        }\n        mesh.updateMatrix();\n        return mesh;\n    }\n}\nclass UniformTexture2D extends Uniform {\n    constructor(ctx, texture){\n        super();\n        this.texture = texture;\n        this._webglTexture = ctx.createWebGLTexture(texture);\n    }\n    destroy(gl) {\n        this.texture.destroy();\n        gl.deleteTexture(this._webglTexture);\n    }\n    update(gl, location, isWebGL2) {\n        const texture = this.texture;\n        const isVideo = texture.isVideo();\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n        gl.uniform1i(location, 0);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this._webglTexture);\n        if (!isVideo && isWebGL2) {\n            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n        } else {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n        }\n        if (!isVideo) {\n            this.needsUpdate = false;\n        }\n    }\n}\nvar vs$2 = \"#define GLSLIFY 1\\nattribute vec3 position;attribute vec2 uv;uniform mat4 uMVMatrix;uniform mat4 uPMatrix;varying highp vec2 vUV;void main(){vUV=uv;gl_Position=uPMatrix*uMVMatrix*vec4(position,1.0);}\"; // eslint-disable-line\nvar fs$2 = \"#define GLSLIFY 1\\nuniform sampler2D uTexture;varying highp vec2 vUV;void main(){gl_FragColor=texture2D(uTexture,vUV.st);}\"; // eslint-disable-line\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Projection based on cubemap strip.\r\n * Slightly more efficient than {@link CubemapProjection} as it doesn't copy cubemap image to canvas while rendering.\r\n * Accepts only single image.\r\n * @ko 큐브맵 스트립 기반의 프로젝션.\r\n * {@link CubemapProjection}와 달리 렌더링하는 과정에 캔버스에 이미지를 복사하는 과정이 없기 때문에 살짝 더 효율적입니다.\r\n * 단일 이미지만 사용 가능합니다.\r\n * @since 4.0.0\r\n * @category Projection\r\n */ class CubestripProjection extends Projection {\n    /**\r\n   * Create new instance.\r\n   * @ko 새 인스턴스를 생성합니다.\r\n   * @param options Options {@ko Options}\r\n   */ constructor(options){\n        super(options);\n        const { cubemapOrder = \"RLUDFB\", cubemapFlipX = false } = options;\n        this._cubemapOrder = cubemapOrder;\n        this._cubemapFlipX = cubemapFlipX;\n    }\n    createMesh(ctx, texture) {\n        const cubemapOrder = this._cubemapOrder;\n        const cubemapFlipX = this._cubemapFlipX;\n        const uniforms = {\n            uTexture: new UniformTexture2D(ctx, texture)\n        };\n        const geometry = new CubeGeometry({\n            order: cubemapOrder\n        });\n        const program = new ShaderProgram(ctx, vs$2, fs$2, uniforms);\n        const vao = ctx.createVAO(geometry, program);\n        const mesh = new TriangleMesh(vao, program);\n        if (cubemapFlipX) {\n            mesh.scale[0] = -1;\n        }\n        mesh.updateMatrix();\n        return mesh;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class CylinderGeometry extends Geometry {\n    constructor(maxTheta){\n        const vertices = [];\n        const indicies = [];\n        const uvs = [];\n        const height = 1;\n        const radialSegments = 60;\n        const halfHeight = height * 0.5;\n        const heightSegments = [\n            -halfHeight,\n            halfHeight\n        ];\n        const invRadialSegments = 1 / radialSegments;\n        const angleConst = maxTheta * invRadialSegments;\n        for(let yIdx = 0; yIdx < 2; yIdx++){\n            const y = heightSegments[yIdx];\n            for(let lngIdx = 0; lngIdx <= radialSegments; lngIdx++){\n                const angle = lngIdx * angleConst + Math.PI - maxTheta * 0.5;\n                const x = Math.cos(angle);\n                const z = Math.sin(angle);\n                const u = lngIdx * invRadialSegments;\n                const v = yIdx;\n                uvs.push(u, v);\n                vertices.push(x, y, z);\n                if (yIdx === 0 && lngIdx < radialSegments) {\n                    const a = lngIdx;\n                    const b = a + radialSegments + 1;\n                    indicies.push(a, b, a + 1, b, b + 1, a + 1);\n                }\n            }\n        }\n        super(vertices, indicies, uvs);\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n*/ /**\r\n * Projection based on cylindrical projection.\r\n * This can show panorama images taken from smartphones.\r\n * @ko 원통 투영법 기반의 프로젝션.\r\n * 일반적인 스마트폰 파노라마 사진을 표시하는데 사용될 수 있습니다.\r\n * @since 4.0.0\r\n * @category Projection\r\n */ class CylindricalProjection extends Projection {\n    /**\r\n   * Create new instance.\r\n   * @ko 새 인스턴스를 생성합니다.\r\n   * @param options Options {@ko Options}\r\n   */ constructor(options){\n        super(options);\n        const { partial = false } = options;\n        this._partial = partial;\n        this._aspect = 1;\n        this._halfHeight = 0;\n        this._mesh = null;\n    }\n    createMesh(ctx, texture) {\n        if (this._mesh) return this._mesh;\n        const partial = this._partial;\n        const { width, height } = texture;\n        const aspect = width / height;\n        const halfVFov = 180 / aspect;\n        const cylinderHeight = partial ? 1 : 2 * Math.tan(halfVFov * DEG_TO_RAD);\n        const cylinderTheta = partial ? aspect : 2 * Math.PI;\n        const geometry = new CylinderGeometry(cylinderTheta);\n        const program = new ShaderProgram(ctx, vs$2, fs$2, {\n            uTexture: new UniformTexture2D(ctx, texture)\n        });\n        const vao = ctx.createVAO(geometry, program);\n        const mesh = new TriangleMesh(vao, program);\n        mesh.scale[1] = cylinderHeight;\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.identity(mesh.rotation);\n        gl_matrix__WEBPACK_IMPORTED_MODULE_1__.rotateY(mesh.rotation, mesh.rotation, -Math.PI / 2);\n        mesh.updateMatrix();\n        this._aspect = aspect;\n        this._halfHeight = cylinderHeight * 0.5;\n        this._mesh = mesh;\n        return mesh;\n    }\n    updateCamera(camera) {\n        super.updateCamera(camera);\n        const mesh = this._mesh;\n        const aspect = this._aspect;\n        const halfHeight = this._halfHeight;\n        if (!mesh) return;\n        if (this._partial) {\n            const restrictedYaw = 0.5 * aspect * RAD_TO_DEG;\n            camera.restrictYawRange(-restrictedYaw, restrictedYaw);\n        }\n        const restrictedPitch = Math.atan2(halfHeight, 1) * RAD_TO_DEG;\n        const minZoom = Math.tan(camera.fov * DEG_TO_RAD * 0.5) / (halfHeight * camera.aspect);\n        camera.restrictPitchRange(-restrictedPitch, restrictedPitch);\n        camera.restrictZoomRange(minZoom, Infinity);\n        camera.restrictRenderHeight(halfHeight * 2);\n    }\n}\nvar fs$1 = \"#define PI 3.14159265359\\nprecision mediump float;\\n#define GLSLIFY 1\\nuniform sampler2D uTexture;varying highp vec2 vUV;const vec2 OPERATE_COORDS_RANGE=vec2(-1.0,1.0);const vec2 TEXTURE_COORDS_RANGE=vec2(0.0,1.0);const float ONE_THIRD=1.0/3.0;const float EAC_CONST=2.0/PI;float scale(vec2 domainRange,vec2 targetRange,float val){float unit=1.0/(domainRange[1]-domainRange[0]);return targetRange[0]+(targetRange[1]-targetRange[0])*(val-domainRange[0])*unit;}void main(void){float transformedCoordX;float transformedCoordY;float texRangeXStart=floor(vUV.s*3.)*ONE_THIRD;float texRangeYStart=floor(vUV.t*2.)*0.5;vec2 orgTextureRangeX=vec2(texRangeXStart,texRangeXStart+ONE_THIRD);vec2 orgTextureRangeY=vec2(texRangeYStart,texRangeYStart+0.5);float px=scale(orgTextureRangeX,OPERATE_COORDS_RANGE,vUV.s);float py=scale(orgTextureRangeY,OPERATE_COORDS_RANGE,vUV.t);float qu=EAC_CONST*atan(px)+0.5;float qv=EAC_CONST*atan(py)+0.5;transformedCoordX=scale(TEXTURE_COORDS_RANGE,orgTextureRangeX,qu);transformedCoordY=scale(TEXTURE_COORDS_RANGE,orgTextureRangeY,qv);gl_FragColor=texture2D(uTexture,vec2(transformedCoordX,transformedCoordY));}\"; // eslint-disable-line\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Equi-Angular Cubemap Projection.\r\n * This format is used by Youtube's 360 videos.\r\n * @ko Equi-Angular Cubemap 프로젝션.\r\n * 이 포맷은 주로 Youtube의 360 비디오에 사용됩니다.\r\n * @since 4.0.0\r\n * @category Projection\r\n */ class EquiangularProjection extends Projection {\n    createMesh(ctx, texture) {\n        const uniforms = {\n            uTexture: new UniformTexture2D(ctx, texture)\n        };\n        const geometry = new CubeGeometry({\n            order: \"LFRDBU\",\n            rotateUV: [\n                ROTATE.ZERO,\n                ROTATE.ZERO,\n                ROTATE.ZERO,\n                ROTATE.CW_90,\n                ROTATE.CCW_90,\n                ROTATE.CW_90\n            ]\n        });\n        const program = new ShaderProgram(ctx, vs$2, fs$1, uniforms);\n        const vao = ctx.createVAO(geometry, program);\n        const mesh = new TriangleMesh(vao, program);\n        return mesh;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class SphereGeometry extends Geometry {\n    /** */ constructor(){\n        // const radius = 1;\n        const widthSegments = 60;\n        const heightSegments = 60;\n        const ANGLE_CORRECTION_FOR_CENTER_ALIGN = -0.5 * Math.PI;\n        const uvs = [];\n        const vertices = [];\n        const indicies = [];\n        let latIdx;\n        let lngIdx;\n        for(latIdx = 0; latIdx <= widthSegments; latIdx++){\n            const theta = (latIdx / widthSegments - 0.5) * Math.PI;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n            for(lngIdx = 0; lngIdx <= heightSegments; lngIdx++){\n                const phi = (lngIdx / heightSegments - 0.5) * 2 * Math.PI + ANGLE_CORRECTION_FOR_CENTER_ALIGN;\n                const sinPhi = Math.sin(phi);\n                const cosPhi = Math.cos(phi);\n                const x = cosPhi * cosTheta;\n                const y = sinTheta;\n                const z = sinPhi * cosTheta;\n                const u = lngIdx / heightSegments;\n                const v = latIdx / widthSegments;\n                uvs.push(u, v);\n                vertices.push(x, y, z);\n                if (lngIdx !== heightSegments && latIdx !== widthSegments) {\n                    const a = latIdx * (heightSegments + 1) + lngIdx;\n                    const b = a + heightSegments + 1;\n                    indicies.push(a, a + 1, b, b, a + 1, b + 1);\n                }\n            }\n        }\n        super(vertices, indicies, uvs);\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Projection based on equirectangular projection.\r\n * @ko 등 장방형 도법(Equirectangular projection) 기반의 프로젝션\r\n * @since 4.0.0\r\n * @category Projection\r\n */ class EquirectProjection extends Projection {\n    /**\r\n   * Create new instance\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor(options){\n        super(options);\n    }\n    createMesh(ctx, texture) {\n        const uniforms = {\n            uTexture: new UniformTexture2D(ctx, texture)\n        };\n        const geometry = new SphereGeometry();\n        const program = new ShaderProgram(ctx, vs$2, fs$2, uniforms);\n        const vao = ctx.createVAO(geometry, program);\n        const mesh = new TriangleMesh(vao, program);\n        return mesh;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class UniformFloat extends Uniform {\n    constructor(val){\n        super();\n        this.val = val;\n    }\n    update(gl, location) {\n        gl.uniform1f(location, this.val);\n        this.needsUpdate = false;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * @hidden\r\n */ class PlaneGeometry extends Geometry {\n    /** */ constructor(width = 2, height = 2, z = -1){\n        const halfWidth = width * 0.5;\n        const halfHeight = height * 0.5;\n        const vertices = [\n            -halfWidth,\n            -halfHeight,\n            z,\n            halfWidth,\n            -halfHeight,\n            z,\n            -halfWidth,\n            halfHeight,\n            z,\n            halfWidth,\n            halfHeight,\n            z\n        ];\n        const indicies = [\n            0,\n            1,\n            2,\n            2,\n            1,\n            3\n        ];\n        const uvs = [\n            0,\n            0,\n            1,\n            0,\n            0,\n            1,\n            1,\n            1\n        ];\n        super(vertices, indicies, uvs);\n    }\n}\nvar vs$1 = \"#define GLSLIFY 1\\nattribute vec3 position;attribute vec2 uv;uniform mat4 uMVMatrix;uniform mat4 uPMatrix;varying highp vec2 vUV;void main(){vUV=uv;gl_Position=vec4(position,1.0);}\"; // eslint-disable-line\nvar fs = \"precision mediump float;\\n#define GLSLIFY 1\\nuniform sampler2D uTexture;uniform float uYaw;uniform float uPitch;uniform float uZoom;varying highp vec2 vUV;const float PI=3.1415926536;const float PI_2=PI*0.5;vec2 toStereographicUV(in vec2 uv,in vec2 center){float R=1.*uZoom;vec2 texLatLon=(uv*2.-1.)*vec2(PI,PI_2);vec2 central=(center*2.-1.)*vec2(PI,PI_2)+vec2(PI,0);float x=texLatLon.x;float y=texLatLon.y;float rou=sqrt(x*x+y*y);float c=2.0*atan(rou,R*0.5);float sin_c=sin(c);float cos_c=cos(c);float sin_cy=sin(central.y);float cos_cy=cos(central.y);float lat=asin(cos_c*sin_cy+(y*sin_c*cos_cy)/rou);float lon=central.x+atan(x*sin_c,rou*cos_cy*cos_c-y*sin_cy*sin_c);float u=(lon/PI+1.0)*0.5;float v=(lat/PI_2+1.0)*0.5;return vec2(u,v);}void main(){vec2 central=vec2(uYaw,uPitch);vec2 uv=toStereographicUV(vUV,central);gl_FragColor=texture2D(uTexture,uv);}\"; // eslint-disable-line\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Projection based on so-called \"Little planet\" or \"Tiny planet\" effect.\r\n * @ko \"Little planet\" 혹은 \"Tiny planet\"로 불리는 이펙트 기반의 프로젝션\r\n * @since 4.0.0\r\n * @category Projection\r\n */ class LittlePlanetProjection extends Projection {\n    /**\r\n   * Create new instance\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor(options){\n        super(options);\n    }\n    createMesh(ctx, texture) {\n        texture.wrapS = WebGLRenderingContext.REPEAT;\n        texture.wrapT = WebGLRenderingContext.REPEAT;\n        const uniforms = {\n            uTexture: new UniformTexture2D(ctx, texture),\n            uYaw: new UniformFloat(0),\n            uPitch: new UniformFloat(0.5),\n            uZoom: new UniformFloat(1)\n        };\n        const geometry = new PlaneGeometry();\n        const program = new ShaderProgram(ctx, vs$1, fs, uniforms);\n        const vao = ctx.createVAO(geometry, program);\n        const mesh = new TriangleMesh(vao, program);\n        mesh.on(OBJECT_3D_EVENTS.UPDATE, ({ camera })=>{\n            const uniforms = mesh.program.uniforms;\n            uniforms.uYaw.val = camera.yaw / 360;\n            // Range from 0 ~ 1\n            uniforms.uPitch.val = camera.pitch / 180 + 0.5;\n            uniforms.uZoom.val = camera.zoom;\n            uniforms.uYaw.needsUpdate = true;\n            uniforms.uPitch.needsUpdate = true;\n            uniforms.uZoom.needsUpdate = true;\n        });\n        return mesh;\n    }\n    updateControl(control) {\n        control.ignoreZoomScale = true;\n    }\n}\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ class UniformVector4Array extends Uniform {\n    constructor(val){\n        super();\n        this.val = val;\n    }\n    update(gl, location) {\n        gl.uniform4fv(location, this.val.reduce((arr, vector)=>[\n                ...arr,\n                ...vector\n            ], []));\n        this.needsUpdate = false;\n    }\n}\nvar vs = \"#define GLSLIFY 1\\nattribute vec3 position;attribute vec2 uv;uniform mat4 uMVMatrix;uniform mat4 uPMatrix;uniform vec4 uTexScaleOffset[2];uniform float uEye;varying highp vec2 vUV;void main(){vec4 scaleOffset=uTexScaleOffset[int(uEye)];vUV=uv.xy*scaleOffset.xy+scaleOffset.zw;gl_Position=uPMatrix*uMVMatrix*vec4(position,1.0);}\"; // eslint-disable-line\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */ /**\r\n * Projection based on stereo equirectangular images.\r\n * @ko Stereo equirectangular 이미지 기반의 프로젝션\r\n * @since 4.0.0\r\n * @category Projection\r\n */ class StereoEquiProjection extends Projection {\n    /**\r\n   * Create new instance\r\n   * @ko 새로운 인스턴스를 생성합니다.\r\n   * @param options - Options {@ko 옵션들}\r\n   */ constructor(options){\n        super(options);\n        this._mode = options.mode;\n    }\n    createMesh(ctx, texture) {\n        let leftEye;\n        let rightEye;\n        switch(this._mode){\n            case StereoEquiProjection.MODE.LEFT_RIGHT:\n                leftEye = [\n                    0.5,\n                    1,\n                    0,\n                    0\n                ];\n                rightEye = [\n                    0.5,\n                    1,\n                    0.5,\n                    0\n                ];\n                break;\n            default:\n                // Default, uses \"top_bottom\"\n                leftEye = [\n                    1,\n                    0.5,\n                    0,\n                    0\n                ];\n                rightEye = [\n                    1,\n                    0.5,\n                    0,\n                    0.5\n                ];\n        }\n        const uniforms = {\n            uTexture: new UniformTexture2D(ctx, texture),\n            uEye: new UniformFloat(0),\n            uTexScaleOffset: new UniformVector4Array([\n                leftEye,\n                rightEye\n            ])\n        };\n        const geometry = new SphereGeometry();\n        const program = new ShaderProgram(ctx, vs, fs$2, uniforms);\n        const vao = ctx.createVAO(geometry, program);\n        const mesh = new TriangleMesh(vao, program);\n        return mesh;\n    }\n}\n/**\r\n * Available stereoscopic modes\r\n * @ko 사용가능한 스테레오스코픽 모드들\r\n * @since 4.0.0\r\n */ StereoEquiProjection.MODE = {\n    /**\r\n   * @ko 이미지가 왼쪽/오른쪽으로 구성되어있을 경우\r\n   * @since 4.0.0\r\n   */ LEFT_RIGHT: \"left_right\",\n    /**\r\n   * @ko 이미지가 위/아래로 구성되어있을 경우\r\n   * @since 4.0.0\r\n   */ TOP_BOTTOM: \"top_bottom\"\n};\n/**\r\n * @hidden\r\n */ const withMethods = (prototype, attr)=>{\n    [\n        _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype,\n        View360.prototype\n    ].forEach((proto)=>{\n        Object.getOwnPropertyNames(proto).filter((name)=>name.charAt(0) !== \"_\" && name !== \"constructor\").forEach((name)=>{\n            const descriptor = Object.getOwnPropertyDescriptor(proto, name);\n            if (descriptor.value) {\n                // Public Function\n                Object.defineProperty(prototype, name, {\n                    value: function(...args) {\n                        return descriptor.value.call(this[attr], ...args);\n                    }\n                });\n            } else {\n                const getterDescriptor = {};\n                if (descriptor.get) {\n                    getterDescriptor.get = function() {\n                        var _a;\n                        return this[attr] && ((_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(this[attr]));\n                    };\n                }\n                if (descriptor.set) {\n                    getterDescriptor.set = function(...args) {\n                        var _a;\n                        return (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call(this[attr], ...args);\n                    };\n                }\n                Object.defineProperty(prototype, name, getterDescriptor);\n            }\n        });\n    });\n};\n/**\r\n * @hidden\r\n */ const getValidProps = (propsObj)=>{\n    return Object.keys(propsObj).reduce((props, propName)=>{\n        if (propsObj[propName] != null) {\n            props[propName] = propsObj[propName];\n        }\n        return props;\n    }, {});\n};\nconst VIEW360_METHODS = [\n    \"destroy\",\n    \"init\",\n    \"load\",\n    \"resize\",\n    \"addPlugins\",\n    \"removePlugins\",\n    \"renderFrame\",\n    // @egjs/component methods\n    \"on\",\n    \"hasOn\",\n    \"once\",\n    \"off\",\n    \"trigger\"\n];\n/*\r\n * Copyright (c) 2023-present NAVER Corp.\r\n * egjs projects are licensed under the MIT license\r\n */  //# sourceMappingURL=view360.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvdmlldzM2MC9kaXN0L3ZpZXczNjAuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7OztBQU9BLEdBQ3dDO0FBQ1c7QUFDZjtBQUVwQzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsU0FBU00sVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNsRCxTQUFTQyxNQUFNQyxLQUFLO1FBQ2xCLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFDekRBLFFBQVFEO1FBQ1Y7SUFDRjtJQUNBLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3ZELFNBQVNDLFVBQVVKLEtBQUs7WUFDdEIsSUFBSTtnQkFDRkssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUN0QixFQUFFLE9BQU9PLEdBQUc7Z0JBQ1ZKLE9BQU9JO1lBQ1Q7UUFDRjtRQUNBLFNBQVNDLFNBQVNSLEtBQUs7WUFDckIsSUFBSTtnQkFDRkssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFDMUIsRUFBRSxPQUFPTyxHQUFHO2dCQUNWSixPQUFPSTtZQUNUO1FBQ0Y7UUFDQSxTQUFTRixLQUFLSSxNQUFNO1lBQ2xCQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQzVFO1FBQ0FILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDcEU7QUFDRjtBQUVBOzs7Q0FHQyxHQUNEOzs7O0NBSUMsR0FDRCxNQUFNTyxxQkFBcUJDO0lBQ3pCOzs7OztHQUtD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Z0MsSUFBSSxDQUFDLElBQUksQ0FBQzBPLEtBQUssS0FBS087b0JBQzNGO2dCQUNGO2dCQUNBbDNDLE9BQU9pM0MsY0FBYyxDQUFDLzJDLFdBQVdDLE1BQU1nM0M7WUFDekM7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU1FLGdCQUFnQkMsQ0FBQUE7SUFDcEIsT0FBT3QzQyxPQUFPdTJCLElBQUksQ0FBQytnQixVQUFVeDlCLE1BQU0sQ0FBQyxDQUFDeTlCLE9BQU9DO1FBQzFDLElBQUlGLFFBQVEsQ0FBQ0UsU0FBUyxJQUFJLE1BQU07WUFDOUJELEtBQUssQ0FBQ0MsU0FBUyxHQUFHRixRQUFRLENBQUNFLFNBQVM7UUFDdEM7UUFDQSxPQUFPRDtJQUNULEdBQUcsQ0FBQztBQUNOO0FBRUEsTUFBTUUsa0JBQWtCO0lBQUM7SUFBVztJQUFRO0lBQVE7SUFBVTtJQUFjO0lBQWlCO0lBQzdGLDBCQUEwQjtJQUMxQjtJQUFNO0lBQVM7SUFBUTtJQUFPO0NBQVU7QUFFeEM7OztDQUdDLEdBRThrQixDQUMva0IsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ibGVzLXJlbmRlci8uL25vZGVfbW9kdWxlcy9AZWdqcy92aWV3MzYwL2Rpc3QvdmlldzM2MC5lc20uanM/NTYyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL3ZpZXczNjBcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtdmlldzM2MFxudmVyc2lvbjogNC4wLjAtYmV0YS43XG4qL1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZWdqcy9jb21wb25lbnQnO1xuaW1wb3J0IHsgcXVhdCwgdmVjMywgbWF0NCwgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgSW1SZWFkeSBmcm9tICdAZWdqcy9pbXJlYWR5JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogRXJyb3IgdGhyb3duIGJ5IHtAbGluayBWaWV3MzYwfVxyXG4gKiBAa28ge0BsaW5rIFZpZXczNjB97J20IOuwnOyDneyLnO2CqCDsl5Drn6xcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgVmlldzM2MEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlIG9mIFZpZXczNjBFcnJvclxyXG4gICAqIEBrbyBWaWV3MzYwRXJyb3LsnZgg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIEVycm9yIG1lc3NhZ2Uge0BrbyDsl5Drn6wg66mU7Iuc7KeAfVxyXG4gICAqIEBwYXJhbSBjb2RlIC0gRXJyb3IgY29kZSB7QGtvIOyXkOufrCDsvZTrk5x9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVmlldzM2MEVycm9yLnByb3RvdHlwZSk7XG4gICAgdGhpcy5uYW1lID0gXCJWaWV3MzYwRXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBFcnJvciBjb2RlcyBvZiB7QGxpbmsgVmlldzM2MEVycm9yfVxyXG4gKiBAa28ge0BsaW5rIFZpZXczNjBFcnJvcn3qsIAg6rCA7KeIIOyImCDsnojripQg7JeQ65+sIOy9lOuTnCDqsJLrk6RcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY29uc3QgRVJST1JfQ09ERVMgPSB7XG4gIC8qKlxyXG4gICAqIFRoZSBnaXZlbiB2YWx1ZSdzIHR5cGUgaXMgbm90IGV4cGVjdGVkXHJcbiAgICogQGtvIOyjvOyWtOynhCDqsJLsnZgg7YOA7J6F7J20IOyemOuqu+uQmOyXiOydhCDqsr3smrBcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgV1JPTkdfVFlQRTogMCxcbiAgLyoqXHJcbiAgICogVGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHN1cHBvcnRlZCBvcHRpb25cclxuICAgKiBAa28g7J6Y66q765CcIOyYteyFmOydhCDrsJvslZjsnYQg6rK97JqwXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIFdST05HX09QVElPTjogMSxcbiAgLyoqXHJcbiAgICogVGhlIGVsZW1lbnQgd2l0aCBnaXZlbiBDU1Mgc2VsZWN0b3IgZG9lcyBub3QgZXhpc3RcclxuICAgKiBAa28g7KO87Ja07KeEIENTUyDshYDroInthLDroZwg7JeY66as66i87Yq466W8IOywvuyngCDrqrvtlojsnYQg6rK97JqwXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIEVMRU1FTlRfTk9UX0ZPVU5EOiAyLFxuICAvKipcclxuICAgKiBDb3VsZG4ndCBmaW5kIGNhbnZhcyBlbGVtZW50IGluc2lkZSB0aGUgZ2l2ZW4gY29udGFpbmVyIGVsZW1lbnQuXHJcbiAgICogQGtvIOy7qO2FjOydtOuEiCDsl5jrpqzrqLztirgg64K067aA7JeQ7IScIOy6lOuyhOyKpCDsl5jrpqzrqLztirjrpbwg7LC+7KeAIOuqu+2WiOydhCDqsr3smrBcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgQ0FOVkFTX05PVF9GT1VORDogMyxcbiAgLyoqXHJcbiAgICogVGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTFxyXG4gICAqIEBrbyDruIzrnbzsmrDsoIDqsIAgV2ViR0zsnYQg7KeA7JuQ7ZWY7KeAIOyViuuKlCDqsr3smrBcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgV0VCR0xfTk9UX1NVUFBPUlRFRDogNCxcbiAgLyoqXHJcbiAgICogRmFpbGVkIGNyZWF0aW5nIGNhbnZhcyAyRCBjb250ZXh0XHJcbiAgICogQGtvIOy6lOuyhOyKpCAyRCDsu6jthY3siqTtirjrpbwg7IOd7ISx7ZWY7KeAIOuqu+2VnCDqsr3smrBcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgRkFJTEVEX0NSRUFURV9DT05URVhUXzJEOiA1LFxuICAvKipcclxuICAgKiBgaW5pdCgpYCBpcyBjYWxsZWQgYmVmb3JlIHNldHRpbmcge0BsaW5rIFZpZXczNjBPcHRpb25zI3Byb2plY3Rpb259XHJcbiAgICogQGtvIHtAbGluayBWaWV3MzYwT3B0aW9ucyNwcm9qZWN0aW9ufeydhCDshKTsoJXtlZjquLAg7KCE7JeQIGBpbml0KClg7J20IO2YuOy2nOuQnCDqsr3smrBcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgUFJPVklERV9QUk9KRUNUSU9OX0ZJUlNUOiA2LFxuICAvKipcclxuICAgKiBGYWlsZWQgbGlua2luZyBXZWJHTCBwcm9ncmFtLiBPbmx5IGNhbiBiZSB0aHJvd24gd2hlbiB7QGxpbmsgVmlldzM2ME9wdGlvbnMjZGVidWd9IGlzIGB0cnVlYC5cclxuICAgKiBAa28gV2ViR0wg7ZSE66Gc6re4656oIOunge2BrOyXkCDsi6TtjKjtlZwg6rK97JqwLiB7QGxpbmsgVmlldzM2ME9wdGlvbnMjZGVidWd966W8IGB0cnVlYOuhnCDshKTsoJXtlZwg6rK97Jqw7JeQ66eMIOuwnOyDne2VoCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBGQUlMRURfTElOS0lOR19QUk9HUkFNOiA3LFxuICAvKipcclxuICAgKiBBcmd1bWVudHMgYXJlIG5vdCBzdWZmaWNpZW50IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXHJcbiAgICogQGtvIO2UhOuhnO2NvO2LsOyXkCDqsJLsnbQg7Lap67aE7Z6IIOyjvOyWtOyngOyngCDslYrslZjsnYQg65WMXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIElOU1VGRklDSUVOVF9BUkdTOiA4XG59O1xuY29uc3QgTUVTU0FHRVMgPSB7XG4gIFdST05HX1RZUEU6ICh2YWwsIHR5cGVzKSA9PiBgJHt0eXBlb2YgdmFsfSBpcyBub3QgYSAke3R5cGVzLm1hcCh0eXBlID0+IGBcIiR7dHlwZX1cImApLmpvaW4oXCIgb3IgXCIpfS5gLFxuICBXUk9OR19PUFRJT046ICh2YWwsIG9wdGlvbk5hbWUpID0+IGBCYWQgb3B0aW9uOiBnaXZlbiBcIiR7dmFsfVwiIGZvciBvcHRpb24gXCIke29wdGlvbk5hbWV9XCIuYCxcbiAgRUxFTUVOVF9OT1RfRk9VTkQ6IHF1ZXJ5ID0+IGBFbGVtZW50IHdpdGggc2VsZWN0b3IgXCIke3F1ZXJ5fVwiIG5vdCBmb3VuZC5gLFxuICBDQU5WQVNfTk9UX0ZPVU5EOiBcIlRoZSBjYW52YXMgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluc2lkZSB0aGUgZ2l2ZW4gcm9vdCBlbGVtZW50LlwiLFxuICBXRUJHTF9OT1RfU1VQUE9SVEVEOiBcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLlwiLFxuICBGQUlMRURfQ1JFQVRFX0NPTlRFWFRfMkQ6IFwiRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMgMkQgY29udGV4dFwiLFxuICBQUk9WSURFX1BST0pFQ1RJT05fRklSU1Q6IFwiXFxcInByb2plY3Rpb25cXFwiIHNob3VsZCBiZSBwcm92aWRlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24uXCIsXG4gIEZBSUxFRF9MSU5LSU5HX1BST0dSQU06IChtc2csIHNoYWRlckxvZykgPT4gYEZhaWxlZCBsaW5raW5nIFdlYkdMIHByb2dyYW0gLSBcIiR7bXNnfVxcblNoYWRlciBjb21waWxlIExvZzogJHtzaGFkZXJMb2d9YCxcbiAgSU5TVUZGSUNJRU5UX0FSR1M6ICh2YWwsIG5hbWUpID0+IGBJbnN1ZmZpY2llbnQgYXJndW1lbnRzOiBnaXZlbiBcIiR7dmFsfVwiIGZvciBcIiR7bmFtZX1cIi5gXG59O1xudmFyIEVSUk9SID0ge1xuICBDT0RFUzogRVJST1JfQ09ERVMsXG4gIE1FU1NBR0VTXG59O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG5jb25zdCBFVkVOVFMkMSA9IHtcbiAgTU9VU0VfRE9XTjogXCJtb3VzZWRvd25cIixcbiAgTU9VU0VfTU9WRTogXCJtb3VzZW1vdmVcIixcbiAgTU9VU0VfVVA6IFwibW91c2V1cFwiLFxuICBUT1VDSF9TVEFSVDogXCJ0b3VjaHN0YXJ0XCIsXG4gIFRPVUNIX01PVkU6IFwidG91Y2htb3ZlXCIsXG4gIFRPVUNIX0VORDogXCJ0b3VjaGVuZFwiLFxuICBXSEVFTDogXCJ3aGVlbFwiLFxuICBSRVNJWkU6IFwicmVzaXplXCIsXG4gIENPTlRFWFRfTUVOVTogXCJjb250ZXh0bWVudVwiLFxuICBNT1VTRV9FTlRFUjogXCJtb3VzZWVudGVyXCIsXG4gIE1PVVNFX0xFQVZFOiBcIm1vdXNlbGVhdmVcIixcbiAgUE9JTlRFUl9ET1dOOiBcInBvaW50ZXJkb3duXCIsXG4gIFBPSU5URVJfTU9WRTogXCJwb2ludGVybW92ZVwiLFxuICBQT0lOVEVSX1VQOiBcInBvaW50ZXJ1cFwiLFxuICBQT0lOVEVSX0NBTkNFTDogXCJwb2ludGVyY2FuY2VsXCIsXG4gIFBPSU5URVJfRU5URVI6IFwicG9pbnRlcmVudGVyXCIsXG4gIFBPSU5URVJfTEVBVkU6IFwicG9pbnRlcmxlYXZlXCIsXG4gIEtFWV9ET1dOOiBcImtleWRvd25cIixcbiAgS0VZX1VQOiBcImtleXVwXCIsXG4gIExPQUQ6IFwibG9hZFwiLFxuICBFUlJPUjogXCJlcnJvclwiLFxuICBDTElDSzogXCJjbGlja1wiLFxuICBET1VCTEVfQ0xJQ0s6IFwiZGJsY2xpY2tcIixcbiAgQ09OVEVYVF9DUkVBVEVfRVJST1I6IFwid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvclwiLFxuICBDT05URVhUX0xPU1Q6IFwid2ViZ2xjb250ZXh0bG9zdFwiLFxuICBDT05URVhUX1JFU1RPUkVEOiBcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsXG4gIERFVklDRV9PUklFTlRBVElPTjogXCJkZXZpY2VvcmllbnRhdGlvblwiLFxuICBERVZJQ0VfTU9USU9OOiBcImRldmljZW1vdGlvblwiLFxuICBPUklFTlRBVElPTl9DSEFOR0U6IFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgVklERU9fUExBWTogXCJwbGF5XCIsXG4gIFZJREVPX1BBVVNFOiBcInBhdXNlXCIsXG4gIFZJREVPX0xPQURFRF9EQVRBOiBcImxvYWRlZGRhdGFcIixcbiAgVklERU9fVk9MVU1FX0NIQU5HRTogXCJ2b2x1bWVjaGFuZ2VcIixcbiAgVklERU9fVElNRV9VUERBVEU6IFwidGltZXVwZGF0ZVwiLFxuICBWSURFT19EVVJBVElPTl9DSEFOR0U6IFwiZHVyYXRpb25jaGFuZ2VcIixcbiAgVklERU9fQ0FOX1BMQVlUSFJPVUdIOiBcImNhbnBsYXl0aHJvdWdoXCIsXG4gIFRSQU5TSVRJT05fRU5EOiBcInRyYW5zaXRpb25lbmRcIixcbiAgWFJfRU5EOiBcImVuZFwiXG59O1xuY29uc3QgRUxfRElWID0gXCJkaXZcIjtcbmNvbnN0IEVMX0JVVFRPTiA9IFwiYnV0dG9uXCI7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC5idXR0b25cbnZhciBNT1VTRV9CVVRUT047XG4oZnVuY3Rpb24gKE1PVVNFX0JVVFRPTikge1xuICBNT1VTRV9CVVRUT05bTU9VU0VfQlVUVE9OW1wiTEVGVFwiXSA9IDBdID0gXCJMRUZUXCI7XG4gIE1PVVNFX0JVVFRPTltNT1VTRV9CVVRUT05bXCJNSURETEVcIl0gPSAxXSA9IFwiTUlERExFXCI7XG4gIE1PVVNFX0JVVFRPTltNT1VTRV9CVVRUT05bXCJSSUdIVFwiXSA9IDJdID0gXCJSSUdIVFwiO1xufSkoTU9VU0VfQlVUVE9OIHx8IChNT1VTRV9CVVRUT04gPSB7fSkpO1xuY29uc3QgQ1VSU09SID0ge1xuICBHUkFCOiBcImdyYWJcIixcbiAgR1JBQkJJTkc6IFwiZ3JhYmJpbmdcIixcbiAgTk9ORTogXCJcIlxufTtcbmNvbnN0IEtFWV9ESVJFQ1RJT04gPSBbXCJMRUZUXCIsIFwiVVBcIiwgXCJSSUdIVFwiLCBcIkRPV05cIl07XG52YXIgRElSRUNUSU9OX0tFWV9DT0RFO1xuKGZ1bmN0aW9uIChESVJFQ1RJT05fS0VZX0NPREUpIHtcbiAgRElSRUNUSU9OX0tFWV9DT0RFW0RJUkVDVElPTl9LRVlfQ09ERVtcIkxFRlRcIl0gPSAzN10gPSBcIkxFRlRcIjtcbiAgRElSRUNUSU9OX0tFWV9DT0RFW0RJUkVDVElPTl9LRVlfQ09ERVtcIlVQXCJdID0gMzhdID0gXCJVUFwiO1xuICBESVJFQ1RJT05fS0VZX0NPREVbRElSRUNUSU9OX0tFWV9DT0RFW1wiUklHSFRcIl0gPSAzOV0gPSBcIlJJR0hUXCI7XG4gIERJUkVDVElPTl9LRVlfQ09ERVtESVJFQ1RJT05fS0VZX0NPREVbXCJET1dOXCJdID0gNDBdID0gXCJET1dOXCI7XG59KShESVJFQ1RJT05fS0VZX0NPREUgfHwgKERJUkVDVElPTl9LRVlfQ09ERSA9IHt9KSk7XG5jb25zdCBTUEFDRV9LRVlfQ09ERSA9IDMyO1xuY29uc3QgRElSRUNUSU9OX0tFWV9OQU1FID0ge1xuICBMRUZUOiBcIkFycm93TGVmdFwiLFxuICBVUDogXCJBcnJvd1VwXCIsXG4gIFJJR0hUOiBcIkFycm93UmlnaHRcIixcbiAgRE9XTjogXCJBcnJvd0Rvd25cIlxufTtcbmNvbnN0IFNQQUNFX0tFWV9OQU1FID0gXCIgXCI7XG5jb25zdCBGVUxMU0NSRUVOX1JFUVVFU1QgPSBbXCJyZXF1ZXN0RnVsbHNjcmVlblwiLCBcIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuXCIsIFwid2Via2l0UmVxdWVzdEZ1bGxTY3JlZW5cIiwgXCJ3ZWJraXRDYW5jZWxGdWxsU2NyZWVuXCIsIFwibW96UmVxdWVzdEZ1bGxTY3JlZW5cIiwgXCJtc1JlcXVlc3RGdWxsc2NyZWVuXCJdO1xuY29uc3QgRlVMTFNDUkVFTl9FTEVNRU5UID0gW1wiZnVsbHNjcmVlbkVsZW1lbnRcIiwgXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiLCBcIndlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudFwiLCBcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCIsIFwibXNGdWxsc2NyZWVuRWxlbWVudFwiXTtcbmNvbnN0IEZVTExTQ1JFRU5fRVhJVCA9IFtcImV4aXRGdWxsc2NyZWVuXCIsIFwid2Via2l0RXhpdEZ1bGxzY3JlZW5cIiwgXCJ3ZWJraXRDYW5jZWxGdWxsU2NyZWVuXCIsIFwibW96Q2FuY2VsRnVsbFNjcmVlblwiLCBcIm1zRXhpdEZ1bGxzY3JlZW5cIl07XG5jb25zdCBGVUxMU0NSRUVOX0NIQU5HRSA9IFtcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsIFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLCBcIk1TRnVsbHNjcmVlbkNoYW5nZVwiXTtcblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIERlZmF1bHQgY2xhc3MgbmFtZXNcclxuICogQGtvIOq4sOuzuCDtgbTrnpjsiqQg7J2066aE65OkXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cbmNvbnN0IERFRkFVTFRfQ0xBU1MgPSB7XG4gIENPTlRBSU5FUjogXCJ2aWV3MzYwLWNvbnRhaW5lclwiLFxuICBDQU5WQVM6IFwidmlldzM2MC1jYW52YXNcIixcbiAgQ1RYX0xPU1Q6IFwidmlldzM2MC1jdHgtbG9zdFwiLFxuICBJTl9WUjogXCJ2aWV3MzYwLXZyLXByZXNlbnRpbmdcIixcbiAgSE9UU1BPVF9DT05UQUlORVI6IFwidmlldzM2MC1ob3RzcG90c1wiLFxuICBIT1RTUE9UOiBcInZpZXczNjAtaG90c3BvdFwiLFxuICBIT1RTUE9UX1ZJU0lCTEU6IFwidmlldzM2MC1ob3RzcG90LXZpc2libGVcIixcbiAgSE9UU1BPVF9GTElQX1g6IFwidmlldzM2MC1ob3RzcG90LWZsaXAteFwiLFxuICBIT1RTUE9UX0ZMSVBfWTogXCJ2aWV3MzYwLWhvdHNwb3QtZmxpcC15XCJcbn07XG4vKipcclxuICogRXZlbnQgbmFtZXNcclxuICogQGtvIOydtOuypO2KuCDsnbTrpoTrk6RcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCBWaWV3MzYwLCB7IEVWRU5UUyB9IGZyb20gXCJAZWdqcy92aWV3MzYwXCI7XHJcbiAqXHJcbiAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3MzYwKFwiI2VsX2lkXCIpO1xyXG4gKlxyXG4gKiB2aWV3ZXIub24oRVZFTlRTLlJFQURZLCBldnQgPT4ge1xyXG4gKiAgIGNvbnNvbGUubG9nKFwiVmlldzM2MCBpcyByZWFkeSFcIik7XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXG5jb25zdCBFVkVOVFMgPSB7XG4gIFJFQURZOiBcInJlYWR5XCIsXG4gIExPQURfU1RBUlQ6IFwibG9hZFN0YXJ0XCIsXG4gIExPQUQ6IFwibG9hZFwiLFxuICBQUk9KRUNUSU9OX0NIQU5HRTogXCJwcm9qZWN0aW9uQ2hhbmdlXCIsXG4gIFJFU0laRTogXCJyZXNpemVcIixcbiAgQkVGT1JFX1JFTkRFUjogXCJiZWZvcmVSZW5kZXJcIixcbiAgUkVOREVSOiBcInJlbmRlclwiLFxuICBJTlBVVF9TVEFSVDogXCJpbnB1dFN0YXJ0XCIsXG4gIElOUFVUX0VORDogXCJpbnB1dEVuZFwiLFxuICBWSUVXX0NIQU5HRTogXCJ2aWV3Q2hhbmdlXCIsXG4gIFNUQVRJQ19DTElDSzogXCJzdGF0aWNDbGlja1wiLFxuICBWUl9TVEFSVDogXCJ2clN0YXJ0XCIsXG4gIFZSX0VORDogXCJ2ckVuZFwiXG59O1xuLyoqXHJcbiAqIENvbGxlY3Rpb24gb2YgcHJlZGVmaW5lZCBlYXNpbmcgZnVuY3Rpb25zXHJcbiAqIEBrbyDrr7jrpqwg7KCV7J2Y65CcIGVhc2luZyDtlajsiJjrk6RcclxuICovXG5jb25zdCBFQVNJTkcgPSB7XG4gIExJTkVBUjogeCA9PiB4LFxuICBTSU5FX1dBVkU6IHggPT4gTWF0aC5zaW4oeCAqIE1hdGguUEkgKiAyKSxcbiAgRUFTRV9PVVRfQ1VCSUM6IHggPT4gMSAtIE1hdGgucG93KDEgLSB4LCAzKSxcbiAgRUFTRV9PVVRfQk9VTkNFOiB4ID0+IHtcbiAgICBjb25zdCBuMSA9IDcuNTYyNTtcbiAgICBjb25zdCBkMSA9IDIuNzU7XG4gICAgaWYgKHggPCAxIC8gZDEpIHtcbiAgICAgIHJldHVybiBuMSAqIHggKiB4O1xuICAgIH0gZWxzZSBpZiAoeCA8IDIgLyBkMSkge1xuICAgICAgcmV0dXJuIG4xICogKHggLT0gMS41IC8gZDEpICogeCArIDAuNzU7XG4gICAgfSBlbHNlIGlmICh4IDwgMi41IC8gZDEpIHtcbiAgICAgIHJldHVybiBuMSAqICh4IC09IDIuMjUgLyBkMSkgKiB4ICsgMC45Mzc1O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbjEgKiAoeCAtPSAyLjYyNSAvIGQxKSAqIHggKyAwLjk4NDM3NTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfYTtcbmNvbnN0IENBTUVSQV9FVkVOVFMgPSB7XG4gIENIQU5HRTogXCJjaGFuZ2VcIixcbiAgQU5JTUFUSU9OX0VORDogXCJhbmltYXRpb25FbmRcIlxufTtcbmNvbnN0IE9CSkVDVF8zRF9FVkVOVFMgPSB7XG4gIFVQREFURTogXCJ1cGRhdGVcIlxufTtcbmNvbnN0IENPTlRST0xfRVZFTlRTID0ge1xuICBJTlBVVF9TVEFSVDogXCJpbnB1dFN0YXJ0XCIsXG4gIENIQU5HRTogXCJjaGFuZ2VcIixcbiAgSU5QVVRfRU5EOiBcImlucHV0RW5kXCIsXG4gIEVOQUJMRTogXCJlbmFibGVcIixcbiAgRElTQUJMRTogXCJkaXNhYmxlXCIsXG4gIFNUQVRJQ19DTElDSzogXCJzdGF0aWNDbGlja1wiXG59O1xuY29uc3QgREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODA7XG5jb25zdCBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbmNvbnN0IERFRkFVTFRfRUFTSU5HID0gRUFTSU5HLkVBU0VfT1VUX0NVQklDO1xuY29uc3QgREVGQVVMVF9BTklNQVRJT05fRFVSQVRJT04gPSAzMDA7XG5jb25zdCBJTkZJTklURV9SQU5HRSA9IHtcbiAgbWluOiAtSW5maW5pdHksXG4gIG1heDogSW5maW5pdHlcbn07XG5jb25zdCBERUZBVUxUX1BJVENIX1JBTkdFID0ge1xuICBtaW46IC05MCxcbiAgbWF4OiA5MFxufTtcbmNvbnN0IERFRkFVTFRfWk9PTV9SQU5HRSA9IHtcbiAgbWluOiAwLjYsXG4gIG1heDogMTBcbn07XG52YXIgUk9UQVRFO1xuKGZ1bmN0aW9uIChST1RBVEUpIHtcbiAgUk9UQVRFW1JPVEFURVtcIlpFUk9cIl0gPSAwXSA9IFwiWkVST1wiO1xuICBST1RBVEVbUk9UQVRFW1wiQ1dfOTBcIl0gPSAxXSA9IFwiQ1dfOTBcIjtcbiAgUk9UQVRFW1JPVEFURVtcIkNDV185MFwiXSA9IDJdID0gXCJDQ1dfOTBcIjtcbiAgUk9UQVRFW1JPVEFURVtcIkNXXzE4MFwiXSA9IDNdID0gXCJDV18xODBcIjtcbn0pKFJPVEFURSB8fCAoUk9UQVRFID0ge30pKTtcbi8vIEN1c3RvbSBldmVudCBuYW1lIGZvciB2aWRlbyB0aW1lIGNoYW5nZVxuY29uc3QgVklERU9fVElNRV9DSEFOR0VfRVZFTlQgPSBcInZpZXczNjB2aWRlb3RpbWVjaGFuZ2VcIjtcbmNvbnN0IFNWR19OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBTRVNTSU9OX1ZSID0gXCJpbW1lcnNpdmUtdnJcIjtcbmNvbnN0IFhSX1JFRkVSRU5DRV9TUEFDRSA9IFwibG9jYWxcIjtcbmNvbnN0IEVQU0lMT04gPSAoX2EgPSBOdW1iZXIuRVBTSUxPTikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMi4yMjA0NDYwNDkyNTAzMTNlLTE2O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG5jb25zdCBpc1N0cmluZyA9IHZhbCA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuY29uc3QgaXNFbGVtZW50ID0gdmFsID0+ICEhdmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG5jb25zdCBjcmVhdGVFbGVtZW50ID0gKGNsYXNzTmFtZSwgdGFnID0gRUxfRElWKSA9PiB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIHJldHVybiBlbDtcbn07XG5jb25zdCBnZXROdWxsYWJsZUVsZW1lbnQgPSAoZWwsIHBhcmVudCkgPT4ge1xuICBsZXQgdGFyZ2V0RWwgPSBudWxsO1xuICBpZiAoaXNTdHJpbmcoZWwpKSB7XG4gICAgY29uc3QgcGFyZW50RWwgPSBwYXJlbnQgPyBwYXJlbnQgOiBkb2N1bWVudDtcbiAgICBjb25zdCBxdWVyeVJlc3VsdCA9IHBhcmVudEVsLnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghcXVlcnlSZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0YXJnZXRFbCA9IHF1ZXJ5UmVzdWx0O1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChlbCkpIHtcbiAgICB0YXJnZXRFbCA9IGVsO1xuICB9XG4gIHJldHVybiB0YXJnZXRFbDtcbn07XG5jb25zdCBnZXRFbGVtZW50ID0gKGVsLCBwYXJlbnQpID0+IHtcbiAgY29uc3QgdGFyZ2V0RWwgPSBnZXROdWxsYWJsZUVsZW1lbnQoZWwsIHBhcmVudCk7XG4gIGlmICghdGFyZ2V0RWwpIHtcbiAgICBpZiAoaXNTdHJpbmcoZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgVmlldzM2MEVycm9yKEVSUk9SLk1FU1NBR0VTLkVMRU1FTlRfTk9UX0ZPVU5EKGVsKSwgRVJST1IuQ09ERVMuRUxFTUVOVF9OT1RfRk9VTkQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVmlldzM2MEVycm9yKEVSUk9SLk1FU1NBR0VTLldST05HX1RZUEUoZWwsIFtcIkhUTUxFbGVtZW50XCIsIFwic3RyaW5nXCJdKSwgRVJST1IuQ09ERVMuV1JPTkdfVFlQRSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRFbDtcbn07XG5jb25zdCBmaW5kQ2FudmFzID0gKHJvb3QsIHNlbGVjdG9yKSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IHJvb3QucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIGlmICghY2FudmFzKSB7XG4gICAgdGhyb3cgbmV3IFZpZXczNjBFcnJvcihFUlJPUi5NRVNTQUdFUy5DQU5WQVNfTk9UX0ZPVU5ELCBFUlJPUi5DT0RFUy5DQU5WQVNfTk9UX0ZPVU5EKTtcbiAgfVxuICByZXR1cm4gY2FudmFzO1xufTtcbmNvbnN0IHJhbmdlID0gZW5kID0+IHtcbiAgaWYgKCFlbmQgfHwgZW5kIDw9IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIEFycmF5LmFwcGx5KDAsIEFycmF5KGVuZCkpLm1hcCgodW5kZWYsIGlkeCkgPT4gaWR4KTtcbn07XG5jb25zdCBjbGFtcCA9ICh4LCBtaW4sIG1heCkgPT4gTWF0aC5tYXgoTWF0aC5taW4oeCwgbWF4KSwgbWluKTtcbi8vIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxuY29uc3QgbGVycCA9IChhLCBiLCB0KSA9PiB7XG4gIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xufTtcbmNvbnN0IGNpcmN1bGF0ZSA9ICh2YWwsIG1pbiwgbWF4KSA9PiB7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhtYXggLSBtaW4pO1xuICBpZiAodmFsIDwgbWluKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG1pbiAtIHZhbCkgJSBzaXplO1xuICAgIHZhbCA9IG1heCAtIG9mZnNldDtcbiAgfSBlbHNlIGlmICh2YWwgPiBtYXgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSAodmFsIC0gbWF4KSAlIHNpemU7XG4gICAgdmFsID0gbWluICsgb2Zmc2V0O1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuY29uc3QgZmluZEluZGV4ID0gKGFycmF5LCBjaGVja2VyKSA9PiB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGFycmF5Lmxlbmd0aDsgaWR4KyspIHtcbiAgICBpZiAoY2hlY2tlcihhcnJheVtpZHhdKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcbmNvbnN0IGdldE9iamVjdE9wdGlvbiA9IHZhbCA9PiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiID8gdmFsIDoge307XG5jb25zdCB0b1ZlcnRpY2FsRm92ID0gKGZvdlJhZGlhbiwgYXNwZWN0KSA9PiB7XG4gIHJldHVybiBNYXRoLmF0YW4oTWF0aC50YW4oZm92UmFkaWFuICogMC41KSAvIGFzcGVjdCkgKiAyO1xufTtcbmNvbnN0IHJlb3JkZXJDdWJlID0gKGFyciwgb3JkZXIsIGRlZmF1bHRPcmRlciA9IFwiUkxVREZCXCIpID0+IHtcbiAgcmV0dXJuIGRlZmF1bHRPcmRlci5zcGxpdChcIlwiKS5tYXAoZmFjZSA9PiBvcmRlci5pbmRleE9mKGZhY2UpKS5tYXAoaW5kZXggPT4gYXJyW2luZGV4XSk7XG59O1xuY29uc3QgaXNGdWxsc2NyZWVuID0gKCkgPT4ge1xuICBpZiAoIWRvY3VtZW50KSByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3Qga2V5IG9mIEZVTExTQ1JFRU5fRUxFTUVOVCkge1xuICAgIGlmIChkb2N1bWVudFtrZXldKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3Qgc2Vuc29yQ2FuQmVFbmFibGVkSU9TID0gKCkgPT4ge1xuICByZXR1cm4gd2luZG93LmlzU2VjdXJlQ29udGV4dCAmJiAhIURldmljZU1vdGlvbkV2ZW50ICYmIFwicmVxdWVzdFBlcm1pc3Npb25cIiBpbiBEZXZpY2VNb3Rpb25FdmVudDtcbn07XG5jb25zdCBoZm92VG9ab29tID0gKGJhc2VGb3YsIGZvdikgPT4ge1xuICBjb25zdCByZW5kZXJpbmdXaWR0aCA9IE1hdGgudGFuKERFR19UT19SQUQgKiBiYXNlRm92ICogMC41KTtcbiAgY29uc3Qgem9vbWVkV2lkdGggPSBNYXRoLnRhbihERUdfVE9fUkFEICogZm92ICogMC41KTtcbiAgcmV0dXJuIHJlbmRlcmluZ1dpZHRoIC8gem9vbWVkV2lkdGg7XG59O1xuY29uc3QgZXVsZXJUb1F1YXQgPSAob3V0LCB5YXcsIHBpdGNoLCByb2xsKSA9PiB7XG4gIHF1YXQuaWRlbnRpdHkob3V0KTtcbiAgY29uc3QgcGl0Y2hUaHJlc2hvbGQgPSAwLjAxO1xuICBjb25zdCBwaXRjaENsYW1wZWQgPSBjbGFtcChwaXRjaCwgLTkwICsgcGl0Y2hUaHJlc2hvbGQsIDkwIC0gcGl0Y2hUaHJlc2hvbGQpO1xuICBxdWF0LnJvdGF0ZVkob3V0LCBvdXQsIHlhdyAqIERFR19UT19SQUQpO1xuICBxdWF0LnJvdGF0ZVgob3V0LCBvdXQsIHBpdGNoQ2xhbXBlZCAqIERFR19UT19SQUQpO1xuICBxdWF0LnJvdGF0ZVoob3V0LCBvdXQsIHJvbGwgKiBERUdfVE9fUkFEKTtcbiAgcmV0dXJuIG91dDtcbn07XG4vKipcclxuICogRXh0cmFjdCBldWxlciBhbmdsZXMgZnJvbSB0aGUgcXVhdGVybmlvbiwgZXhjZXB0IHJvbGwoei1heGlzIHJvdGF0aW9uKVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xuY29uc3QgcXVhdFRvRXVsZXIgPSBxdWF0ZXJuaW9uID0+IHtcbiAgY29uc3QgeCA9IHF1YXRlcm5pb25bMF07XG4gIGNvbnN0IHkgPSBxdWF0ZXJuaW9uWzFdO1xuICBjb25zdCB6ID0gcXVhdGVybmlvblsyXTtcbiAgY29uc3QgdyA9IHF1YXRlcm5pb25bM107XG4gIGNvbnN0IHgyID0geCAqIHg7XG4gIGNvbnN0IHkyID0geSAqIHk7XG4gIGNvbnN0IHoyID0geiAqIHo7XG4gIGNvbnN0IHcyID0gdyAqIHc7XG4gIGNvbnN0IHVuaXQgPSB4MiArIHkyICsgejIgKyB3MjtcbiAgY29uc3QgdGVzdCA9IHggKiB3IC0geSAqIHo7XG4gIGxldCBwaXRjaCwgeWF3O1xuICBpZiAodGVzdCA+IDAuNDk5OTk1ICogdW5pdCkge1xuICAgIC8vIHNpbmd1bGFyaXR5IGF0IHRoZSBub3J0aCBwb2xlXG4gICAgcGl0Y2ggPSBNYXRoLlBJIC8gMjtcbiAgICB5YXcgPSAyICogTWF0aC5hdGFuMih5LCB4KTtcbiAgfSBlbHNlIGlmICh0ZXN0IDwgLTAuNDk5OTk1ICogdW5pdCkge1xuICAgIC8vIHNpbmd1bGFyaXR5IGF0IHRoZSBzb3V0aCBwb2xlXG4gICAgcGl0Y2ggPSAtTWF0aC5QSSAvIDI7XG4gICAgeWF3ID0gLTIgKiBNYXRoLmF0YW4yKHksIHgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpZXcgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSk7XG4gICAgY29uc3QgdXAgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG4gICAgdmVjMy50cmFuc2Zvcm1RdWF0KHZpZXcsIHZpZXcsIHF1YXRlcm5pb24pO1xuICAgIHZlYzMudHJhbnNmb3JtUXVhdCh1cCwgdXAsIHF1YXRlcm5pb24pO1xuICAgIGNvbnN0IHZpZXdYWiA9IE1hdGguc3FydCh2aWV3WzBdICogdmlld1swXSArIHZpZXdbMl0gKiB2aWV3WzJdKTtcbiAgICBwaXRjaCA9IE1hdGguYXRhbjIoLXZpZXdbMV0sIHZpZXdYWik7XG4gICAgeWF3ID0gTWF0aC5hdGFuMih2aWV3WzBdLCB2aWV3WzJdKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBpdGNoOiBjbGFtcChwaXRjaCAqIFJBRF9UT19ERUcsIC05MCwgOTApLFxuICAgIHlhdzogY2lyY3VsYXRlKHlhdyAqIFJBRF9UT19ERUcsIDAsIDM2MClcbiAgfTtcbn07XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogSW50ZXJwb2xhdG9yIGJldHdlZW4gdHdvIHZhbHVlcyB3aXRoIGR1cmF0aW9uXHJcbiAqIEBrbyDtirnsoJUg7Iuc6rCE64+Z7JWIIOuRkCDqsJLsnYQg67O06rCE7ZW07KO864qUIOuztOqwhOq4sFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBNb3Rpb24ge1xuICAvKipcclxuICAgKiBDdXJyZW50IGludGVycG9sYXRlZCB2YWx1ZVxyXG4gICAqIEBrbyDtmITsnqwg67O06rCE65CcIOqwklxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgdmFsKCkge1xuICAgIHJldHVybiB0aGlzLl92YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhcnQoZnJvbSkgdmFsdWUgb2YgaW50ZXJwb2xhdGlvblxyXG4gICAqIEBrbyDrs7TqsIQg7Iuc7J6RIOqwklxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xuICB9XG4gIC8qKlxyXG4gICAqIEVuZCh0bykgdmFsdWUgb2YgaW50ZXJwb2xhdGlvblxyXG4gICAqIEBrbyDrs7TqsIQg64GdIOqwklxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmQ7XG4gIH1cbiAgLyoqXHJcbiAgICogSW50ZXJwb2xhdGlvbiBwcm9ncmVzcyB2YWx1ZSAoMCB+IDEpXHJcbiAgICogQGtvIO2YhOyerCDrs7TqsIQg7KeE7ZaJ7KCV64+EICgwIH4gMSlcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IHByb2dyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgfVxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBpbnRlcnBvbGF0aW9uIGlzIGluIGFjdGl2ZSBzdGF0ZS5cclxuICAgKiBAa28g67O06rCEIOynhO2WieykkeyduOyngCDsl6zrtoAuIGB0cnVlYOydvCDqsr3smrAg67O06rCE7J20IOynhO2WieykkeyeheuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGFjdGl2YXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZhdGVkO1xuICB9XG4gIC8qKlxyXG4gICAqIER1cmF0aW9uIG9mIHRoZSBpbnRlcnBvbGF0aW9uXHJcbiAgICogQGtvIOuztOqwhO2VoCDsi5zqsIRcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgfVxuICBzZXQgZHVyYXRpb24odmFsKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBsb29wIGludGVycG9sYXRpb24gb24gZmluaXNoXHJcbiAgICogQGtvIOuztOqwhOydtCDrgZ3rgpwg7J207ZuE7JeQIOuLpOyLnCDsi5zsnpHtlaDsp4Ag7Jes67aAXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBsb29wKCkge1xuICAgIHJldHVybiB0aGlzLl9sb29wO1xuICB9XG4gIHNldCBsb29wKHZhbCkge1xuICAgIHRoaXMuX2xvb3AgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogUmFuZ2Ugb2YgdGhlIGludGVycG9sYXRpb25cclxuICAgKiBAa28g67O06rCEIOuylOychFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgcmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlO1xuICB9XG4gIC8qKlxyXG4gICAqIEVhc2luZyBmdW5jdGlvbiBvZiB0aGUgaW50ZXJwb2xhdGlvblxyXG4gICAqIEBrbyDrs7TqsITsl5Ag7IKs7Jqp65CY64qUIGVhc2luZyBmdW5jdGlvblxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgZWFzaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9lYXNpbmc7XG4gIH1cbiAgc2V0IGVhc2luZyh2YWwpIHtcbiAgICB0aGlzLl9lYXNpbmcgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBpbnN0YW5jZS5cclxuICAgKiBAa28g7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKiBAcGFyYW0gb3B0aW9ucy5kdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgaW50ZXJwb2xhdGlvbiB7QGtvIOuztOqwhO2VoCDsi5zqsIR9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMubG9vcCBXaGV0aGVyIHRvIGxvb3AgaW50ZXJwb2xhdGlvbiBvbiBmaW5pc2gge0BrbyDrs7TqsITsnbQg64Gd64KcIOydtO2bhOyXkCDri6Tsi5wg7Iuc7J6R7ZWg7KeAIOyXrOu2gH1cclxuICAgKiBAcGFyYW0gb3B0aW9ucy5yYW5nZSBSYW5nZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiB7QGtvIOuztOqwhCDrspTsnIR9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMubG9vcCBFYXNpbmcgZnVuY3Rpb24gb2YgdGhlIGludGVycG9sYXRpb24ge0BrbyDrs7TqsITsl5Ag7IKs7Jqp65CY64qUIGVhc2luZyBmdW5jdGlvbn1cclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGR1cmF0aW9uID0gREVGQVVMVF9BTklNQVRJT05fRFVSQVRJT04sXG4gICAgbG9vcCA9IGZhbHNlLFxuICAgIHJhbmdlID0ge1xuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxXG4gICAgfSxcbiAgICBlYXNpbmcgPSBERUZBVUxUX0VBU0lOR1xuICB9ID0ge30pIHtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuX2xvb3AgPSBsb29wO1xuICAgIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgdGhpcy5fZWFzaW5nID0gZWFzaW5nO1xuICAgIHRoaXMuX2FjdGl2YXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVzZXQoMCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIG1vdGlvbiBhbmQgcHJvZ3Jlc3MgaXQgYnkgZ2l2ZW4gZGVsdGFUaW1lXHJcbiAgICogQGtvIOyjvOyWtOynhCBkZWx0YVRpbWXrp4ztgbwg67O06rCE7J2EIOynhO2Wie2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gZGVsdGFUaW1lIC0gbnVtYmVyIG9mIG1pbGlzZWMgdG8gdXBkYXRlIG1vdGlvbiB7QGtvIOuztOqwhOydhCDsp4TtlontlaAg7Iuc6rCELCDrsIDrpqzstIgg64uo7JyEfVxyXG4gICAqIEByZXR1cm5zIERpZmZlcmVuY2UoZGVsdGEpIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBsYXN0IHVwZGF0ZS4ge0BrbyDsp4Drgpwg7JeF642w7J207Yq4IOydtO2bhOydmCDqsJIg67OA7ZmU65+JfVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmF0ZWQpIHtcbiAgICAgIHRoaXMuX3ZhbCA9IHRoaXMuX2VuZDtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuX2VuZDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLl92YWw7XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgbmV4dFByb2dyZXNzID0gdGhpcy5fcHJvZ3Jlc3MgKyBkZWx0YVRpbWUgLyBkdXJhdGlvbjtcbiAgICB0aGlzLl9wcm9ncmVzcyA9IGxvb3AgPyBjaXJjdWxhdGUobmV4dFByb2dyZXNzLCAwLCAxKSA6IGNsYW1wKG5leHRQcm9ncmVzcywgMCwgMSk7XG4gICAgY29uc3QgZWFzZWRQcm9ncmVzcyA9IHRoaXMuX2Vhc2luZyh0aGlzLl9wcm9ncmVzcyk7XG4gICAgdGhpcy5fdmFsID0gbGVycChzdGFydCwgZW5kLCBlYXNlZFByb2dyZXNzKTtcbiAgICBpZiAoIWxvb3AgJiYgdGhpcy5fcHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgdGhpcy5fYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWwgLSBwcmV2O1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBgc3RhcnRgLCBgZW5kYCB0byB0aGUgZ2l2ZW4gdmFsdWUgYW5kIHNldCBgcHJvZ3Jlc3NgIHRvIDAuXHJcbiAgICogQGtvIOyjvOyWtOynhCDqsJLsnLzroZwg7Iuc7J6RIOyngOygkCwg64GdIOyngOygkOydhCDstIjquLDtmZTtlZjqs6AgcHJvZ3Jlc3PrpbwgMOycvOuhnCDshLjtjIXtlanri4jri6QuXHJcbiAgICogQHBhcmFtIGRlZmF1bHRWYWwgLSBWYWx1ZSB0byByZXNldCB7QGtvIOy0iOq4sO2ZlO2VoCDqsJJ9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIHJlc2V0KGRlZmF1bHRWYWwpIHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIGNvbnN0IHZhbCA9IGNsYW1wKGRlZmF1bHRWYWwsIHJhbmdlLm1pbiwgcmFuZ2UubWF4KTtcbiAgICB0aGlzLl9zdGFydCA9IHZhbDtcbiAgICB0aGlzLl9lbmQgPSB2YWw7XG4gICAgdGhpcy5fdmFsID0gdmFsO1xuICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcbiAgICB0aGlzLl9hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBBZGQgZGVsdGEgdG8gc3RhcnQgJiBlbmQgYW5kIGN1cnJlbnQgdmFsdWUuXHJcbiAgICogQGtvIO2YhOyerCAmIOuBnSDrsI8g7ZiE7J6sIOqwkuyXkCDso7zslrTsp4Qg6rCS7J2EIOuNlO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gZGVsdGEgLSBEZWx0YSB2YWx1ZSB0byBhZGQge0BrbyDstpTqsIDtlaAg6rCSfVxyXG4gICAqL1xuICBhZGQoZGVsdGEpIHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHRoaXMuX3N0YXJ0ID0gY2xhbXAodGhpcy5fc3RhcnQgKyBkZWx0YSwgcmFuZ2UubWluLCByYW5nZS5tYXgpO1xuICAgIHRoaXMuX2VuZCA9IGNsYW1wKHRoaXMuX2VuZCArIGRlbHRhLCByYW5nZS5taW4sIHJhbmdlLm1heCk7XG4gICAgdGhpcy5fdmFsID0gY2xhbXAodGhpcy5fdmFsICsgZGVsdGEsIHJhbmdlLm1pbiwgcmFuZ2UubWF4KTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgY3VycmVudCB2YWx1ZSB0byBzdGFydCwgYW5kIGVuZCB0byBjdXJyZW50IHZhbHVlICsgZGVsdGEsIHRoZW4gcmVzZXQgcHJvZ3Jlc3MgdG8gMC5cclxuICAgKiBAa28g7ZiE7J6sIOqwkuydhCDsi5zsnpEg7KeA7KCQ7Jy866GcLCDqt7jsl5DshJwgZGVsdGHrp4ztgbwg7LaU6rCA65CcIOqwkuydhCDrgZ3soJDsnLzroZwg7ZWY6rOgIHByb2dyZXNz66W8IDDsnLzroZwg6rCx7Iug7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBkZWx0YSAtIERlbHRhIHZhbHVlIHRvIGFkZCB7QGtvIOy2lOqwgO2VoCDqsJJ9XHJcbiAgICovXG4gIHNldE5ld0VuZEJ5RGVsdGEoZGVsdGEpIHtcbiAgICBjb25zdCByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fdmFsO1xuICAgIHRoaXMuX2VuZCA9IGNsYW1wKHRoaXMuX2VuZCArIGRlbHRhLCByYW5nZS5taW4sIHJhbmdlLm1heCk7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMuX2FjdGl2YXRlZCA9IHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IG5ldyByYW5nZSBvZiB0aGUgaW50ZXJwb2xhdGlvbi5cclxuICAgKiBAa28g67O06rCE7J2YIOuylOychOulvCDrs4Dqsr3tlanri4jri6QuXHJcbiAgICogQHBhcmFtIG1pbiAtIE5ldyBtaW5pbXVtIHJhbmdlIHtAa28g67OA6rK97ZWgIOuylOychOydmCDstZzshozqsJJ9XHJcbiAgICogQHBhcmFtIG1heCAtIE5ldyBtYXhpbXVtIHJhbmdlIHtAa28g67OA6rK97ZWgIOuylOychOydmCDstZzrjIDqsJJ9XHJcbiAgICovXG4gIHNldFJhbmdlKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5fc3RhcnQgPSBjbGFtcCh0aGlzLl9zdGFydCwgbWluLCBtYXgpO1xuICAgIHRoaXMuX2VuZCA9IGNsYW1wKHRoaXMuX2VuZCwgbWluLCBtYXgpO1xuICAgIHRoaXMuX3JhbmdlID0ge1xuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfTtcbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogQW5pbWF0aW9uIG9mIHRoZSB7QGxpbmsgQ2FtZXJhfVxyXG4gKiBAaW50ZXJuYWxcclxuICogQGtvIHtAbGluayBDYW1lcmF97J2YIOyVoOuLiOuplOydtOyFmFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBDYW1lcmFBbmltYXRpb24ge1xuICAvKipcclxuICAgKiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICogQGtvIOyVoOuLiOuplOydtOyFmCDsnqzsg53si5zqsIRcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb3Rpb24uZHVyYXRpb247XG4gIH1cbiAgc2V0IGR1cmF0aW9uKHZhbCkge1xuICAgIHRoaXMuX21vdGlvbi5kdXJhdGlvbiA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBFYXNpbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvblxyXG4gICAqIEBrbyDslaDri4jrqZTsnbTshZjsnZggZWFzaW5nIGZ1bmN0aW9uXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBlYXNpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdGlvbi5lYXNpbmc7XG4gIH1cbiAgc2V0IGVhc2luZyh2YWwpIHtcbiAgICB0aGlzLl9tb3Rpb24uZWFzaW5nID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2VcclxuICAgKiBAa28g7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIGNhbWVyYSAtIENhbWVyYSB0byBhbmltYXRlIHtAa28g7JWg64uI66mU7J207IWY7J2EIOyggeyaqe2VoCDsubTrqZTrnbx9XHJcbiAgICogQHBhcmFtIGZyb20gLSBTdGFydCBwb3NlIHtAa28g7JWg64uI66mU7J207IWY7J20IOyLnOyekSDsi5zsoJDsnZgg7Lm066mU65287J2YIO2ajOyghCDrsI8g7KSMfVxyXG4gICAqIEBwYXJhbSB0byAtIEVuZCBwb3NlIHtAa28g7JWg64uI66mU7J207IWY7J20IOuBneuCrOydhCDrlYwg7Lm066mU65287J2YIO2ajOyghCDrsI8g7KSMfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKiBAcGFyYW0gb3B0aW9ucy5kdXJhdGlvbiAtIEFuaW1hdGlvbiBkdXJhdGlvbiB7QGtvIOyVoOuLiOuplOydtOyFmCDsnqzsg50g7Iuc6rCEfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zLmVhc2luZyAtIEFuaW1hdGlvbiBlYXNpbmcgZnVuY3Rpb24ge0BrbyDslaDri4jrqZTsnbTshZggZWFzaW5nIGZ1bmN0aW9ufVxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW1lcmEsIGZyb20sIHRvLCB7XG4gICAgZHVyYXRpb24gPSBERUZBVUxUX0FOSU1BVElPTl9EVVJBVElPTixcbiAgICBlYXNpbmcgPSBERUZBVUxUX0VBU0lOR1xuICB9ID0ge30pIHtcbiAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5fbW90aW9uID0gbmV3IE1vdGlvbih7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2luZyxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9maW5pc2hQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9maW5pc2ggPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIC8vIEVuYWJsZSBtb3Rpb25cbiAgICB0aGlzLl9tb3Rpb24uc2V0TmV3RW5kQnlEZWx0YSgxKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZWQgb24gYW5pbWF0aW9uIGVuZC5cclxuICAgKiBAa28g7JWg64uI66mU7J207IWYIOyerOyDneydtCDrgZ3rgqzsnYQg65WMIHJlc29sdmXrkJjripQgUHJvbWlzZeulvCDrsJjtmZjtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldEZpbmlzaFByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaFByb21pc2U7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuaW1hdGlvbiBieSBnaXZlbiBkZWx0YVRpbWUuXHJcbiAgICogQGtvIOyjvOyWtOynhCDsi5zqsITrp4ztgbwg7JWg64uI66mU7J207IWY7J2EIOyXheuNsOydtO2KuO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gZGVsdGFUaW1lIE51bWJlciBvZiBtaWxpc2VjIHRvIHVwZGF0ZSB7QGtvIOyXheuNsOydtO2KuO2VoCDsi5zqsIQsIOuwgOumrOy0iCDri6jsnIR9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBjb25zdCBtb3Rpb24gPSB0aGlzLl9tb3Rpb247XG4gICAgbW90aW9uLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgIC8vIFByb2dyZXNzIHRoYXQgZWFzaW5nIGlzIGFwcGxpZWRcbiAgICBjb25zdCBwcm9ncmVzcyA9IG1vdGlvbi52YWw7XG4gICAgY29uc3Qgcm90YXRpb24gPSBxdWF0LmNyZWF0ZSgpO1xuICAgIGNvbnN0IHpvb20gPSBsZXJwKGZyb20uem9vbSwgdG8uem9vbSwgcHJvZ3Jlc3MpO1xuICAgIHF1YXQuc2xlcnAocm90YXRpb24sIGZyb20ucm90YXRpb24sIHRvLnJvdGF0aW9uLCBwcm9ncmVzcyk7XG4gICAgY2FtZXJhLnJvdGF0ZShyb3RhdGlvbiwgem9vbSk7XG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcclxuICogQ2FtZXJhIGZvciBWaWV3MzYwXHJcbiAqIEBrbyBWaWV3MzYw7JqpIOy5tOuplOudvCDqtaztmITssrRcclxuICogQHZlcnNpb24gNC4wLjBcclxuICovXG5jbGFzcyBDYW1lcmEgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcclxuICAgKiBDYW1lcmEncyB3aWR0aCAvIGhlaWdodCByYXRpb1xyXG4gICAqIEBrbyDsubTrqZTrnbzsnZgg6rCA66GcIC8g7IS466GcIOu5hOycqFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xuICBnZXQgYXNwZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9hc3BlY3Q7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgY2FtZXJhJ3Mgcm90YXRpb24gY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGZyYW1lLlxyXG4gICAqIEBrbyDrp4jsp4Drp4kg7ZSE66CI7J6EIOydtO2bhOuhnCDsubTrqZTrnbzsnZgg7ZqM7KCE6rCS7J20IOuzgOqyveuQmOyXiOuKlOyngCDrgpjtg4DrgrTripQg7ZSM656Y6re4LlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xuICBnZXQgY2hhbmdlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlZDtcbiAgfVxuICAvKipcclxuICAgKiBAY29weSBWaWV3MzYwI3lhd1JhbmdlXHJcbiAgICovXG4gIGdldCB5YXdSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5pdGlhbFlhd1JhbmdlO1xuICB9XG4gIHNldCB5YXdSYW5nZSh2YWwpIHtcbiAgICB0aGlzLl9pbml0aWFsWWF3UmFuZ2UgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogQGNvcHkgVmlldzM2MCNwaXRjaFJhbmdlXHJcbiAgICovXG4gIGdldCBwaXRjaFJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbml0aWFsUGl0Y2hSYW5nZTtcbiAgfVxuICBzZXQgcGl0Y2hSYW5nZSh2YWwpIHtcbiAgICB0aGlzLl9pbml0aWFsUGl0Y2hSYW5nZSA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBAY29weSBWaWV3MzYwI3pvb21SYW5nZVxyXG4gICAqL1xuICBnZXQgem9vbVJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbml0aWFsWm9vbVJhbmdlO1xuICB9XG4gIHNldCB6b29tUmFuZ2UodmFsKSB7XG4gICAgdGhpcy5faW5pdGlhbFpvb21SYW5nZSA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlIG9mIENhbWVyYVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQ2FtZXJhIG9wdGlvbnMge0BrbyDsubTrqZTrnbwg7Ji17IWY65OkfVxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgaW5pdGlhbFlhdyxcbiAgICBpbml0aWFsUGl0Y2gsXG4gICAgaW5pdGlhbFpvb20sXG4gICAgeWF3UmFuZ2UsXG4gICAgcGl0Y2hSYW5nZSxcbiAgICB6b29tUmFuZ2UsXG4gICAgZm92XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMueWF3ID0gaW5pdGlhbFlhdztcbiAgICB0aGlzLnBpdGNoID0gaW5pdGlhbFBpdGNoO1xuICAgIHRoaXMuem9vbSA9IGluaXRpYWxab29tO1xuICAgIHRoaXMucm9sbE9mZnNldCA9IDA7XG4gICAgdGhpcy5pbml0aWFsWWF3ID0gaW5pdGlhbFlhdztcbiAgICB0aGlzLmluaXRpYWxQaXRjaCA9IGluaXRpYWxQaXRjaDtcbiAgICB0aGlzLmluaXRpYWxab29tID0gaW5pdGlhbFpvb207XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdGhpcy5hbmltYXRpb24gPSBudWxsO1xuICAgIHRoaXMuX3VwID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICAgIHRoaXMuX2FzcGVjdCA9IDE7XG4gICAgdGhpcy5faW5pdGlhbFlhd1JhbmdlID0geWF3UmFuZ2U7XG4gICAgdGhpcy5faW5pdGlhbFBpdGNoUmFuZ2UgPSBwaXRjaFJhbmdlO1xuICAgIHRoaXMuX2luaXRpYWxab29tUmFuZ2UgPSB6b29tUmFuZ2U7XG4gICAgdGhpcy5feWF3UmFuZ2UgPSB5YXdSYW5nZTtcbiAgICB0aGlzLl9waXRjaFJhbmdlID0gcGl0Y2hSYW5nZTtcbiAgICB0aGlzLl96b29tUmFuZ2UgPSB6b29tUmFuZ2U7XG4gICAgdGhpcy5xdWF0ZXJuaW9uID0gcXVhdC5jcmVhdGUoKTtcbiAgICB0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy52aWV3TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIHRoaXMuZm92ID0gZm92O1xuICAgIHRoaXMuX21heFJlbmRlckhlaWdodCA9IC0xO1xuICB9XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgaW5zdGFuY2UgYW5kIGRldGFjaCBhbGwgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICogQGtvIOyduOyKpO2EtOyKpOulvCDsgq3soJztlZjqs6Ag66qo65OgIOydtOuypO2KuCDrpqzsiqTrhIjrpbwg7IKt7KCc7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVmcmVzaCBpbnRlcm5hbCBzaXplIHZhbHVlLlxyXG4gICAqIEBrbyDrgrTrtoAg7YGs6riw6rCS7J2EIOqwseyLoO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gd2lkdGggLSBOZXcgd2lkdGgge0BrbyDrs4Dqsr3rkJwg64SI67mE6rCSfVxyXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBOZXcgaGVpZ2h0IHtAa28g67OA6rK965CcIOuGkuydtOqwkn1cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwcmV2QXNwZWN0ID0gdGhpcy5fYXNwZWN0O1xuICAgIHRoaXMuX2FzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGlmICh0aGlzLl9hc3BlY3QgIT09IHByZXZBc3BlY3QpIHtcbiAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENoYW5nZSBjYW1lcmEncyByb3RhdGlvbiB3aXRoIGV1bGVyIHZhbHVlcy5cclxuICAgKiBAa28g7Lm066mU6528IO2ajOyghOydhCDsmKTsnbzrn6wg6rCBIOuwqe2WpeycvOuhnCDrs4Dqsr3tlanri4jri6QuXHJcbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gUm90YXRpb24gdmFsdWVzIHtAa28g7ZqM7KCEIOqwkn1cclxuICAgKiBAcGFyYW0gcm90YXRpb24ueWF3IC0geWF3KHktYXhpcyByb3RhdGlvbikgdG8gbG9vayBhdCB7QGtvIOuwlOudvOuzvCB5YXcoeey2lSDtmozsoIQpIOqwkn1cclxuICAgKiBAcGFyYW0gcm90YXRpb24ucGl0Y2ggLSBwaXRjaCh4LWF4aXMgcm90YXRpb24pIHRvIGxvb2sgYXQge0BrbyDrsJTrnbzrs7wgcGl0Y2goeOy2lSDtmozsoIQpIOqwkn1cclxuICAgKiBAcGFyYW0gcm90YXRpb24uem9vbSAtIHpvb20gdmFsdWUgdG8gYXBwbHkge0BrbyDsoIHsmqntlaAg7Lm066mU6528IOykjCDqsJJ9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGxvb2tBdCh7XG4gICAgeWF3ID0gdGhpcy55YXcsXG4gICAgcGl0Y2ggPSB0aGlzLnBpdGNoLFxuICAgIHpvb20gPSB0aGlzLnpvb21cbiAgfSkge1xuICAgIGNvbnN0IHByZXZRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZSh0aGlzLnF1YXRlcm5pb24pO1xuICAgIGNvbnN0IHByZXZab29tID0gdGhpcy56b29tO1xuICAgIHRoaXMueWF3ID0gY2lyY3VsYXRlKHlhdywgMCwgMzYwKTtcbiAgICB0aGlzLnBpdGNoID0gY2xhbXAocGl0Y2gsIC05MCwgOTApO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5fdXBkYXRlUXVhdGVybmlvbigpO1xuICAgIGNvbnN0IHpvb21EaWZmID0gTWF0aC5hYnMoem9vbSAtIHByZXZab29tKTtcbiAgICBpZiAoIXF1YXQuZXF1YWxzKHRoaXMucXVhdGVybmlvbiwgcHJldlF1YXRlcm5pb24pIHx8IHpvb21EaWZmID49IEVQU0lMT04gKiAxMCAvLyBpZ25vcmUgc21hbGwgY2hhbmdlc1xuICAgICkge1xuICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hhbmdlIGNhbWVyYSdzIHJvdGF0aW9uIHdpdGggcXVhdGVybmlvbi5cclxuICAgKiBAa28g7Lm066mU6528IO2ajOyghOydhCBRdWF0ZXJuaW9u7J2EIOydtOyaqe2VtOyEnCDrs4Dqsr3tlanri4jri6QuXHJcbiAgICogQHBhcmFtIHJvdGF0aW9uIC0gUXVhdGVybmlvbiB0byBhcHBseSB7QGtvIOyggeyaqe2VoCBRdWF0ZXJuaW9ufVxyXG4gICAqIEBwYXJhbSB6b29tIC0gem9vbSB2YWx1ZSB0byBhcHBseSB7QGtvIOyggeyaqe2VoCDsubTrqZTrnbwg7KSMIOqwkn1cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgcm90YXRlKHJvdGF0aW9uLCB6b29tID0gdGhpcy56b29tKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHF1YXQubm9ybWFsaXplKHF1YXQuY3JlYXRlKCksIHJvdGF0aW9uKTtcbiAgICBjb25zdCBpc1NhbWVSb3RhdGlvbiA9IHF1YXQuZXF1YWxzKHRoaXMucXVhdGVybmlvbiwgbm9ybWFsaXplZCk7XG4gICAgcXVhdC5jb3B5KHRoaXMucXVhdGVybmlvbiwgbm9ybWFsaXplZCk7XG4gICAgY29uc3QgcHJldlpvb20gPSB0aGlzLnpvb207XG4gICAgY29uc3Qge1xuICAgICAgeWF3LFxuICAgICAgcGl0Y2hcbiAgICB9ID0gcXVhdFRvRXVsZXIobm9ybWFsaXplZCk7XG4gICAgdGhpcy55YXcgPSB5YXc7XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgY29uc3Qgem9vbURpZmYgPSBNYXRoLmFicyh6b29tIC0gcHJldlpvb20pO1xuICAgIGlmICghaXNTYW1lUm90YXRpb24gfHwgem9vbURpZmYgPj0gRVBTSUxPTiAqIDEwKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDaGFuZ2UgY2FtZXJhJ3Mgcm90YXRpb24gdG8gZ2l2ZW4gZXVsZXIgdmFsdWVzIGJ5IHRoZSBnaXZlbiBkdXJhdGlvbi5cclxuICAgKiBAa28g7Lm066mU652866W8IOyjvOyWtOynhCDrsKntlqXsnLzroZwg7KO87Ja07KeEIOyLnOqwhOuPmeyViCDshJzshJztnogg7J2064+Z7Iuc7YK164uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW5pbWF0aW9uIHBhcmFtZXRlcnMge0BrbyDslaDri4jrqZTsnbTshZgg7Yyo65+s66+47YSwfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zLnlhdyAtIHlhdyh5LWF4aXMgcm90YXRpb24pIHRvIGxvb2sgYXQge0BrbyDrsJTrnbzrs7wgeWF3KHnstpUg7ZqM7KCEKSDqsJJ9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMucGl0Y2ggLSBwaXRjaCh4LWF4aXMgcm90YXRpb24pIHRvIGxvb2sgYXQge0BrbyDrsJTrnbzrs7wgcGl0Y2goeOy2lSDtmozsoIQpIOqwkn1cclxuICAgKiBAcGFyYW0gb3B0aW9ucy56b29tIC0gem9vbSB2YWx1ZSB0byBhcHBseSB7QGtvIOyggeyaqe2VoCDsubTrqZTrnbwg7KSMIOqwkn1cclxuICAgKiBAcGFyYW0gb3B0aW9ucy5kdXJhdGlvbiAtIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24ge0BrbyDslaDri4jrqZTsnbTshZgg7Iuc6rCEfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zLmVhc2luZyAtIEVhc2luZyBmdW5jdGlvbiBmb3IgdGhlIGFuaW1hdGlvbiB7QGtvIOyVoOuLiOuplOydtOyFmOyXkCDsoIHsmqntlaAgZWFzaW5nIGZ1bmN0aW9ufVxyXG4gICAqL1xuICBhbmltYXRlVG8oe1xuICAgIHlhdyA9IHRoaXMueWF3LFxuICAgIHBpdGNoID0gdGhpcy5waXRjaCxcbiAgICB6b29tID0gdGhpcy56b29tLFxuICAgIGR1cmF0aW9uID0gMCxcbiAgICBlYXNpbmcgPSBERUZBVUxUX0VBU0lOR1xuICB9ID0ge30pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMueWF3ID09PSB5YXcgJiYgdGhpcy5waXRjaCA9PT0gcGl0Y2ggJiYgdGhpcy56b29tID09PSB6b29tKSByZXR1cm47XG4gICAgICBjb25zdCBmcm9tID0ge1xuICAgICAgICByb3RhdGlvbjogcXVhdC5jbG9uZSh0aGlzLnF1YXRlcm5pb24pLFxuICAgICAgICB6b29tOiB0aGlzLnpvb21cbiAgICAgIH07XG4gICAgICBjb25zdCB0byA9IHtcbiAgICAgICAgcm90YXRpb246IGV1bGVyVG9RdWF0KHF1YXQuY3JlYXRlKCksIHlhdywgcGl0Y2gsIHRoaXMucm9sbE9mZnNldCksXG4gICAgICAgIHpvb21cbiAgICAgIH07XG4gICAgICBjb25zdCBhbmltYXRpb24gPSBuZXcgQ2FtZXJhQW5pbWF0aW9uKHRoaXMsIGZyb20sIHRvLCB7XG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmdcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmluaXNoUHJvbWlzZSA9IGFuaW1hdGlvbi5nZXRGaW5pc2hQcm9taXNlKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgIGZpbmlzaFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmlnZ2VyKENBTUVSQV9FVkVOVFMuQU5JTUFUSU9OX0VORCwge1xuICAgICAgICAgIGFuaW1hdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbmlzaFByb21pc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICByZXN0cmljdFlhd1JhbmdlKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5feWF3UmFuZ2UgPSB7XG4gICAgICBtaW4sXG4gICAgICBtYXhcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEBoaWRkZW5cclxuICAgKi9cbiAgcmVzdHJpY3RQaXRjaFJhbmdlKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5fcGl0Y2hSYW5nZSA9IHtcbiAgICAgIG1pbixcbiAgICAgIG1heFxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICByZXN0cmljdFpvb21SYW5nZShtaW4sIG1heCkge1xuICAgIHRoaXMuX3pvb21SYW5nZSA9IHtcbiAgICAgIG1pbixcbiAgICAgIG1heFxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICByZXN0cmljdFJlbmRlckhlaWdodChoZWlnaHQpIHtcbiAgICB0aGlzLl9tYXhSZW5kZXJIZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICByZXNldFJhbmdlKCkge1xuICAgIHRoaXMuX3lhd1JhbmdlID0gdGhpcy5faW5pdGlhbFlhd1JhbmdlO1xuICAgIHRoaXMuX3BpdGNoUmFuZ2UgPSB0aGlzLl9pbml0aWFsUGl0Y2hSYW5nZTtcbiAgICB0aGlzLl96b29tUmFuZ2UgPSB0aGlzLl9pbml0aWFsWm9vbVJhbmdlO1xuICAgIHRoaXMuX21heFJlbmRlckhlaWdodCA9IC0xO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCBhY3R1YWwgeWF3IHJhbmdlIGJ5IHRoZSBnaXZlbiB6b29tIHZhbHVlLlxyXG4gICAqIEBrbyDso7zslrTsp4Qgem9vbSDqsJLsl5Ag64yA7ZWcIOyLpOygnCB5YXcg67KU7JyE6rCS7J2EIOuwmO2ZmO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0WWF3UmFuZ2Uoem9vbSkge1xuICAgIGNvbnN0IHlhd0xpbWl0ID0gdGhpcy5feWF3UmFuZ2U7XG4gICAgY29uc3QgbWF4UmVuZGVySGVpZ2h0ID0gdGhpcy5fbWF4UmVuZGVySGVpZ2h0O1xuICAgIGlmICgheWF3TGltaXQpIHJldHVybiBJTkZJTklURV9SQU5HRTtcbiAgICBjb25zdCBoYWxmSEZvdiA9IHRoaXMuZ2V0SG9yaXpvbnRhbEZvdih6b29tKSAqIDAuNTtcbiAgICBsZXQgbWluWWF3ID0geWF3TGltaXQubWluO1xuICAgIGxldCBtYXhZYXcgPSB5YXdMaW1pdC5tYXg7XG4gICAgaWYgKG1heFJlbmRlckhlaWdodCA+IDApIHtcbiAgICAgIGNvbnN0IGhhbGZWRm92UmFkID0gdG9WZXJ0aWNhbEZvdihoYWxmSEZvdiAqIERFR19UT19SQUQsIHRoaXMuX2FzcGVjdCk7XG4gICAgICBjb25zdCBoID0gbWF4UmVuZGVySGVpZ2h0ICogMC41O1xuICAgICAgY29uc3QgdCA9IE1hdGgudGFuKGhhbGZWRm92UmFkKTtcbiAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoKDEgKyBoICogaCkgLyAoMSArIHQgKiB0KSk7XG4gICAgICBjb25zdCB0aGV0YSA9IE1hdGguYXRhbihNYXRoLnRhbihoYWxmSEZvdiAqIERFR19UT19SQUQpICogZCkgKiBSQURfVE9fREVHO1xuICAgICAgbWluWWF3ID0geWF3TGltaXQubWluICsgdGhldGE7XG4gICAgICBtYXhZYXcgPSB5YXdMaW1pdC5tYXggLSB0aGV0YTtcbiAgICB9XG4gICAgaWYgKG1pbllhdyA+IG1heFlhdykge1xuICAgICAgbWluWWF3ID0gMDtcbiAgICAgIG1heFlhdyA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbllhdyxcbiAgICAgIG1heDogbWF4WWF3XG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgYWN0dWFsIHBpdGNoIHJhbmdlIGJ5IHRoZSBnaXZlbiB6b29tIHZhbHVlLlxyXG4gICAqIEBrbyDso7zslrTsp4Qgem9vbSDqsJLsl5Ag64yA7ZWcIOyLpOygnCBwaXRjaCDrspTsnITqsJLsnYQg67CY7ZmY7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXRQaXRjaFJhbmdlKHpvb20pIHtcbiAgICBjb25zdCBwaXRjaExpbWl0ID0gdGhpcy5fcGl0Y2hSYW5nZTtcbiAgICBjb25zdCBtYXhSZW5kZXJIZWlnaHQgPSB0aGlzLl9tYXhSZW5kZXJIZWlnaHQ7XG4gICAgaWYgKCFwaXRjaExpbWl0KSByZXR1cm4gREVGQVVMVF9QSVRDSF9SQU5HRTtcbiAgICBsZXQgbWluUGl0Y2ggPSBwaXRjaExpbWl0Lm1pbjtcbiAgICBsZXQgbWF4UGl0Y2ggPSBwaXRjaExpbWl0Lm1heDtcbiAgICBpZiAobWF4UmVuZGVySGVpZ2h0ID4gMCkge1xuICAgICAgY29uc3QgaGFsZlZGb3YgPSB0aGlzLmdldFZlcnRpY2FsRm92KHpvb20pICogMC41O1xuICAgICAgbWluUGl0Y2ggPSBwaXRjaExpbWl0Lm1pbiArIGhhbGZWRm92O1xuICAgICAgbWF4UGl0Y2ggPSBwaXRjaExpbWl0Lm1heCAtIGhhbGZWRm92O1xuICAgIH1cbiAgICBpZiAobWluUGl0Y2ggPiBtYXhQaXRjaCkge1xuICAgICAgbWluUGl0Y2ggPSAwO1xuICAgICAgbWF4UGl0Y2ggPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBNYXRoLm1heChtaW5QaXRjaCwgLTkwKSxcbiAgICAgIG1heDogTWF0aC5taW4obWF4UGl0Y2gsIDkwKVxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGFjdHVhbCB6b29tIHJhbmdlIGluIGZvdiBkZWdyZWVzLlxyXG4gICAqIEBrbyDsi6TsoJwg7KSMIOuylOychOulvCBmb3bqsIHsnZgg67KU7JyE66GcIOuwmO2ZmO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0Wm9vbVJhbmdlKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsaW1pdCA9IChfYSA9IHRoaXMuX3pvb21SYW5nZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9aT09NX1JBTkdFO1xuICAgIC8vIG1heCAoem9vbSBpbikgLT4gbWluaW11bSBmb3ZcbiAgICBjb25zdCBtaW5Gb3YgPSB0aGlzLmdldEhvcml6b250YWxGb3YobGltaXQubWF4KTtcbiAgICBjb25zdCBtYXhGb3YgPSB0aGlzLmdldEhvcml6b250YWxGb3YobGltaXQubWluKTtcbiAgICBjb25zdCBjdXJyZW50Rm92ID0gdGhpcy5nZXRIb3Jpem9udGFsRm92KHRoaXMuem9vbSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogTWF0aC5tYXgobWluRm92LCAxKSxcbiAgICAgIG1heDogTWF0aC5taW4obWF4Rm92LCAxODApLFxuICAgICAgY3VycmVudDogY3VycmVudEZvdlxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIGhvcml6b250YWwgZm92IHZhbHVlIHdoZW4gdGhlIGdpdmVuIHpvb20gaXMgYXBwbGllZC4gKGluIGRlZ3JlZXMsIMKwKVxyXG4gICAqIEBrbyDso7zslrTsp4Qgem9vbSDqsJLsnbQg7KCB7Jqp65CY7JeI7J2EIOuVjOydmCDsiJjtj4kgZm926rCS7J2EIOuwmO2ZmO2VqeuLiOuLpC4gKOuPhCDri6jsnIQsIMKwKVxyXG4gICAqIEByZXR1cm5zIFpvb21lZCBob3Jpem9udGFsIEZPViB7QGtvIOykjOydtCDsoIHsmqnrkJwg7IiY7Y+JIGZvduqwkn1cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0SG9yaXpvbnRhbEZvdih6b29tID0gdGhpcy56b29tKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFpvb21lZEhvcml6b250YWxGb3Yoem9vbSkgKiBSQURfVE9fREVHO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybiB2ZXJ0aWNhbCBmb3YgdmFsdWUgd2hlbiB0aGUgZ2l2ZW4gem9vbSBpcyBhcHBsaWVkLiAoaW4gZGVncmVlcywgwrApXHJcbiAgICogQGtvIOyjvOyWtOynhCB6b29tIOqwkuydtCDsoIHsmqnrkJjsl4jsnYQg65WM7J2YIOyImOyngSBmb3bqsJLsnYQg67CY7ZmY7ZWp64uI64ukLiAo64+EIOuLqOychCwgwrApXHJcbiAgICogQHJldHVybnMgWm9vbWVkIHZlcnRpY2FsIEZPViB7QGtvIOykjOydtCDsoIHsmqnrkJwg7IiY7KeBIGZvduqwkn1cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0VmVydGljYWxGb3Yoem9vbSA9IHRoaXMuem9vbSkge1xuICAgIGNvbnN0IGFzcGVjdCA9IHRoaXMuX2FzcGVjdDtcbiAgICBjb25zdCBoRm92ID0gdGhpcy5fZ2V0Wm9vbWVkSG9yaXpvbnRhbEZvdih6b29tKTsgLy8gSW4gcmFkaWFuc1xuICAgIGNvbnN0IHZGb3YgPSB0b1ZlcnRpY2FsRm92KGhGb3YsIGFzcGVjdCk7XG4gICAgcmV0dXJuIHZGb3YgKiBSQURfVE9fREVHO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSB6b29tIHZhbHVlIGZvciB0aGUgZ2l2ZW4gZm92LlxyXG4gICAqIEBrbyDso7zslrTsp4QgZm926rCS7J2EIHpvb23qsJLsnLzroZwg67OA7ZmY7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBmb3YgaG9yaXpvbnRhbCBmb3YgKGluIGRlZ3JlZXMsIMKwKSB7QGtvIOyImO2PiSBmb3Yg6rCSICjrj4Qg64uo7JyELCDCsCl9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGZvdlRvWm9vbShmb3YpIHtcbiAgICBjb25zdCBiYXNlRm92ID0gdGhpcy5mb3Y7XG4gICAgY29uc3QgcmVuZGVyaW5nV2lkdGggPSBNYXRoLnRhbihERUdfVE9fUkFEICogYmFzZUZvdiAqIDAuNSk7XG4gICAgY29uc3Qgem9vbWVkV2lkdGggPSBNYXRoLnRhbihERUdfVE9fUkFEICogZm92ICogMC41KTtcbiAgICByZXR1cm4gcmVuZGVyaW5nV2lkdGggLyB6b29tZWRXaWR0aDtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgaW5uZXIgbWF0cml4ZXMuXHJcbiAgICogQGtvIOuCtOu2gCDtlonroKzrk6TsnYQg7JeF642w7J207Yq47ZWp64uI64ukLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICB1cGRhdGVNYXRyaXgoKSB7XG4gICAgY29uc3QgdXAgPSB0aGlzLl91cDtcbiAgICBjb25zdCBhc3BlY3QgPSB0aGlzLl9hc3BlY3Q7XG4gICAgY29uc3Qgdmlld01hdHJpeCA9IHRoaXMudmlld01hdHJpeDtcbiAgICBjb25zdCBwcm9qTWF0cml4ID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMucXVhdGVybmlvbjtcbiAgICBjb25zdCB1cERpciA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3Qgdmlld0RpciA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAtMSk7XG4gICAgdmVjMy50cmFuc2Zvcm1RdWF0KHZpZXdEaXIsIHZpZXdEaXIsIHJvdGF0aW9uKTtcbiAgICB2ZWMzLnRyYW5zZm9ybVF1YXQodXBEaXIsIHVwLCByb3RhdGlvbik7XG4gICAgY29uc3QgaEZvdiA9IHRoaXMuX2dldFpvb21lZEhvcml6b250YWxGb3YoKTsgLy8gSW4gcmFkaWFuc1xuICAgIGNvbnN0IHZGb3YgPSB0b1ZlcnRpY2FsRm92KGhGb3YsIGFzcGVjdCk7XG4gICAgbWF0NC5sb29rQXQodmlld01hdHJpeCwgcG9zaXRpb24sIHZpZXdEaXIsIHVwRGlyKTtcbiAgICBtYXQ0LnBlcnNwZWN0aXZlKHByb2pNYXRyaXgsIHZGb3YsIGFzcGVjdCwgMC4xLCAxMDApO1xuICAgIHRoaXMuX2NoYW5nZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBoaWRkZW5cclxuICAgKi9cbiAgb25GcmFtZVJlbmRlcigpIHtcbiAgICB0aGlzLl9jaGFuZ2VkID0gZmFsc2U7XG4gIH1cbiAgX3VwZGF0ZVF1YXRlcm5pb24oKSB7XG4gICAgZXVsZXJUb1F1YXQodGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnlhdywgdGhpcy5waXRjaCwgdGhpcy5yb2xsT2Zmc2V0KTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0gem9vbSBDdXJyZW50IHpvb20gdmFsdWVcclxuICAgKiBAcmV0dXJucyBob3Jpem9udGFsIGZvdiBpbmNsdWRpbmcgem9vbSwgaW4gcmFkaWFuXHJcbiAgICovXG4gIF9nZXRab29tZWRIb3Jpem9udGFsRm92KHpvb20gPSB0aGlzLnpvb20pIHtcbiAgICByZXR1cm4gMiAqIE1hdGguYXRhbihNYXRoLnRhbihERUdfVE9fUkFEICogdGhpcy5mb3YgKiAwLjUpIC8gem9vbSk7XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuY2xhc3MgTW91c2VJbnB1dCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fb25Nb3VzZURvd24gPSBldnQgPT4ge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLl9lbDtcbiAgICAgIGlmICghZWwgfHwgZXZ0LmJ1dHRvbiAhPT0gTU9VU0VfQlVUVE9OLkxFRlQpIHJldHVybjtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKGVsLmZvY3VzKSB7XG4gICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByZXZQb3NbMF0gPSBldnQuY2xpZW50WDtcbiAgICAgIHRoaXMuX3ByZXZQb3NbMV0gPSBldnQuY2xpZW50WTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX01PVkUsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5NT1VTRV9VUCwgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIHtcbiAgICAgICAgc3JjRXZlbnQ6IGV2dCxcbiAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgIGlzS2V5Ym9hcmQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX29uTW91c2VNb3ZlID0gZXZ0ID0+IHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgeCA9IGV2dC5jbGllbnRYO1xuICAgICAgY29uc3QgeSA9IGV2dC5jbGllbnRZO1xuICAgICAgY29uc3QgcHJldlBvcyA9IHRoaXMuX3ByZXZQb3M7XG4gICAgICBjb25zdCBkZWx0YVggPSB4IC0gcHJldlBvc1swXTtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IHkgLSBwcmV2UG9zWzFdO1xuICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLkNIQU5HRSwge1xuICAgICAgICBkZWx0YToge1xuICAgICAgICAgIHg6IGRlbHRhWCxcbiAgICAgICAgICB5OiBkZWx0YVlcbiAgICAgICAgfSxcbiAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgIGlzS2V5Ym9hcmQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHByZXZQb3NbMF0gPSB4O1xuICAgICAgcHJldlBvc1sxXSA9IHk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9wcmV2UG9zWzBdID0gMDtcbiAgICAgIHRoaXMuX3ByZXZQb3NbMV0gPSAwO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuTU9VU0VfTU9WRSwgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX1VQLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHtcbiAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgIGlzS2V5Ym9hcmQ6IGZhbHNlLFxuICAgICAgICBzY3JvbGxpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX2VsID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2UG9zID0gWzAsIDBdO1xuICB9XG4gIGVuYWJsZShlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2VsKSByZXR1cm47XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX0RPV04sIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICB0aGlzLl9lbCA9IGVsZW1lbnQ7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWw7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX0RPV04sIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5NT1VTRV9NT1ZFLCB0aGlzLl9vbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX1VQLCB0aGlzLl9vbk1vdXNlVXAsIGZhbHNlKTtcbiAgICB0aGlzLl9lbCA9IG51bGw7XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuY2xhc3MgVG91Y2hJbnB1dCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGdldCBzY3JvbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxhYmxlO1xuICB9XG4gIHNldCBzY3JvbGxhYmxlKHZhbCkge1xuICAgIHRoaXMuX3Njcm9sbGFibGUgPSB2YWw7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9vblRvdWNoU3RhcnQgPSBldnQgPT4ge1xuICAgICAgaWYgKGV2dC50b3VjaGVzLmxlbmd0aCA+IDEgfHwgdGhpcy5fc2Nyb2xsaW5nKSByZXR1cm47XG4gICAgICBjb25zdCB0b3VjaCA9IGV2dC50b3VjaGVzWzBdO1xuICAgICAgdGhpcy5faXNGaXJzdFRvdWNoID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3ByZXZQb3NbMF0gPSB0b3VjaC5jbGllbnRYO1xuICAgICAgdGhpcy5fcHJldlBvc1sxXSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIHtcbiAgICAgICAgc3JjRXZlbnQ6IGV2dCxcbiAgICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgaXNLZXlib2FyZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fb25Ub3VjaE1vdmUgPSBldnQgPT4ge1xuICAgICAgLy8gT25seSB0aGUgb25lIGZpbmdlciBtb3Rpb24gc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPiAxIHx8IHRoaXMuX3Njcm9sbGluZykgcmV0dXJuO1xuICAgICAgY29uc3QgdG91Y2ggPSBldnQudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHNjcm9sbGFibGUgPSB0aGlzLl9zY3JvbGxhYmxlO1xuICAgICAgY29uc3QgcHJldlBvcyA9IHRoaXMuX3ByZXZQb3M7XG4gICAgICBjb25zdCB4ID0gdG91Y2guY2xpZW50WDtcbiAgICAgIGNvbnN0IHkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgY29uc3QgZGVsdGFYID0geCAtIHByZXZQb3NbMF07XG4gICAgICBjb25zdCBkZWx0YVkgPSB5IC0gcHJldlBvc1sxXTtcbiAgICAgIGlmICh0aGlzLl9pc0ZpcnN0VG91Y2gpIHtcbiAgICAgICAgaWYgKHNjcm9sbGFibGUgJiYgIWlzRnVsbHNjcmVlbigpKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhWSkgPiBNYXRoLmFicyhkZWx0YVgpKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgU2Nyb2xsaW5nXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0ZpcnN0VG91Y2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuQ0hBTkdFLCB7XG4gICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgeDogZGVsdGFYLFxuICAgICAgICAgIHk6IGRlbHRhWVxuICAgICAgICB9LFxuICAgICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgICBpc0tleWJvYXJkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBwcmV2UG9zWzBdID0geDtcbiAgICAgIHByZXZQb3NbMV0gPSB5O1xuICAgIH07XG4gICAgdGhpcy5fb25Ub3VjaEVuZCA9IGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAwKSByZXR1cm47XG4gICAgICBjb25zdCB0b3VjaCA9IGV2dC50b3VjaGVzWzBdO1xuICAgICAgY29uc3QgcHJldlBvcyA9IHRoaXMuX3ByZXZQb3M7XG4gICAgICBpZiAodG91Y2gpIHtcbiAgICAgICAgcHJldlBvc1swXSA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgIHByZXZQb3NbMV0gPSB0b3VjaC5jbGllbnRZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvc1swXSA9IDA7XG4gICAgICAgIHByZXZQb3NbMV0gPSAwO1xuICAgICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuSU5QVVRfRU5ELCB7XG4gICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICBpc0tleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgICBzY3JvbGxpbmc6IHRoaXMuX3Njcm9sbGluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY3JvbGxpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX2VsID0gbnVsbDtcbiAgICB0aGlzLl9wcmV2UG9zID0gWzAsIDBdO1xuICAgIHRoaXMuX2lzRmlyc3RUb3VjaCA9IGZhbHNlO1xuICAgIHRoaXMuX3Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3Njcm9sbGFibGUgPSBmYWxzZTtcbiAgfVxuICBlbmFibGUoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9lbCkgcmV0dXJuO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5UT1VDSF9TVEFSVCwgdGhpcy5fb25Ub3VjaFN0YXJ0LCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5UT1VDSF9NT1ZFLCB0aGlzLl9vblRvdWNoTW92ZSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVE9VQ0hfRU5ELCB0aGlzLl9vblRvdWNoRW5kKTtcbiAgICB0aGlzLl9lbCA9IGVsZW1lbnQ7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWw7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRPVUNIX1NUQVJULCB0aGlzLl9vblRvdWNoU3RhcnQpO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5UT1VDSF9NT1ZFLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRPVUNIX0VORCwgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgdGhpcy5fZWwgPSBudWxsO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbmNsYXNzIEtleWJvYXJkSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBnZXQgYWN0aXZlKCkge1xuICAgIGNvbnN0IHByZXNzZWQgPSB0aGlzLl9wcmVzc2VkO1xuICAgIHJldHVybiBwcmVzc2VkLkxFRlQgfHwgcHJlc3NlZC5VUCB8fCBwcmVzc2VkLlJJR0hUIHx8IHByZXNzZWQuRE9XTjtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX29uS2V5RG93biA9IGV2dCA9PiB7XG4gICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIGtleXByZXNzIGV4Y2VwdCBtYWluIGFycm93IGtleXNcbiAgICAgIGlmIChldnQubG9jYXRpb24gIT09IEtleWJvYXJkRXZlbnQuRE9NX0tFWV9MT0NBVElPTl9TVEFOREFSRCkgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlS2V5UHJlc3MoZXZ0LCB0cnVlKTtcbiAgICAgIGNvbnN0IHByZXNzZWRDb3VudCA9IHRoaXMuX2dldFByZXNzZWRLZXlDb3VudCgpO1xuICAgICAgaWYgKHByZXNzZWRDb3VudCA8PSAwKSByZXR1cm47XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmIChwcmVzc2VkQ291bnQgPT09IDEgJiYgIWV2dC5yZXBlYXQpIHtcbiAgICAgICAgLy8gT24gZmlyc3Qga2V5ZG93blxuICAgICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIHtcbiAgICAgICAgICBzcmNFdmVudDogZXZ0LFxuICAgICAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgICAgIGlzS2V5Ym9hcmQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbktleVVwID0gZXZ0ID0+IHtcbiAgICAgIC8vIElnbm9yZSBhbGwgb3RoZXIga2V5cHJlc3MgZXhjZXB0IG1haW4gYXJyb3cga2V5c1xuICAgICAgaWYgKGV2dC5sb2NhdGlvbiAhPT0gS2V5Ym9hcmRFdmVudC5ET01fS0VZX0xPQ0FUSU9OX1NUQU5EQVJEKSByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVLZXlQcmVzcyhldnQsIGZhbHNlKTtcbiAgICAgIGNvbnN0IHByZXNzZWRDb3VudCA9IHRoaXMuX2dldFByZXNzZWRLZXlDb3VudCgpO1xuICAgICAgaWYgKHByZXNzZWRDb3VudCA+IDApIHJldHVybjtcbiAgICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHtcbiAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgIGlzS2V5Ym9hcmQ6IHRydWUsXG4gICAgICAgIHNjcm9sbGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fZWwgPSBudWxsO1xuICAgIHRoaXMuX2NsZWFyUHJlc3NlZEtleXMoKTtcbiAgfVxuICBlbmFibGUoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9lbCkgcmV0dXJuO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5LRVlfRE9XTiwgdGhpcy5fb25LZXlEb3duKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuS0VZX1VQLCB0aGlzLl9vbktleVVwKTtcbiAgICB0aGlzLl9lbCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fY2xlYXJQcmVzc2VkS2V5cygpO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsO1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5LRVlfRE9XTiwgdGhpcy5fb25LZXlEb3duKTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuS0VZX1VQLCB0aGlzLl9vbktleVVwKTtcbiAgICB0aGlzLl9lbCA9IG51bGw7XG4gICAgdGhpcy5fY2xlYXJQcmVzc2VkS2V5cygpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2dldERlbHRhQnlQcmVzc2VkS2V5cygpO1xuICAgIGlmIChkZWx0YS54ICE9PSAwIHx8IGRlbHRhLnkgIT09IDApIHtcbiAgICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5DSEFOR0UsIHtcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgICBpc0tleWJvYXJkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2NsZWFyUHJlc3NlZEtleXMoKSB7XG4gICAgdGhpcy5fcHJlc3NlZCA9IEtFWV9ESVJFQ1RJT04ucmVkdWNlKChvYmosIGtleU5hbWUpID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9iaiksIHtcbiAgICAgICAgW2tleU5hbWVdOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwge30pO1xuICB9XG4gIF91cGRhdGVLZXlQcmVzcyhldmVudCwgaXNFbmFibGUpIHtcbiAgICBjb25zdCBwcmVzc2VkID0gdGhpcy5fcHJlc3NlZDtcbiAgICBjb25zdCBrZXlUb1VwZGF0ZSA9IGV2ZW50LmtleUNvZGUgIT0gbnVsbCA/IERJUkVDVElPTl9LRVlfQ09ERVtldmVudC5rZXlDb2RlXSA6IERJUkVDVElPTl9LRVlfTkFNRVtldmVudC5rZXldO1xuICAgIGlmICgha2V5VG9VcGRhdGUpIHJldHVybjtcbiAgICBwcmVzc2VkW2tleVRvVXBkYXRlXSA9IGlzRW5hYmxlO1xuICB9XG4gIF9nZXRQcmVzc2VkS2V5Q291bnQoKSB7XG4gICAgcmV0dXJuIEtFWV9ESVJFQ1RJT04uZmlsdGVyKGtleSA9PiB0aGlzLl9wcmVzc2VkW2tleV0pLmxlbmd0aDtcbiAgfVxuICBfZ2V0RGVsdGFCeVByZXNzZWRLZXlzKCkge1xuICAgIGNvbnN0IHByZXNzZWQgPSB0aGlzLl9wcmVzc2VkO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgaWYgKHByZXNzZWQuTEVGVCkge1xuICAgICAgeCArPSAxO1xuICAgIH1cbiAgICBpZiAocHJlc3NlZC5SSUdIVCkge1xuICAgICAgeCAtPSAxO1xuICAgIH1cbiAgICBpZiAocHJlc3NlZC5VUCkge1xuICAgICAgeSArPSAxO1xuICAgIH1cbiAgICBpZiAocHJlc3NlZC5ET1dOKSB7XG4gICAgICB5IC09IDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIENhbWVyYSdzIHJvdGF0aW9uIGNvbnRyb2xcclxuICogQGtvIOy5tOuplOudvOydmCDtmozsoITsnYQg64u064u57ZWY64qUIOy7qO2KuOuhpFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBSb3RhdGVDb250cm9sIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXHJcbiAgICogQGNvcHkgQ2FtZXJhQ29udHJvbCNlbmFibGVkXHJcbiAgICovXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICB9XG4gIC8qKlxyXG4gICAqIEBoaWRkZW5cclxuICAgKi9cbiAgZ2V0IGVuYWJsZUJsb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZUJsb2NrZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQGNvcHkgQ2FtZXJhQ29udHJvbCNhbmltYXRpbmdcclxuICAgKi9cbiAgZ2V0IGFuaW1hdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5Ym9hcmRJbnB1dC5hY3RpdmUgfHwgdGhpcy5feE1vdGlvbi5hY3RpdmF0ZWQgfHwgdGhpcy5feU1vdGlvbi5hY3RpdmF0ZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3VycmVudCB5YXcgdmFsdWVcclxuICAgKiBAa28g7ZiE7J6sIHlhdyDqsJJcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IHlhdygpIHtcbiAgICByZXR1cm4gdGhpcy5feE1vdGlvbjtcbiAgfVxuICAvKipcclxuICAgKiBDdXJyZW50IHBpdGNoIHZhbHVlXHJcbiAgICogQGtvIO2YhOyerCBwaXRjaCDqsJJcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IHBpdGNoKCkge1xuICAgIHJldHVybiB0aGlzLl95TW90aW9uO1xuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IFZpZXczNjAjc2Nyb2xsYWJsZVxyXG4gICAqL1xuICBnZXQgc2Nyb2xsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG91Y2hJbnB1dC5zY3JvbGxhYmxlO1xuICB9XG4gIHNldCBzY3JvbGxhYmxlKHZhbCkge1xuICAgIHRoaXMuX3RvdWNoSW5wdXQuc2Nyb2xsYWJsZSA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBTY2FsZSBmYWN0b3IgZm9yIG1vdXNlL3RvdWNoIHJvdGF0aW9uXHJcbiAgICogQGtvIOuniOyasOyKpC/thLDsuZjrpbwg7Ya17ZWcIO2ajOyghCDrsLDsnKhcclxuICAgKiBAZGVmYXVsdCBbMSwgMV1cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IHBvaW50ZXJTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRlclNjYWxlO1xuICB9XG4gIHNldCBwb2ludGVyU2NhbGUodmFsKSB7XG4gICAgdGhpcy5fcG9pbnRlclNjYWxlID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIFNjYWxlIGZhY3RvciBmb3Iga2V5Ym9hcmQgcm90YXRpb25cclxuICAgKiBAa28g7YKk67O065Oc66W8IO2Gte2VnCDtmozsoIQg67Cw7JyoXHJcbiAgICogQGRlZmF1bHQgWzEsIDFdXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBrZXlib2FyZFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlib2FyZFNjYWxlO1xuICB9XG4gIHNldCBrZXlib2FyZFNjYWxlKHZhbCkge1xuICAgIHRoaXMuX2tleWJvYXJkU2NhbGUgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogRHVyYXRpb24gb2YgdGhlIGlucHV0IGFuaW1hdGlvbiAobXMpXHJcbiAgICogQGtvIO2ajOyghCDslaDri4jrqZTsnbTshZjsnZgg7Iuc6rCEIChtcylcclxuICAgKiBAZGVmYXVsdCAzMDBcclxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgfVxuICBzZXQgZHVyYXRpb24odmFsKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB2YWw7XG4gICAgdGhpcy5feE1vdGlvbi5kdXJhdGlvbiA9IHZhbDtcbiAgICB0aGlzLl95TW90aW9uLmR1cmF0aW9uID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIEVhc2luZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICogQGtvIO2ajOyghCDslaDri4jrqZTsnbTshZjsl5Ag7KCB7Jqp7ZWgIGVhc2luZyDtlajsiJhcclxuICAgKiBAZGVmYXVsdCBFQVNJTkcuRUFTRV9PVVRfQ1VCSUNcclxuICAgKiBAc2VlIEVBU0lOR1xyXG4gICAqL1xuICBnZXQgZWFzaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9lYXNpbmc7XG4gIH1cbiAgc2V0IGVhc2luZyh2YWwpIHtcbiAgICB0aGlzLl9lYXNpbmcgPSB2YWw7XG4gICAgdGhpcy5feE1vdGlvbi5lYXNpbmcgPSB2YWw7XG4gICAgdGhpcy5feU1vdGlvbi5lYXNpbmcgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogRGlzYWJsZSBYLWF4aXMocGl0Y2gpIHJvdGF0aW9uLlxyXG4gICAqIEBrbyB47LaVIO2ajOyghChwaXRjaCnsnYQg67mE7Zmc7ISx7ZmU7ZWp64uI64ukLlxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICovXG4gIGdldCBkaXNhYmxlUGl0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVQaXRjaDtcbiAgfVxuICBzZXQgZGlzYWJsZVBpdGNoKHZhbCkge1xuICAgIHRoaXMuX2Rpc2FibGVQaXRjaCA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBEaXNhYmxlIFktYXhpcyh5YXcpIHJvdGF0aW9uLlxyXG4gICAqIEBrbyB57LaVIO2ajOyghCh5YXcp7J2EIOu5hO2ZnOyEse2ZlO2VqeuLiOuLpC5cclxuICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAqL1xuICBnZXQgZGlzYWJsZVlhdygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZVlhdztcbiAgfVxuICBzZXQgZGlzYWJsZVlhdyh2YWwpIHtcbiAgICB0aGlzLl9kaXNhYmxlWWF3ID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIERpc2FibGUgcm90YXRpb24gYnkga2V5Ym9hcmQuXHJcbiAgICogQGtvIO2CpOuztOuTnOulvCDsnbTsmqntlZwg7ZqM7KCE7J2EIOu5hO2ZnOyEse2ZlO2VqeuLiOuLpC5cclxuICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAqL1xuICBnZXQgZGlzYWJsZUtleWJvYXJkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlS2V5Ym9hcmQ7XG4gIH1cbiAgc2V0IGRpc2FibGVLZXlib2FyZCh2YWwpIHtcbiAgICB0aGlzLl9kaXNhYmxlS2V5Ym9hcmQgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBSb3RhdGVDb250cm9sIGluc3RhbmNlXHJcbiAgICogQGtvIFJvdGF0ZUNvbnRyb2zsnZgg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gY29udHJvbEVsIC0gRWxlbWVudCB0byBhdHRhY2ggaGFuZGxlcnMge0BrbyDsnoXroKXsnYQg67Cb7J2EIOyXmOumrOuovO2KuH1cclxuICAgKiBAcGFyYW0gZW5hYmxlQmxvY2tlZCAtIFdoZXRoZXIgdG8gZGlzYWJsZSBjb250cm9sIG9uIGluaXQge0BrbyDstIjquLDtmZQg6rO87KCV7JeQ7IScIOy7qO2KuOuhpCDtmZzshLHtmZQg7Jes67aAfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgY29udHJvbCB7QGtvIOy7qO2KuOuhpCDsmLXshZjrk6R9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyb2xFbCwgZW5hYmxlQmxvY2tlZCwge1xuICAgIGR1cmF0aW9uID0gREVGQVVMVF9BTklNQVRJT05fRFVSQVRJT04sXG4gICAgZWFzaW5nID0gREVGQVVMVF9FQVNJTkcsXG4gICAgcG9pbnRlclNjYWxlID0gWzEsIDFdLFxuICAgIGtleWJvYXJkU2NhbGUgPSBbMSwgMV0sXG4gICAgZGlzYWJsZVBpdGNoID0gZmFsc2UsXG4gICAgZGlzYWJsZVlhdyA9IGZhbHNlLFxuICAgIGRpc2FibGVLZXlib2FyZCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fb25JbnB1dFN0YXJ0ID0gZXZ0ID0+IHtcbiAgICAgIHRoaXMuX2NoYW5nZWRXaGlsZURyYWdnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZ0KSwge1xuICAgICAgICBpbnB1dFR5cGU6IFwicm90YXRlXCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIHRoaXMuX29uQ2hhbmdlID0gZXZ0ID0+IHtcbiAgICAgIGNvbnN0IGRlbHRhID0gZXZ0LmRlbHRhO1xuICAgICAgY29uc3QgaW52Wm9vbVNjYWxlID0gMSAvIHRoaXMuX3pvb21TY2FsZTsgLy8gUmVkdWNlIHNwZWVkIG9uIHpvb21cbiAgICAgIGNvbnN0IHNjcmVlblNjYWxlID0gdGhpcy5fc2NyZWVuU2NhbGU7XG4gICAgICBjb25zdCBrZXlib2FyZFNjYWxlID0gdGhpcy5fa2V5Ym9hcmRTY2FsZTtcbiAgICAgIGNvbnN0IHBvaW50ZXJTY2FsZSA9IHRoaXMuX3BvaW50ZXJTY2FsZTtcbiAgICAgIGxldCBzY2FsZTtcbiAgICAgIGlmIChldnQuaXNLZXlib2FyZCkge1xuICAgICAgICBzY2FsZSA9IFtrZXlib2FyZFNjYWxlWzBdICogaW52Wm9vbVNjYWxlLCBrZXlib2FyZFNjYWxlWzFdICogaW52Wm9vbVNjYWxlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlID0gW3BvaW50ZXJTY2FsZVswXSAqIHNjcmVlblNjYWxlWzBdICogaW52Wm9vbVNjYWxlLCBwb2ludGVyU2NhbGVbMV0gKiBzY3JlZW5TY2FsZVsxXSAqIGludlpvb21TY2FsZV07XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZWRYID0gZGVsdGEueCAqIHNjYWxlWzBdO1xuICAgICAgY29uc3Qgc2NhbGVkWSA9IGRlbHRhLnkgKiBzY2FsZVsxXTtcbiAgICAgIHRoaXMuX3hNb3Rpb24uc2V0TmV3RW5kQnlEZWx0YShzY2FsZWRYKTtcbiAgICAgIHRoaXMuX3lNb3Rpb24uc2V0TmV3RW5kQnlEZWx0YShzY2FsZWRZKTtcbiAgICAgIHRoaXMuX2NoYW5nZWRXaGlsZURyYWdnaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMuX29uSW5wdXRFbmQgPSBldnQgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldnQpLCB7XG4gICAgICAgIGlucHV0VHlwZTogXCJyb3RhdGVcIlxuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLl9jaGFuZ2VkV2hpbGVEcmFnZ2luZyAmJiAhZXZ0LmlzS2V5Ym9hcmQgJiYgIWV2dC5zY3JvbGxpbmcpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLlNUQVRJQ19DTElDSywge1xuICAgICAgICAgIGlzVG91Y2g6IGV2dC5pc1RvdWNoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlZFdoaWxlRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX2NvbnRyb2xFbCA9IGNvbnRyb2xFbDtcbiAgICB0aGlzLl9wb2ludGVyU2NhbGUgPSBwb2ludGVyU2NhbGU7XG4gICAgdGhpcy5fa2V5Ym9hcmRTY2FsZSA9IGtleWJvYXJkU2NhbGU7XG4gICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLl9lYXNpbmcgPSBlYXNpbmc7XG4gICAgdGhpcy5fZGlzYWJsZVBpdGNoID0gZGlzYWJsZVBpdGNoO1xuICAgIHRoaXMuX2Rpc2FibGVZYXcgPSBkaXNhYmxlWWF3O1xuICAgIHRoaXMuX2Rpc2FibGVLZXlib2FyZCA9IGRpc2FibGVLZXlib2FyZDtcbiAgICB0aGlzLl9lbmFibGVCbG9ja2VkID0gZW5hYmxlQmxvY2tlZDtcbiAgICB0aGlzLl9tb3VzZUlucHV0ID0gbmV3IE1vdXNlSW5wdXQoKTtcbiAgICB0aGlzLl90b3VjaElucHV0ID0gbmV3IFRvdWNoSW5wdXQoKTtcbiAgICB0aGlzLl9rZXlib2FyZElucHV0ID0gbmV3IEtleWJvYXJkSW5wdXQoKTtcbiAgICB0aGlzLl94TW90aW9uID0gbmV3IE1vdGlvbih7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIHJhbmdlOiBJTkZJTklURV9SQU5HRSxcbiAgICAgIGVhc2luZ1xuICAgIH0pO1xuICAgIHRoaXMuX3lNb3Rpb24gPSBuZXcgTW90aW9uKHtcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgcmFuZ2U6IERFRkFVTFRfUElUQ0hfUkFOR0UsXG4gICAgICBlYXNpbmdcbiAgICB9KTtcbiAgICB0aGlzLl9zY3JlZW5TY2FsZSA9IFsxLCAxXTtcbiAgICB0aGlzLl96b29tU2NhbGUgPSAxO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jaGFuZ2VkV2hpbGVEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2JpbmRJbnB1dHMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX21vdXNlSW5wdXQub2ZmKCk7XG4gICAgdGhpcy5fdG91Y2hJbnB1dC5vZmYoKTtcbiAgICB0aGlzLl9rZXlib2FyZElucHV0Lm9mZigpO1xuICAgIHRoaXMub2ZmKCk7XG4gICAgdGhpcy5fY2hhbmdlZFdoaWxlRHJhZ2dpbmcgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBAaGlkZGVuXHJcbiAgICovXG4gIHVwZGF0ZShkZWx0YSkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHhNb3Rpb24gPSB0aGlzLl94TW90aW9uO1xuICAgIGNvbnN0IHlNb3Rpb24gPSB0aGlzLl95TW90aW9uO1xuICAgIGNvbnN0IGtleWJvYXJkSW5wdXQgPSB0aGlzLl9rZXlib2FyZElucHV0O1xuICAgIGlmICghdGhpcy5fZGlzYWJsZUtleWJvYXJkKSB7XG4gICAgICBrZXlib2FyZElucHV0LnVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVQaXRjaCkge1xuICAgICAgeU1vdGlvbi51cGRhdGUoZGVsdGEpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVZYXcpIHtcbiAgICAgIHhNb3Rpb24udXBkYXRlKGRlbHRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICB1cGRhdGVSYW5nZShjYW1lcmEsIHpvb20pIHtcbiAgICBjb25zdCB5YXdSYW5nZSA9IGNhbWVyYS5nZXRZYXdSYW5nZSh6b29tKTtcbiAgICBjb25zdCBwaXRjaFJhbmdlID0gY2FtZXJhLmdldFBpdGNoUmFuZ2Uoem9vbSk7XG4gICAgdGhpcy5feE1vdGlvbi5zZXRSYW5nZSh5YXdSYW5nZS5taW4sIHlhd1JhbmdlLm1heCk7XG4gICAgdGhpcy5feU1vdGlvbi5zZXRSYW5nZShwaXRjaFJhbmdlLm1pbiwgcGl0Y2hSYW5nZS5tYXgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBoaWRkZW5cclxuICAgKi9cbiAgc2V0Wm9vbVNjYWxlKHZhbCkge1xuICAgIHRoaXMuX3pvb21TY2FsZSA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBSZXNpemUgY29udHJvbCB0byBtYXRjaCB0YXJnZXQgc2l6ZS5cclxuICAgKiBAa28g7Luo7Yq466Gk7J2YIOuCtOu2gCDtgazquLDrpbwg6rCx7Iug7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBoZm92IC0gQ2FtZXJhIGhvcml6b250YWwgZm92IGluIGRlZ3JlZXMge0BrbyDsubTrqZTrnbzsnZgg7IiY7Y+J67Cp7ZalIGZvduqwkiAo64+EIOuLqOychCl9XHJcbiAgICogQHBhcmFtIGFzcGVjdCAtIENhbWVyYSBhc3BlY3Qge0BrbyDsubTrqZTrnbwg6rCA66GcL+yEuOuhnCDruYTsnKh9XHJcbiAgICogQHBhcmFtIHdpZHRoIC0gTmV3IHdpZHRoIHtAa28g6rCx7Iug65CcIOuEiOu5hH1cclxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gTmV3IGhlaWdodCB7QGtvIOqwseyLoOuQnCDrhpLsnbR9XHJcbiAgICovXG4gIHJlc2l6ZShoZm92LCBhc3BlY3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB2Zm92ID0gdG9WZXJ0aWNhbEZvdihoZm92ICogREVHX1RPX1JBRCwgYXNwZWN0KSAqIFJBRF9UT19ERUc7XG4gICAgdGhpcy5fc2NyZWVuU2NhbGVbMF0gPSBoZm92IC8gd2lkdGg7XG4gICAgdGhpcy5fc2NyZWVuU2NhbGVbMV0gPSB2Zm92IC8gaGVpZ2h0O1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jb250cm9sRWw7XG4gICAgdGhpcy5fbW91c2VJbnB1dC5lbmFibGUoZWxlbWVudCk7XG4gICAgdGhpcy5fdG91Y2hJbnB1dC5lbmFibGUoZWxlbWVudCk7XG4gICAgdGhpcy5fa2V5Ym9hcmRJbnB1dC5lbmFibGUoZWxlbWVudCk7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5fZW5hYmxlQmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5FTkFCTEUsIHtcbiAgICAgIGNvbnRyb2w6IHRoaXMsXG4gICAgICB1cGRhdGVDdXJzb3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuX21vdXNlSW5wdXQuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3RvdWNoSW5wdXQuZGlzYWJsZSgpO1xuICAgIHRoaXMuX2tleWJvYXJkSW5wdXQuZGlzYWJsZSgpO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuRElTQUJMRSwge1xuICAgICAgdXBkYXRlQ3Vyc29yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3luYyhjYW1lcmEpIHtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlKGNhbWVyYSwgY2FtZXJhLnpvb20pO1xuICAgIHRoaXMuX3hNb3Rpb24ucmVzZXQoY2FtZXJhLnlhdyk7XG4gICAgdGhpcy5feU1vdGlvbi5yZXNldChjYW1lcmEucGl0Y2gpO1xuICB9XG4gIF9iaW5kSW5wdXRzKCkge1xuICAgIGNvbnN0IG1vdXNlSW5wdXQgPSB0aGlzLl9tb3VzZUlucHV0O1xuICAgIGNvbnN0IHRvdWNoSW5wdXQgPSB0aGlzLl90b3VjaElucHV0O1xuICAgIGNvbnN0IGtleWJvYXJkSW5wdXQgPSB0aGlzLl9rZXlib2FyZElucHV0O1xuICAgIG1vdXNlSW5wdXQub24oQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIHRoaXMuX29uSW5wdXRTdGFydCk7XG4gICAgbW91c2VJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5DSEFOR0UsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICBtb3VzZUlucHV0Lm9uKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCwgdGhpcy5fb25JbnB1dEVuZCk7XG4gICAgdG91Y2hJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgdGhpcy5fb25JbnB1dFN0YXJ0KTtcbiAgICB0b3VjaElucHV0Lm9uKENPTlRST0xfRVZFTlRTLkNIQU5HRSwgdGhpcy5fb25DaGFuZ2UpO1xuICAgIHRvdWNoSW5wdXQub24oQ09OVFJPTF9FVkVOVFMuSU5QVVRfRU5ELCB0aGlzLl9vbklucHV0RW5kKTtcbiAgICBrZXlib2FyZElucHV0Lm9uKENPTlRST0xfRVZFTlRTLklOUFVUX1NUQVJULCB0aGlzLl9vbklucHV0U3RhcnQpO1xuICAgIGtleWJvYXJkSW5wdXQub24oQ09OVFJPTF9FVkVOVFMuQ0hBTkdFLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAga2V5Ym9hcmRJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHRoaXMuX29uSW5wdXRFbmQpO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbmNsYXNzIFdoZWVsSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBnZXQgc2Nyb2xsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsYWJsZTtcbiAgfVxuICBzZXQgc2Nyb2xsYWJsZSh2YWwpIHtcbiAgICB0aGlzLl9zY3JvbGxhYmxlID0gdmFsO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fb25XaGVlbCA9IGV2dCA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxhYmxlID0gdGhpcy5fc2Nyb2xsYWJsZTtcbiAgICAgIGlmIChldnQuZGVsdGFZID09PSAwIHx8IHNjcm9sbGFibGUpIHJldHVybjtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKHRoaXMuX2lucHV0VGltZXIgPCAwKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwge1xuICAgICAgICAgIHNyY0V2ZW50OiBldnQsXG4gICAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgICAgaXNLZXlib2FyZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2Jhc2VTY2FsZSAqIGV2dC5kZWx0YVk7XG4gICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuQ0hBTkdFLCB7XG4gICAgICAgIGRlbHRhLFxuICAgICAgICBpc1RvdWNoOiBmYWxzZSxcbiAgICAgICAgaXNLZXlib2FyZDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5wdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCwge1xuICAgICAgICAgIGlzVG91Y2g6IGZhbHNlLFxuICAgICAgICAgIGlzS2V5Ym9hcmQ6IGZhbHNlLFxuICAgICAgICAgIHNjcm9sbGluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2lucHV0VGltZXIgPSAtMTtcbiAgICAgIH0sIERFRkFVTFRfQU5JTUFUSU9OX0RVUkFUSU9OKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsID0gbnVsbDtcbiAgICB0aGlzLl9iYXNlU2NhbGUgPSAwLjA0O1xuICAgIHRoaXMuX3Njcm9sbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnB1dFRpbWVyID0gLTE7XG4gIH1cbiAgZW5hYmxlKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5fZWwpIHJldHVybjtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuV0hFRUwsIHRoaXMuX29uV2hlZWwsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLl9lbCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fY2xlYXJUaW1lcigpO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsO1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5XSEVFTCwgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuICAgIHRoaXMuX2VsID0gbnVsbDtcbiAgICB0aGlzLl9jbGVhclRpbWVyKCk7XG4gIH1cbiAgX2NsZWFyVGltZXIoKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9pbnB1dFRpbWVyKTtcbiAgICB0aGlzLl9pbnB1dFRpbWVyID0gLTE7XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuY2xhc3MgUGluY2hJbnB1dCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fb25Ub3VjaE1vdmUgPSBldnQgPT4ge1xuICAgICAgY29uc3QgdG91Y2hlcyA9IGV2dC50b3VjaGVzO1xuICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoICE9PSAyKSByZXR1cm47XG4gICAgICBpZiAoIWV2dC5jYW5jZWxhYmxlKSByZXR1cm47XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHByZXZEaXN0YW5jZSA9IHRoaXMuX3ByZXZEaXN0YW5jZTtcbiAgICAgIGNvbnN0IGRpZmYgPSBbdG91Y2hlc1swXS5wYWdlWCAtIHRvdWNoZXNbMV0ucGFnZVgsIHRvdWNoZXNbMF0ucGFnZVkgLSB0b3VjaGVzWzFdLnBhZ2VZXTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpZmZbMF0gKiBkaWZmWzBdICsgZGlmZlsxXSAqIGRpZmZbMV0pICogdGhpcy5fYmFzZVNjYWxlO1xuICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLl9pc0ZpcnN0VG91Y2ggPyAwIDogZGlzdGFuY2UgLSBwcmV2RGlzdGFuY2U7XG4gICAgICBpZiAodGhpcy5faXNGaXJzdFRvdWNoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwge1xuICAgICAgICAgIHNyY0V2ZW50OiBldnQsXG4gICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICBpc0tleWJvYXJkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByZXZEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgdGhpcy5faXNGaXJzdFRvdWNoID0gZmFsc2U7XG4gICAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuQ0hBTkdFLCB7XG4gICAgICAgIGRlbHRhLFxuICAgICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgICBpc0tleWJvYXJkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9vblRvdWNoRW5kID0gZXZ0ID0+IHtcbiAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggIT09IDApIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5faXNGaXJzdFRvdWNoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHtcbiAgICAgICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgICAgIGlzS2V5Ym9hcmQ6IGZhbHNlLFxuICAgICAgICAgIHNjcm9sbGluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wcmV2RGlzdGFuY2UgPSAtMTtcbiAgICAgIHRoaXMuX2lzRmlyc3RUb3VjaCA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLl9lbCA9IG51bGw7XG4gICAgdGhpcy5fYmFzZVNjYWxlID0gLTAuMjtcbiAgICB0aGlzLl9wcmV2RGlzdGFuY2UgPSAtMTtcbiAgICB0aGlzLl9pc0ZpcnN0VG91Y2ggPSB0cnVlO1xuICB9XG4gIGVuYWJsZShlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2VsKSByZXR1cm47XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRPVUNIX01PVkUsIHRoaXMuX29uVG91Y2hNb3ZlLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRPVUNIX0VORCwgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgdGhpcy5fZWwgPSBlbGVtZW50O1xuICAgIHRoaXMuX3ByZXZEaXN0YW5jZSA9IC0xO1xuICAgIHRoaXMuX2lzRmlyc3RUb3VjaCA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWw7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRPVUNIX01PVkUsIHRoaXMuX29uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRPVUNIX0VORCwgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgdGhpcy5fZWwgPSBudWxsO1xuICB9XG59XG5cbi8qXHJcbiogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuKi9cbi8qKlxyXG4gKiBDYW1lcmEncyB6b29tIGNvbnRyb2xcclxuICogQGtvIOy5tOuplOudvOydmCDspIwg6rCS7J2EIOuLtOuLue2VmOuKlCDsu6jtirjroaRcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgWm9vbUNvbnRyb2wgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcclxuICAgKiBAY29weSBDYW1lcmFDb250cm9sI2VuYWJsZWRcclxuICAgKi9cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICBnZXQgZW5hYmxlQmxvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlQmxvY2tlZDtcbiAgfVxuICAvKipcclxuICAgKiBAY29weSBDYW1lcmFDb250cm9sI2FuaW1hdGluZ1xyXG4gICAqL1xuICBnZXQgYW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9tb3Rpb24uYWN0aXZhdGVkO1xuICB9XG4gIC8qKlxyXG4gICAqIEN1cnJlbnQgem9vbSB2YWx1ZVxyXG4gICAqIEBrbyDtmITsnqwg7KSMIOqwklxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xuICBnZXQgem9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW90aW9uLnZhbDtcbiAgfVxuICAvKipcclxuICAgKiBAY29weSBWaWV3MzYwI3doZWVsU2Nyb2xsYWJsZVxyXG4gICAqL1xuICBnZXQgc2Nyb2xsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2hlZWxJbnB1dC5zY3JvbGxhYmxlO1xuICB9XG4gIHNldCBzY3JvbGxhYmxlKHZhbCkge1xuICAgIHRoaXMuX3doZWVsSW5wdXQuc2Nyb2xsYWJsZSA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBAaGlkZGVuXHJcbiAgICovXG4gIGdldCByYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW90aW9uLnJhbmdlO1xuICB9XG4gIC8qKlxyXG4gICAqIFNjYWxlIGZhY3RvciBvZiB0aGUgem9vbVxyXG4gICAqIEBrbyDsnoXroKXsl5Ag7J2Y7ZWcIOykjCDrsLDsnKhcclxuICAgKiBAZGVmYXVsdCAxXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gIH1cbiAgc2V0IHNjYWxlKHZhbCkge1xuICAgIHRoaXMuX3NjYWxlID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIER1cmF0aW9uIG9mIHRoZSBpbnB1dCBhbmltYXRpb24gKG1zKVxyXG4gICAqIEBrbyDtmozsoIQg7JWg64uI66mU7J207IWY7J2YIOyLnOqwhCAobXMpXHJcbiAgICogQGRlZmF1bHQgMzAwXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW90aW9uLmR1cmF0aW9uO1xuICB9XG4gIC8qKlxyXG4gICAqIEVhc2luZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICogQGtvIO2ajOyghCDslaDri4jrqZTsnbTshZjsl5Ag7KCB7Jqp7ZWgIGVhc2luZyDtlajsiJhcclxuICAgKiBAZGVmYXVsdCBFQVNJTkcuRUFTRV9PVVRfQ1VCSUNcclxuICAgKiBAc2VlIEVBU0lOR1xyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgZWFzaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9tb3Rpb24uZWFzaW5nO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgWm9vbUNvbnRyb2wgaW5zdGFuY2VcclxuICAgKiBAa28gWm9vbUNvbnRyb2zsnZgg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gY29udHJvbEVsIC0gRWxlbWVudCB0byBhdHRhY2ggaGFuZGxlcnMge0BrbyDsnoXroKXsnYQg67Cb7J2EIOyXmOumrOuovO2KuH1cclxuICAgKiBAcGFyYW0gZW5hYmxlQmxvY2tlZCAtIFdoZXRoZXIgdG8gZGlzYWJsZSBjb250cm9sIG9uIGluaXQge0BrbyDstIjquLDtmZQg6rO87KCV7JeQ7IScIOy7qO2KuOuhpCDtmZzshLHtmZQg7Jes67aAfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgY29udHJvbCB7QGtvIOy7qO2KuOuhpCDsmLXshZjrk6R9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyb2xFbCwgZW5hYmxlQmxvY2tlZCwge1xuICAgIHNjYWxlID0gMSxcbiAgICBkdXJhdGlvbiA9IERFRkFVTFRfQU5JTUFUSU9OX0RVUkFUSU9OLFxuICAgIGVhc2luZyA9IERFRkFVTFRfRUFTSU5HXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fb25JbnB1dFN0YXJ0ID0gZXZ0ID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldnQpLCB7XG4gICAgICAgIGlucHV0VHlwZTogXCJ6b29tXCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIHRoaXMuX29uQ2hhbmdlID0gKHtcbiAgICAgIGRlbHRhXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zY2FsZTtcbiAgICAgIGNvbnN0IHNjYWxlZERlbHRhID0gZGVsdGEgKiBzY2FsZTtcbiAgICAgIHRoaXMuX21vdGlvbi5zZXROZXdFbmRCeURlbHRhKHNjYWxlZERlbHRhKTtcbiAgICB9O1xuICAgIHRoaXMuX29uSW5wdXRFbmQgPSBldnQgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldnQpLCB7XG4gICAgICAgIGlucHV0VHlwZTogXCJ6b29tXCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5fY29udHJvbEVsID0gY29udHJvbEVsO1xuICAgIHRoaXMuX2VuYWJsZUJsb2NrZWQgPSBlbmFibGVCbG9ja2VkO1xuICAgIHRoaXMuX3doZWVsSW5wdXQgPSBuZXcgV2hlZWxJbnB1dCgpO1xuICAgIHRoaXMuX3BpbmNoSW5wdXQgPSBuZXcgUGluY2hJbnB1dCgpO1xuICAgIHRoaXMuX21vdGlvbiA9IG5ldyBNb3Rpb24oe1xuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcsXG4gICAgICByYW5nZTogSU5GSU5JVEVfUkFOR0VcbiAgICB9KTtcbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYmluZElucHV0cygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fd2hlZWxJbnB1dC5vZmYoKTtcbiAgICB0aGlzLl9waW5jaElucHV0Lm9mZigpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICB1cGRhdGUoZGVsdGEpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCBtb3Rpb24gPSB0aGlzLl9tb3Rpb247XG4gICAgbW90aW9uLnVwZGF0ZShkZWx0YSk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLl9lbmFibGVkKSByZXR1cm47XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NvbnRyb2xFbDtcbiAgICB0aGlzLl93aGVlbElucHV0LmVuYWJsZShlbGVtZW50KTtcbiAgICB0aGlzLl9waW5jaElucHV0LmVuYWJsZShlbGVtZW50KTtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9lbmFibGVCbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLkVOQUJMRSwge1xuICAgICAgY29udHJvbDogdGhpcyxcbiAgICAgIHVwZGF0ZUN1cnNvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuX3doZWVsSW5wdXQuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3BpbmNoSW5wdXQuZGlzYWJsZSgpO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuRElTQUJMRSwge1xuICAgICAgdXBkYXRlQ3Vyc29yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHN5bmMoY2FtZXJhKSB7XG4gICAgY29uc3QgbW90aW9uID0gdGhpcy5fbW90aW9uO1xuICAgIGNvbnN0IHJhbmdlID0gY2FtZXJhLmdldFpvb21SYW5nZSgpO1xuICAgIG1vdGlvbi5zZXRSYW5nZShyYW5nZS5taW4sIHJhbmdlLm1heCk7XG4gICAgbW90aW9uLnJlc2V0KHJhbmdlLmN1cnJlbnQpO1xuICB9XG4gIF9iaW5kSW5wdXRzKCkge1xuICAgIGNvbnN0IHdoZWVsSW5wdXQgPSB0aGlzLl93aGVlbElucHV0O1xuICAgIGNvbnN0IHBpbmNoSW5wdXQgPSB0aGlzLl9waW5jaElucHV0O1xuICAgIHdoZWVsSW5wdXQub24oQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIHRoaXMuX29uSW5wdXRTdGFydCk7XG4gICAgd2hlZWxJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5DSEFOR0UsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB3aGVlbElucHV0Lm9uKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCwgdGhpcy5fb25JbnB1dEVuZCk7XG4gICAgcGluY2hJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgdGhpcy5fb25JbnB1dFN0YXJ0KTtcbiAgICBwaW5jaElucHV0Lm9uKENPTlRST0xfRVZFTlRTLkNIQU5HRSwgdGhpcy5fb25DaGFuZ2UpO1xuICAgIHBpbmNoSW5wdXQub24oQ09OVFJPTF9FVkVOVFMuSU5QVVRfRU5ELCB0aGlzLl9vbklucHV0RW5kKTtcbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG5jb25zdCBST1RBVEVfQ09OU1RBTlQgPSB7XG4gIFBJVENIX0RFTFRBOiAxLFxuICBZQVdfREVMVEFfQllfUk9MTDogMixcbiAgWUFXX0RFTFRBX0JZX1lBVzogM1xufTtcblJPVEFURV9DT05TVEFOVFtST1RBVEVfQ09OU1RBTlQuUElUQ0hfREVMVEFdID0ge1xuICB0YXJnZXRBeGlzOiBbMCwgMSwgMF0sXG4gIG1lc2hQb2ludDogWzAsIDAsIDFdXG59O1xuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfUk9MTF0gPSB7XG4gIHRhcmdldEF4aXM6IFswLCAxLCAwXSxcbiAgbWVzaFBvaW50OiBbMSwgMCwgMF1cbn07XG5ST1RBVEVfQ09OU1RBTlRbUk9UQVRFX0NPTlNUQU5ULllBV19ERUxUQV9CWV9ZQVddID0ge1xuICB0YXJnZXRBeGlzOiBbMSwgMCwgMF0sXG4gIG1lc2hQb2ludDogWzAsIDAsIDFdXG59O1xuY2xhc3MgR3lyb0lucHV0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgZ2V0IG9yaWVudGF0aW9uVXBkYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25VcGRhdGVkO1xuICB9XG4gIGdldCBpZ25vcmVSb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9pZ25vcmVSb2xsO1xuICB9XG4gIHNldCBpZ25vcmVSb2xsKHZhbCkge1xuICAgIHRoaXMuX2lnbm9yZVJvbGwgPSB2YWw7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uID0gZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHByZXZPcmllbnRhdGlvbiA9IHRoaXMuX29yaWVudGF0aW9uO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbHBoYSxcbiAgICAgICAgYmV0YSxcbiAgICAgICAgZ2FtbWFcbiAgICAgIH0gPSBldnQ7XG4gICAgICBpZiAoYWxwaGEgPT0gbnVsbCB8fCBiZXRhID09IG51bGwgfHwgZ2FtbWEgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgcHJldk9yaWVudGF0aW9uLmFscGhhID0gYWxwaGE7XG4gICAgICBwcmV2T3JpZW50YXRpb24uYmV0YSA9IGJldGE7XG4gICAgICBwcmV2T3JpZW50YXRpb24uZ2FtbWEgPSBnYW1tYTtcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uVXBkYXRlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5fbmVlZHNDYWxpYnJhdGUpIHtcbiAgICAgICAgdGhpcy5fbmVlZHNDYWxpYnJhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2FsaWJyYXRlU2Vuc29yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl91cGRhdGVTY3JlZW5PcmllbnRhdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cuc2NyZWVuICYmIHdpbmRvdy5zY3JlZW4ub3JpZW50YXRpb24gJiYgd2luZG93LnNjcmVlbi5vcmllbnRhdGlvbi5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uID0gc2NyZWVuLm9yaWVudGF0aW9uLmFuZ2xlO1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cub3JpZW50YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zY3JlZW5PcmllbnRhdGlvbiA9IHdpbmRvdy5vcmllbnRhdGlvbiA+PSAwID8gd2luZG93Lm9yaWVudGF0aW9uIDogMzYwICsgd2luZG93Lm9yaWVudGF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2NyZWVuT3JpZW50YXRpb24gPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5xdWF0ZXJuaW9uID0gcXVhdC5jcmVhdGUoKTtcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IHtcbiAgICAgIGFscGhhOiAwLFxuICAgICAgYmV0YTogOTAsXG4gICAgICBnYW1tYTogMFxuICAgIH07XG4gICAgdGhpcy5feWF3T3JpZ2luID0gMDtcbiAgICB0aGlzLl95YXdPZmZzZXQgPSAwO1xuICAgIHRoaXMuX29yaWVudGF0aW9uVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uID0gMDtcbiAgICB0aGlzLl9uZWVkc0NhbGlicmF0ZSA9IHRydWU7XG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkgcmV0dXJuO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLkRFVklDRV9PUklFTlRBVElPTiwgdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuT1JJRU5UQVRJT05fQ0hBTkdFLCB0aGlzLl91cGRhdGVTY3JlZW5PcmllbnRhdGlvbik7XG4gICAgdGhpcy5fdXBkYXRlU2NyZWVuT3JpZW50YXRpb24oKTtcbiAgICB0aGlzLl9vcmllbnRhdGlvblVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9uZWVkc0NhbGlicmF0ZSA9IHRydWU7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHJldHVybjtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5ERVZJQ0VfT1JJRU5UQVRJT04sIHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24pO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLk9SSUVOVEFUSU9OX0NIQU5HRSwgdGhpcy5fdXBkYXRlU2NyZWVuT3JpZW50YXRpb24pO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fdXBkYXRlUm90YXRpb24oKTtcbiAgICB0aGlzLl9vcmllbnRhdGlvblVwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBjb2xsZWN0RGVsdGEoKSB7XG4gICAgaWYgKCF0aGlzLl9vcmllbnRhdGlvblVwZGF0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBpdGNoOiAwLFxuICAgICAgICB5YXc6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZXZSb3RhdGlvbiA9IHF1YXQuY2xvbmUodGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLl91cGRhdGVSb3RhdGlvbigpO1xuICAgIHRoaXMuX29yaWVudGF0aW9uVXBkYXRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLl90b0V1bGVyRGVsdGEocHJldlJvdGF0aW9uLCB0aGlzLnF1YXRlcm5pb24pO1xuICB9XG4gIHNldEluaXRpYWxSb3RhdGlvbih5YXcpIHtcbiAgICB0aGlzLl95YXdPcmlnaW4gPSB5YXc7XG4gIH1cbiAgX2NhbGlicmF0ZVNlbnNvcigpIHtcbiAgICBjb25zdCB5YXdPcmlnaW4gPSB0aGlzLl95YXdPcmlnaW47XG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLnF1YXRlcm5pb247XG4gICAgdGhpcy5feWF3T2Zmc2V0ID0gMDtcbiAgICB0aGlzLl91cGRhdGVSb3RhdGlvbigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHlhdzogc2Vuc29yWWF3XG4gICAgfSA9IHF1YXRUb0V1bGVyKHJvdGF0aW9uKTtcbiAgICB0aGlzLl95YXdPZmZzZXQgPSBzZW5zb3JZYXcgLSB5YXdPcmlnaW47XG4gICAgdGhpcy5fdXBkYXRlUm90YXRpb24oKTtcbiAgICB0aGlzLl9uZWVkc0NhbGlicmF0ZSA9IGZhbHNlO1xuICB9XG4gIF91cGRhdGVSb3RhdGlvbigpIHtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMucXVhdGVybmlvbjtcbiAgICBjb25zdCB7XG4gICAgICBhbHBoYSxcbiAgICAgIGJldGEsXG4gICAgICBnYW1tYVxuICAgIH0gPSB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICBxdWF0LmlkZW50aXR5KHJvdGF0aW9uKTtcbiAgICBxdWF0LnJvdGF0ZVkocm90YXRpb24sIHJvdGF0aW9uLCAoYWxwaGEgLSB0aGlzLl95YXdPZmZzZXQpICogREVHX1RPX1JBRCk7XG4gICAgcXVhdC5yb3RhdGVYKHJvdGF0aW9uLCByb3RhdGlvbiwgYmV0YSAqIERFR19UT19SQUQpO1xuICAgIHF1YXQucm90YXRlWihyb3RhdGlvbiwgcm90YXRpb24sIC1nYW1tYSAqIERFR19UT19SQUQpO1xuICAgIGNvbnN0IHNjcmVlbiA9IHF1YXQuY3JlYXRlKCk7XG4gICAgY29uc3Qgc2NyZWVuQW5nbGUgPSAtdGhpcy5fc2NyZWVuT3JpZW50YXRpb24gKiAwLjUgKiBERUdfVE9fUkFEO1xuICAgIGNvbnN0IHdvcmxkID0gcXVhdC5mcm9tVmFsdWVzKC1NYXRoLnNxcnQoMC41KSwgMCwgMCwgTWF0aC5zcXJ0KDAuNSkpO1xuICAgIHF1YXQuc2V0KHNjcmVlbiwgMCwgTWF0aC5zaW4oc2NyZWVuQW5nbGUpLCAwLCBNYXRoLmNvcyhzY3JlZW5BbmdsZSkpO1xuICAgIHF1YXQubXVsdGlwbHkocm90YXRpb24sIHJvdGF0aW9uLCBzY3JlZW4pO1xuICAgIHF1YXQubXVsdGlwbHkocm90YXRpb24sIHJvdGF0aW9uLCB3b3JsZCk7XG4gICAgcXVhdC5ub3JtYWxpemUocm90YXRpb24sIHJvdGF0aW9uKTtcbiAgfVxuICBfdG9FdWxlckRlbHRhKHByZXZRdWF0LCBjdXJyZW50UXVhdCkge1xuICAgIHJldHVybiB7XG4gICAgICB5YXc6IHRoaXMuX2dldERlbHRhWWF3KHByZXZRdWF0LCBjdXJyZW50UXVhdCksXG4gICAgICBwaXRjaDogdGhpcy5fZ2V0RGVsdGFQaXRjaChwcmV2UXVhdCwgY3VycmVudFF1YXQpXG4gICAgfTtcbiAgfVxuICBfZ2V0RGVsdGFZYXcocHJ2USwgY3VyUSkge1xuICAgIGNvbnN0IHlhd0RlbHRhQnlZYXcgPSB0aGlzLl9nZXRSb3RhdGlvbkRlbHRhKHBydlEsIGN1clEsIFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKTtcbiAgICBjb25zdCB5YXdEZWx0YUJ5Um9sbCA9IHRoaXMuX2dldFJvdGF0aW9uRGVsdGEocHJ2USwgY3VyUSwgUk9UQVRFX0NPTlNUQU5ULllBV19ERUxUQV9CWV9ST0xMKSAqIE1hdGguc2luKHRoaXMuX2V4dHJhY3RQaXRjaEZyb21RdWF0KGN1clEpKTtcbiAgICByZXR1cm4geWF3RGVsdGFCeVJvbGwgKyB5YXdEZWx0YUJ5WWF3O1xuICB9XG4gIF9nZXREZWx0YVBpdGNoKHBydlEsIGN1clEpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Um90YXRpb25EZWx0YShwcnZRLCBjdXJRLCBST1RBVEVfQ09OU1RBTlQuUElUQ0hfREVMVEEpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkRlbHRhKHByZXZRLCBjdXJRLCByb3RhdGVLaW5kKSB7XG4gICAgY29uc3QgdGFyZ2V0QXhpcyA9IHZlYzMuZnJvbVZhbHVlcyhST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1swXSwgUk9UQVRFX0NPTlNUQU5UW3JvdGF0ZUtpbmRdLnRhcmdldEF4aXNbMV0sIFJPVEFURV9DT05TVEFOVFtyb3RhdGVLaW5kXS50YXJnZXRBeGlzWzJdKTtcbiAgICBjb25zdCBtZXNoUG9pbnQgPSBST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0ubWVzaFBvaW50O1xuICAgIGNvbnN0IHByZXZRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShwcmV2USk7XG4gICAgY29uc3QgY3VyUXVhdGVybmlvbiA9IHF1YXQuY2xvbmUoY3VyUSk7XG4gICAgcXVhdC5ub3JtYWxpemUocHJldlF1YXRlcm5pb24sIHByZXZRdWF0ZXJuaW9uKTtcbiAgICBxdWF0Lm5vcm1hbGl6ZShjdXJRdWF0ZXJuaW9uLCBjdXJRdWF0ZXJuaW9uKTtcbiAgICBsZXQgcHJldlBvaW50ID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDEpO1xuICAgIGxldCBjdXJQb2ludCA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAxKTtcbiAgICB2ZWMzLnRyYW5zZm9ybVF1YXQocHJldlBvaW50LCBwcmV2UG9pbnQsIHByZXZRdWF0ZXJuaW9uKTtcbiAgICB2ZWMzLnRyYW5zZm9ybVF1YXQoY3VyUG9pbnQsIGN1clBvaW50LCBjdXJRdWF0ZXJuaW9uKTtcbiAgICB2ZWMzLnRyYW5zZm9ybVF1YXQodGFyZ2V0QXhpcywgdGFyZ2V0QXhpcywgY3VyUXVhdGVybmlvbik7XG4gICAgY29uc3Qgcm90YXRlRGlzdGFuY2UgPSB2ZWMzLmRvdCh0YXJnZXRBeGlzLCB2ZWMzLmNyb3NzKHZlYzMuY3JlYXRlKCksIHByZXZQb2ludCwgY3VyUG9pbnQpKTtcbiAgICBjb25zdCByb3RhdGVEaXJlY3Rpb24gPSByb3RhdGVEaXN0YW5jZSA+IDAgPyAxIDogLTE7XG4gICAgLy8gd2hlbiBjb3VudGVyIGNsb2NrIHdpc2UsIHVzZSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApXG4gICAgLy8gd2hlbiBjbG9jayB3aXNlLCB1c2UgdmVjMy5mcm9tVmFsdWVzKDAsLTEsMClcbiAgICAvLyBjb25zdCBtZXNoUG9pbnQxID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApO1xuICAgIGNvbnN0IG1lc2hQb2ludDIgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG4gICAgbGV0IG1lc2hQb2ludDM7XG4gICAgaWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG4gICAgICBtZXNoUG9pbnQzID0gdmVjMy5mcm9tVmFsdWVzKDAsIHJvdGF0ZURpcmVjdGlvbiwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc2hQb2ludDMgPSB2ZWMzLmZyb21WYWx1ZXMocm90YXRlRGlyZWN0aW9uLCAwLCAwKTtcbiAgICB9XG4gICAgdmVjMy50cmFuc2Zvcm1RdWF0KG1lc2hQb2ludDIsIG1lc2hQb2ludDIsIGN1clF1YXRlcm5pb24pO1xuICAgIHZlYzMudHJhbnNmb3JtUXVhdChtZXNoUG9pbnQzLCBtZXNoUG9pbnQzLCBjdXJRdWF0ZXJuaW9uKTtcbiAgICBjb25zdCB2ZWNVID0gbWVzaFBvaW50MjtcbiAgICBjb25zdCB2ZWNWID0gbWVzaFBvaW50MztcbiAgICBjb25zdCB2ZWNOID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2ZWMzLmNyb3NzKHZlY04sIHZlY1UsIHZlY1YpO1xuICAgIHZlYzMubm9ybWFsaXplKHZlY04sIHZlY04pO1xuICAgIGNvbnN0IGNvZWZmaWNpZW50QSA9IHZlY05bMF07XG4gICAgY29uc3QgY29lZmZpY2llbnRCID0gdmVjTlsxXTtcbiAgICBjb25zdCBjb2VmZmljaWVudEMgPSB2ZWNOWzJdO1xuICAgIC8vIGEgcG9pbnQgb24gdGhlIHBsYW5lXG4gICAgY3VyUG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG4gICAgdmVjMy50cmFuc2Zvcm1RdWF0KGN1clBvaW50LCBjdXJQb2ludCwgY3VyUXVhdGVybmlvbik7XG4gICAgLy8gYSBwb2ludCBzaG91bGQgcHJvamVjdCBvbiB0aGUgcGxhbmVcbiAgICBwcmV2UG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG4gICAgdmVjMy50cmFuc2Zvcm1RdWF0KHByZXZQb2ludCwgcHJldlBvaW50LCBwcmV2UXVhdGVybmlvbik7XG4gICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBwcmV2UG9pbnQgYW5kIHRoZSBwbGFuZVxuICAgIGxldCBkaXN0YW5jZSA9IE1hdGguYWJzKHByZXZQb2ludFswXSAqIGNvZWZmaWNpZW50QSArIHByZXZQb2ludFsxXSAqIGNvZWZmaWNpZW50QiArIHByZXZQb2ludFsyXSAqIGNvZWZmaWNpZW50Qyk7XG4gICAgY29uc3QgcHJvamVjdGVkUHJldlBvaW50ID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2ZWMzLnN1YnRyYWN0KHByb2plY3RlZFByZXZQb2ludCwgcHJldlBvaW50LCB2ZWMzLnNjYWxlKHZlYzMuY3JlYXRlKCksIHZlY04sIGRpc3RhbmNlKSk7XG4gICAgbGV0IHRyaWdvbm9tZXRyaWNSYXRpbyA9IChwcm9qZWN0ZWRQcmV2UG9pbnRbMF0gKiBjdXJQb2ludFswXSArIHByb2plY3RlZFByZXZQb2ludFsxXSAqIGN1clBvaW50WzFdICsgcHJvamVjdGVkUHJldlBvaW50WzJdICogY3VyUG9pbnRbMl0pIC8gKHZlYzMubGVuZ3RoKHByb2plY3RlZFByZXZQb2ludCkgKiB2ZWMzLmxlbmd0aChjdXJQb2ludCkpO1xuICAgIC8vIGRlZmVuc2l2ZSBibG9ja1xuICAgIGlmICh0cmlnb25vbWV0cmljUmF0aW8gPiAxKSB7XG4gICAgICB0cmlnb25vbWV0cmljUmF0aW8gPSAxO1xuICAgIH1cbiAgICBjb25zdCB0aGV0YSA9IE1hdGguYWNvcyh0cmlnb25vbWV0cmljUmF0aW8pO1xuICAgIGNvbnN0IGNyb3NzVmVjID0gdmVjMy5jcm9zcyh2ZWMzLmNyZWF0ZSgpLCBjdXJQb2ludCwgcHJvamVjdGVkUHJldlBvaW50KTtcbiAgICBkaXN0YW5jZSA9IGNvZWZmaWNpZW50QSAqIGNyb3NzVmVjWzBdICsgY29lZmZpY2llbnRCICogY3Jvc3NWZWNbMV0gKyBjb2VmZmljaWVudEMgKiBjcm9zc1ZlY1syXTtcbiAgICBsZXQgdGhldGFEaXJlY3Rpb247XG4gICAgaWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG4gICAgICB0aGV0YURpcmVjdGlvbiA9IGRpc3RhbmNlID4gMCA/IDEgOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhldGFEaXJlY3Rpb24gPSBkaXN0YW5jZSA8IDAgPyAxIDogLTE7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhUmFkaWFuID0gdGhldGEgKiB0aGV0YURpcmVjdGlvbiAqIHJvdGF0ZURpcmVjdGlvbjtcbiAgICByZXR1cm4gZGVsdGFSYWRpYW4gKiBSQURfVE9fREVHO1xuICB9XG4gIF9leHRyYWN0UGl0Y2hGcm9tUXVhdChxdWF0ZXJuaW9uKSB7XG4gICAgY29uc3QgYmFzZVYgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSk7XG4gICAgdmVjMy50cmFuc2Zvcm1RdWF0KGJhc2VWLCBiYXNlViwgcXVhdGVybmlvbik7XG4gICAgcmV0dXJuIC0xICogTWF0aC5hdGFuMihiYXNlVlsxXSwgTWF0aC5zcXJ0KE1hdGgucG93KGJhc2VWWzBdLCAyKSArIE1hdGgucG93KGJhc2VWWzJdLCAyKSkpO1xuICB9XG59XG5cbi8qKlxyXG4gKiBDYW1lcmEncyByb3RhdGlvbiBjb250cm9sIGJ5IGd5cm9zY29wZVxyXG4gKiBAa28g7J6Q7J2066Gc7Iqk7L2U7ZSE66W8IOydtOyaqe2VnCDtmozsoIQg7Luo7Yq466GkXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cbmNsYXNzIEd5cm9Db250cm9sIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXHJcbiAgICogQGNvcHkgQ2FtZXJhQ29udHJvbCNlbmFibGVkXHJcbiAgICovXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC5lbmFibGVkO1xuICB9XG4gIC8qKlxyXG4gICAqIEBoaWRkZW5cclxuICAgKi9cbiAgZ2V0IGVuYWJsZUJsb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZUJsb2NrZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQGNvcHkgQ2FtZXJhQ29udHJvbCNhbmltYXRpbmdcclxuICAgKi9cbiAgZ2V0IGFuaW1hdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQuZW5hYmxlZCAmJiB0aGlzLl9pbnB1dC5vcmllbnRhdGlvblVwZGF0ZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hlbiBgdHJ1ZWAsIGlnbm9yZSBneXJvc2NvcGUncyByb2xsKHotYXhpcyByb3RhdGlvbikgdmFsdWUuXHJcbiAgICogOjo6Y2F1dGlvblxyXG4gICAqIFNldHRpbmcgYGZhbHNlYCB3aWxsIGlnbm9yZSBjYW1lcmEncyByYW5nZSBsaW1pdC5cclxuICAgKiBPcHRpb25zIGxpa2Uge0BsaW5rIFZpZXczNjBPcHRpb25zI3lhd1JhbmdlfSwge0BsaW5rIFZpZXczNjBPcHRpb25zI3BpdGNoUmFuZ2V9IGFyZSBpZ25vcmVkLCBhbmQge0BsaW5rIEN5bGluZGVyUHJvamVjdGlvbn0gYWxzbyBjYW4ndCBmb3JjZSBpdCdzIGNhbWVyYSByYW5nZSBsaW1pdC5cclxuICAgKiA6OjpcclxuICAgKiBAa28gYHRydWVg7J28IOqyveyasCDsnpDsnbTroZzsiqTsvZTtlIQg7J6F66Cl7J2YIHJvbGwoeuy2lSDtmozsoIQp6rCS7J2EIOustOyLnO2VqeuLiOuLpC5cclxuICAgKiA6OjpjYXV0aW9uXHJcbiAgICog7J20IOqwkuydhCBgZmFsc2Vg66GcIOyEpOygle2VoCDqsr3smrAg7Lm066mU6528IOuylOychCDsoJzslb3snYQg66y07Iuc7ZWp64uI64ukLlxyXG4gICAqIHtAbGluayBWaWV3MzYwT3B0aW9ucyN5YXdSYW5nZX0sIHtAbGluayBWaWV3MzYwT3B0aW9ucyNwaXRjaFJhbmdlfeyZgCDqsJnsnYAg6rCS7J2AIOustOyLnOuQmOupsCwge0BsaW5rIEN5bGluZGVyUHJvamVjdGlvbn0g7IKs7Jqp7Iuc7JeQ64+EIOuylOychOulvCDrspfslrTrgqAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgKiA6OjpcclxuICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBpZ25vcmVSb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9pZ25vcmVSb2xsO1xuICB9XG4gIHNldCBpZ25vcmVSb2xsKHZhbCkge1xuICAgIHRoaXMuX2lnbm9yZVJvbGwgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIGF2YWlsYWJpbGl0eSBvZiB0aGUgZ3lyb3Njb3BlLlxyXG4gICAqIDo6OmNhdXRpb25cclxuICAgKiBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSB1bnRpbCB1c2VyIHBlcm1pc3Npb24gdW5kZXIgZW52aXJvbm1lbnRzIGxpa2UgaU9TIHdoaWNoIHJlcXVpcmVzIHVzZXIgcGVybWlzc2lvbiB3aGVuIHVzaW5nIGd5cm9zY29wZS5cclxuICAgKiA6OjpcclxuICAgKiBAa28g7J6Q7J2066Gc7Iqk7L2U7ZSEIOyCrOyaqSDqsIDriqUg7Jes67aA66W8IOuwmO2ZmO2VqeuLiOuLpC5cclxuICAgKiA6OjpjYXV0aW9uXHJcbiAgICogaU9T7JmAIOqwmeydtCBHeXJvU2NvcGUg7IKs7Jqp7IucIOyCrOyaqeyekCBQZXJtaXNzaW9u7J2EIOyalOq1rO2VmOuKlCDtmZjqsr3sl5DshJzripQg7IKs7Jqp7J6QIFBlcm1pc3Npb27snYQg67Cb6riwIOyghOq5jOyngCDtla3sg4EgYGZhbHNlYOyeheuLiOuLpC5cclxuICAgKiA6OjpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3QgZ3lyb0F2YWlsYWJsZSA9IGF3YWl0IEd5cm9Db250cm9sLmlzQXZhaWxhYmxlKCk7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFEZXZpY2VNb3Rpb25FdmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgb25EZXZpY2VNb3Rpb25DaGFuZ2U7XG4gICAgICBjb25zdCBsaXN0ZW5EZXZpY2VNb3Rpb24gPSAoKSA9PiBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgICAgICBvbkRldmljZU1vdGlvbkNoYW5nZSA9IGV2dCA9PiB7XG4gICAgICAgICAgcmVzKGV2dC5yb3RhdGlvblJhdGUgJiYgZXZ0LnJvdGF0aW9uUmF0ZS5hbHBoYSAhPSBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuREVWSUNFX01PVElPTiwgb25EZXZpY2VNb3Rpb25DaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gKCkgPT4gbmV3IFByb21pc2UocmVzID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXMoZmFsc2UpLCAxMDAwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbbGlzdGVuRGV2aWNlTW90aW9uKCksIHRpbWVvdXQoKV0pLnRoZW4oYXZhaWxhYmxlID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuREVWSUNFX01PVElPTiwgb25EZXZpY2VNb3Rpb25DaGFuZ2UpO1xuICAgICAgICByZXR1cm4gYXZhaWxhYmxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVxdWVzdCB1c2VyIHBlcm1pc3Npb24gZm9yIGd5cm9zY29wZSBzZW5zb3IuXHJcbiAgICogVGhpcyBjYW4gYmUgdXNlZCBpbiBlbnZpcm9ubWVudHMgbGlrZSBpT1Mgd2hpY2ggcmVxdWlyZXMgdXNlciBwZXJtaXNzaW9uIHdoZW4gdXNpbmcgZ3lyb3Njb3BlIHNlbnNvcnMuXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCBzZW5zb3IgcGVybWlzc2lvbiDst6jrk53snYQg7JqU7LKt7ZWp64uI64ukLlxyXG4gICAqIGlPU+yZgCDqsJnsnbQgZ3lyb3Njb3BlIOyCrOyaqeyLnCDsgqzsmqnsnpAgUGVybWlzc2lvbuydhCDsmpTqtaztlZjripQg7ZmY6rK97JeQ7IScIOyCrOyaqSDqsIDriqXtlanri4jri6QuXHJcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgcGVybWlzc2lvbiBpcyBncmFudGVkIHtAa28g7IKs7Jqp7J6QIHBlcm1pc3Npb24g7Leo65OdIOyXrOu2gH1cclxuICAgKi9cbiAgc3RhdGljIHJlcXVlc3RTZW5zb3JQZXJtaXNzaW9uKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBSZXF1ZXN0IHNlbnNvciBwZXJtaXNzaW9uLCBvbiBpT1MxMytcbiAgICAgIGlmIChzZW5zb3JDYW5CZUVuYWJsZWRJT1MoKSkge1xuICAgICAgICByZXR1cm4gRGV2aWNlTW90aW9uRXZlbnQucmVxdWVzdFBlcm1pc3Npb24oKS50aGVuKHBlcm1pc3Npb25TdGF0ZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25TdGF0ZSA9PT0gXCJncmFudGVkXCI7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgR3lyb0NvbnRyb2wgaW5zdGFuY2VcclxuICAgKiBAa28gR3lyb0NvbnRyb2zsnZgg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gZW5hYmxlQmxvY2tlZCAtIFdoZXRoZXIgdG8gZGlzYWJsZSBjb250cm9sIG9uIGluaXQge0BrbyDstIjquLDtmZQg6rO87KCV7JeQ7IScIOy7qO2KuOuhpCDtmZzshLHtmZQg7Jes67aAfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgY29udHJvbCB7QGtvIOy7qO2KuOuhpCDsmLXshZjrk6R9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuYWJsZUJsb2NrZWQsIHtcbiAgICBpZ25vcmVSb2xsID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2VuYWJsZUJsb2NrZWQgPSBlbmFibGVCbG9ja2VkO1xuICAgIHRoaXMuX2lnbm9yZVJvbGwgPSBpZ25vcmVSb2xsO1xuICAgIHRoaXMuX2lucHV0ID0gbmV3IEd5cm9JbnB1dCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IENhbWVyYUNvbnRyb2wjZGVzdHJveVxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX2lucHV0Lm9mZigpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICB1cGRhdGUoY2FtZXJhLCB5YXcsIHBpdGNoLCB6b29tKSB7XG4gICAgaWYgKCF0aGlzLl9pZ25vcmVSb2xsKSB7XG4gICAgICB0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKGNhbWVyYSwgem9vbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVlhd1BpdGNoKGNhbWVyYSwgeWF3LCBwaXRjaCwgem9vbSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IENhbWVyYUNvbnRyb2wjZW5hYmxlXHJcbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5faW5wdXQuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2lucHV0LmVuYWJsZSgpO1xuICAgIHRoaXMuX2VuYWJsZUJsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuRU5BQkxFLCB7XG4gICAgICBjb250cm9sOiB0aGlzLFxuICAgICAgdXBkYXRlQ3Vyc29yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IENhbWVyYUNvbnRyb2wjZGlzYWJsZVxyXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIGlmICghdGhpcy5faW5wdXQuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2lucHV0LmRpc2FibGUoKTtcbiAgICB0aGlzLnRyaWdnZXIoQ09OVFJPTF9FVkVOVFMuRElTQUJMRSwge1xuICAgICAgdXBkYXRlQ3Vyc29yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IENhbWVyYUNvbnRyb2wjc3luY1xyXG4gICAqL1xuICBzeW5jKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgX3VwZGF0ZVlhd1BpdGNoKGNhbWVyYSwgeWF3LCBwaXRjaCwgem9vbSkge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5faW5wdXQ7XG4gICAgaWYgKCFpbnB1dC5lbmFibGVkKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgeWF3OiB5YXdEZWx0YSxcbiAgICAgIHBpdGNoOiBwaXRjaERlbHRhXG4gICAgfSA9IGlucHV0LmNvbGxlY3REZWx0YSgpO1xuICAgIHlhdy5hZGQoeWF3RGVsdGEpO1xuICAgIHBpdGNoLmFkZChwaXRjaERlbHRhKTtcbiAgICBjYW1lcmEubG9va0F0KHtcbiAgICAgIHlhdzogeWF3LnZhbCxcbiAgICAgIHBpdGNoOiBwaXRjaC52YWwsXG4gICAgICB6b29tXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZVF1YXRlcm5pb24oY2FtZXJhLCB6b29tKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICBpZiAoIWlucHV0LmVuYWJsZWQpIHJldHVybjtcbiAgICBpbnB1dC51cGRhdGUoKTtcbiAgICBjYW1lcmEucm90YXRlKGlucHV0LnF1YXRlcm5pb24sIHpvb20pO1xuICB9XG59XG5cbi8qKlxyXG4gKiBQYW5vcmFtYSBjb250cm9sIGZvciBWaWV3MzYwXHJcbiAqIEBrbyBWaWV3MzYw7JqpIO2MjOuFuOudvOuniCDsu6jtirjroaRcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgUGFub0NvbnRyb2wge1xuICAvKipcclxuICAgKiBAY29weSBWaWV3MzYwI3VzZUdyYWJDdXJzb3JcclxuICAgKi9cbiAgZ2V0IHVzZUdyYWJDdXJzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZUdyYWJDdXJzb3I7XG4gIH1cbiAgc2V0IHVzZUdyYWJDdXJzb3IodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gdGhpcy5fdXNlR3JhYkN1cnNvcikgcmV0dXJuO1xuICAgIHRoaXMuX3VzZUdyYWJDdXJzb3IgPSB2YWw7XG4gICAgaWYgKHZhbCAmJiB0aGlzLl9lbmFibGVkKSB7XG4gICAgICB0aGlzLl9zZXRDdXJzb3IoQ1VSU09SLkdSQUIpO1xuICAgIH0gZWxzZSBpZiAoIXZhbCkge1xuICAgICAgdGhpcy5fc2V0Q3Vyc29yKENVUlNPUi5OT05FKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQGNvcHkgVmlldzM2MCNkaXNhYmxlQ29udGV4dE1lbnVcclxuICAgKi9cbiAgZ2V0IGRpc2FibGVDb250ZXh0TWVudSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZUNvbnRleHRNZW51O1xuICB9XG4gIHNldCBkaXNhYmxlQ29udGV4dE1lbnUodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gdGhpcy5fZGlzYWJsZUNvbnRleHRNZW51KSByZXR1cm47XG4gICAgdGhpcy5fZGlzYWJsZUNvbnRleHRNZW51ID0gdmFsO1xuICAgIGlmICh2YWwgJiYgdGhpcy5fZW5hYmxlZCkge1xuICAgICAgdGhpcy5fYmxvY2tDb250ZXh0TWVudSgpO1xuICAgIH0gZWxzZSBpZiAoIXZhbCkge1xuICAgICAgdGhpcy5fcmVzdG9yZUNvbnRleHRNZW51KCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IFZpZXczNjAjZGlzYWJsZUNvbnRleHRNZW51XHJcbiAgICovXG4gIGdldCBzY3JvbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3RhdGVDb250cm9sLnNjcm9sbGFibGU7XG4gIH1cbiAgc2V0IHNjcm9sbGFibGUodmFsKSB7XG4gICAgdGhpcy5fcm90YXRlQ29udHJvbC5zY3JvbGxhYmxlID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IFZpZXczNjAjZGlzYWJsZUNvbnRleHRNZW51XHJcbiAgICovXG4gIGdldCB3aGVlbFNjcm9sbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvb21Db250cm9sLnNjcm9sbGFibGU7XG4gIH1cbiAgc2V0IHdoZWVsU2Nyb2xsYWJsZSh2YWwpIHtcbiAgICB0aGlzLl96b29tQ29udHJvbC5zY3JvbGxhYmxlID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIFdoZW4gYHRydWVgLCBkaXNhYmxlcyByb3RhdGlvbiBzbG93LWRvd24gYnkgem9vbS12YWx1ZS5cclxuICAgKiBAa28gYHRydWVg7J28IOqyveyasCDspIwg65CcIOygleuPhOyXkCDrlLDrnbwg7ZqM7KCE7IaN64+E66W8IOuKpuy2lOuKlCDrj5nsnpHsnYQg67mE7Zmc7ISx7ZmU7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgaWdub3JlWm9vbVNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9pZ25vcmVab29tU2NhbGU7XG4gIH1cbiAgc2V0IGlnbm9yZVpvb21TY2FsZSh2YWwpIHtcbiAgICB0aGlzLl9pZ25vcmVab29tU2NhbGUgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgY29udHJvbCBpcyBlbmFibGVkIG9yIG5vdFxyXG4gICAqIEBrbyDsu6jtirjroaQg7Zmc7ISx7ZmUIOyXrOu2gOulvCDqsIDrpqztgqTripQg6rCSXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICB9XG4gIC8qKlxyXG4gICAqIEBjb3B5IFZpZXczNjAjcm90YXRlXHJcbiAgICovXG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0ZUNvbnRyb2w7XG4gIH1cbiAgLyoqXHJcbiAgICogQGNvcHkgVmlldzM2MCN6b29tXHJcbiAgICovXG4gIGdldCB6b29tKCkge1xuICAgIHJldHVybiB0aGlzLl96b29tQ29udHJvbDtcbiAgfVxuICAvKipcclxuICAgKiBAY29weSBWaWV3MzYwI2d5cm9cclxuICAgKi9cbiAgZ2V0IGd5cm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2d5cm9Db250cm9sO1xuICB9XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgb25lIG9mIHRoZSBjb250cm9scyBpcyBhbmltYXRpbmcgYXQgdGhlIG1vbWVudFxyXG4gICAqIEBrbyDtmITsnqwg7Luo7Yq466GkIOykkSDtlZjrgpjrnbzrj4Qg64+Z7J6R7KSR7J247KeAIOyXrOu2gOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBhbmltYXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JvdGF0ZUNvbnRyb2wuYW5pbWF0aW5nIHx8IHRoaXMuX3pvb21Db250cm9sLmFuaW1hdGluZyB8fCB0aGlzLl9neXJvQ29udHJvbC5hbmltYXRpbmc7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBpbnN0YW5jZS5cclxuICAgKiBAa28g7IOIIOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBDYW52YXMgZWxlbWVudCB7QGtvIOy6lOuyhOyKpCDsl5jrpqzrqLztirh9XHJcbiAgICogQHBhcmFtIGNhbWVyYSAtIENhbWVyYSBpbnN0YW5jZSB7QGtvIENhbWVyYSDsnbjsiqTthLTsiqR9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBQYW5vQ29udHJvbCB7QGtvIFBhbm9Db250cm9sIOyYteyFmOuTpH1cclxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY2FtZXJhLCB7XG4gICAgdXNlR3JhYkN1cnNvcixcbiAgICBzY3JvbGxhYmxlLFxuICAgIHdoZWVsU2Nyb2xsYWJsZSxcbiAgICBkaXNhYmxlQ29udGV4dE1lbnUsXG4gICAgcm90YXRlLFxuICAgIHpvb20sXG4gICAgZ3lyb1xuICB9KSB7XG4gICAgdGhpcy5fcHJldmVudENvbnRleHRNZW51ID0gZXZ0ID0+IHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgdGhpcy5fb25JbnB1dFN0YXJ0ID0gZXZ0ID0+IHtcbiAgICAgIGlmICh0aGlzLl91c2VHcmFiQ3Vyc29yICYmICFldnQuaXNLZXlib2FyZCkge1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3IoQ1VSU09SLkdSQUJCSU5HKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uSW5wdXRFbmQgPSBldnQgPT4ge1xuICAgICAgaWYgKHRoaXMuX3VzZUdyYWJDdXJzb3IgJiYgIWV2dC5pc0tleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuX3NldEN1cnNvcihDVVJTT1IuR1JBQik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkVuYWJsZSA9ICh7XG4gICAgICBjb250cm9sLFxuICAgICAgdXBkYXRlQ3Vyc29yXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZUN1cnNvciAmJiB0aGlzLl91c2VHcmFiQ3Vyc29yKSB7XG4gICAgICAgIHRoaXMuX3NldEN1cnNvcihDVVJTT1IuR1JBQik7XG4gICAgICB9XG4gICAgICBjb250cm9sLnN5bmModGhpcy5fY2FtZXJhKTtcbiAgICB9O1xuICAgIHRoaXMuX29uRGlzYWJsZSA9ICh7XG4gICAgICB1cGRhdGVDdXJzb3JcbiAgICB9KSA9PiB7XG4gICAgICBpZiAodXBkYXRlQ3Vyc29yKSB7XG4gICAgICAgIHRoaXMuX3NldEN1cnNvcihDVVJTT1IuTk9ORSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkNhbWVyYUFuaW1hdGlvbkVuZCA9ICh7XG4gICAgICBhbmltYXRpb25cbiAgICB9KSA9PiB7XG4gICAgICBhbmltYXRpb24uZ2V0RmluaXNoUHJvbWlzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gQmluZCBPcHRpb25zXG4gICAgdGhpcy5fdXNlR3JhYkN1cnNvciA9IHVzZUdyYWJDdXJzb3I7XG4gICAgdGhpcy5fZGlzYWJsZUNvbnRleHRNZW51ID0gZGlzYWJsZUNvbnRleHRNZW51O1xuICAgIC8vIFNldCBpbnRlcm5hbCB2YWx1ZXNcbiAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5fY29udHJvbEVsID0gZWxlbWVudDtcbiAgICB0aGlzLl9pZ25vcmVab29tU2NhbGUgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcm90YXRlQ29udHJvbCA9IG5ldyBSb3RhdGVDb250cm9sKGVsZW1lbnQsICFyb3RhdGUsIGdldE9iamVjdE9wdGlvbihyb3RhdGUpKTtcbiAgICB0aGlzLl96b29tQ29udHJvbCA9IG5ldyBab29tQ29udHJvbChlbGVtZW50LCAhem9vbSwgZ2V0T2JqZWN0T3B0aW9uKHpvb20pKTtcbiAgICB0aGlzLl9neXJvQ29udHJvbCA9IG5ldyBHeXJvQ29udHJvbCghZ3lybywgZ2V0T2JqZWN0T3B0aW9uKGd5cm8pKTtcbiAgICB0aGlzLl9yb3RhdGVDb250cm9sLnNjcm9sbGFibGUgPSBzY3JvbGxhYmxlO1xuICAgIHRoaXMuX3pvb21Db250cm9sLnNjcm9sbGFibGUgPSB3aGVlbFNjcm9sbGFibGU7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgdGhlIGluc3RhbmNlIGFuZCByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZC5cclxuICAgKiBUaGlzIGFsc28gd2lsbCByZXNldCBDU1MgY3Vyc29yIHRvIGluaXRpYWwuXHJcbiAgICogQGtvIOyduOyKpO2EtOyKpOulvCDsgq3soJztlZjqs6Ag67aA7LCp65CcIOuqqOuToCDsnbTrsqTtirgg66as7Iqk64SI66W8IOygnOqxsO2VqeuLiOuLpC5cclxuICAgKiDrmJDtlZwsIOy6lOuyhOyKpOyXkCDsoIHsmqnrkJwgQ1NTIGN1cnNvcuuPhCDsoJzqsbDtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fcm90YXRlQ29udHJvbC5kZXN0cm95KCk7XG4gICAgdGhpcy5fem9vbUNvbnRyb2wuZGVzdHJveSgpO1xuICAgIHRoaXMuX3NldEN1cnNvcihDVVJTT1IuTk9ORSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXplIGNvbnRyb2wgdG8gbWF0Y2ggdGFyZ2V0IHNpemUuXHJcbiAgICogQGtvIOy7qO2KuOuhpOydtCDrgrTrtoDsl5Ag7LqQ7Iuc7ZWY6rOgIOyeiOuKlCDtgazquLDqsJLsnYQg6rCx7Iug7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSB3aWR0aCBOZXcgd2lkdGgge0BrbyDrs4Dqsr3rkJwg64SI67mEfVxyXG4gICAqIEBwYXJhbSBoZWlnaHQgTmV3IGhlaWdodCB7QGtvIOuzgOqyveuQnCDrhpLsnbR9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIHRoaXMuX3JvdGF0ZUNvbnRyb2wucmVzaXplKGNhbWVyYS5mb3YsIGNhbWVyYS5hc3BlY3QsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEVuYWJsZSB0aGlzIGNvbnRyb2wgYW5kIGFkZCBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICogQGtvIOy7qO2KuOuhpOydhCDtmZzshLHtmZTtlZjqs6Ag7J2067Kk7Yq4IOumrOyKpOuEiOuTpOydhCDstpTqsIDtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5fcm90YXRlQ29udHJvbC5lbmFibGVCbG9ja2VkKSB7XG4gICAgICAgIHRoaXMuX3JvdGF0ZUNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3pvb21Db250cm9sLmVuYWJsZUJsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5fem9vbUNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2d5cm9Db250cm9sLmVuYWJsZUJsb2NrZWQpIHtcbiAgICAgICAgaWYgKHlpZWxkIEd5cm9Db250cm9sLmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICB0aGlzLl9neXJvQ29udHJvbC5lbmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zeW5jKCk7XG4gICAgICBpZiAodGhpcy5fZGlzYWJsZUNvbnRleHRNZW51KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrQ29udGV4dE1lbnUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIERpc2FibGUgdGhpcyBjb250cm9sIGFuZCByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqIEBrbyDsu6jtirjroaTsnYQg67mE7Zmc7ISx7ZmU7ZWY6rOgIOuqqOuToCDsnbTrsqTtirgg66as7Iqk64SI65Ok7J2EIOygnOqxsO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHJldHVybjtcbiAgICB0aGlzLl9yb3RhdGVDb250cm9sLmRpc2FibGUoKTtcbiAgICB0aGlzLl96b29tQ29udHJvbC5kaXNhYmxlKCk7XG4gICAgdGhpcy5fZ3lyb0NvbnRyb2wuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3Jlc3RvcmVDb250ZXh0TWVudSgpO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgY29udHJvbCBieSBnaXZlbiBkZWx0YVRpbWVcclxuICAgKiBAa28g7Luo7Yq466Gk7J2EIOyjvOyWtOynhCDsi5zqsITrp4ztgbwg7JeF642w7J207Yq47ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBkZWx0YSBOdW1iZXIgb2YgbWlsaXNlYyB0byB1cGRhdGUge0BrbyDsl4XrjbDsnbTtirjtlaAg7Iuc6rCELCDrsIDrpqzstIgg64uo7JyEfVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICB1cGRhdGUoZGVsdGEpIHtcbiAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgY29uc3Qgcm90YXRlQ29udHJvbCA9IHRoaXMuX3JvdGF0ZUNvbnRyb2w7XG4gICAgY29uc3Qgem9vbUNvbnRyb2wgPSB0aGlzLl96b29tQ29udHJvbDtcbiAgICBjb25zdCBneXJvQ29udHJvbCA9IHRoaXMuX2d5cm9Db250cm9sO1xuICAgIHpvb21Db250cm9sLnVwZGF0ZShkZWx0YSk7XG4gICAgY29uc3Qgem9vbSA9IGhmb3ZUb1pvb20oY2FtZXJhLmZvdiwgem9vbUNvbnRyb2wuem9vbSk7XG4gICAgLy8gU2xvdyBkb3duIHJvdGF0aW9uIG9uIHpvb20taW5cbiAgICBjb25zdCB6b29tU2NhbGUgPSB0aGlzLl9pZ25vcmVab29tU2NhbGUgPyAxIDogTWF0aC5tYXgoem9vbSwgMSk7XG4gICAgcm90YXRlQ29udHJvbC5zZXRab29tU2NhbGUoem9vbVNjYWxlKTtcbiAgICByb3RhdGVDb250cm9sLnVwZGF0ZVJhbmdlKGNhbWVyYSwgem9vbSk7XG4gICAgcm90YXRlQ29udHJvbC51cGRhdGUoZGVsdGEpO1xuICAgIGNvbnN0IHlhdyA9IHJvdGF0ZUNvbnRyb2wueWF3O1xuICAgIGNvbnN0IHBpdGNoID0gcm90YXRlQ29udHJvbC5waXRjaDtcbiAgICBpZiAoZ3lyb0NvbnRyb2wuZW5hYmxlZCkge1xuICAgICAgZ3lyb0NvbnRyb2wudXBkYXRlKGNhbWVyYSwgeWF3LCBwaXRjaCwgem9vbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWVyYS5sb29rQXQoe1xuICAgICAgICB5YXc6IHlhdy52YWwsXG4gICAgICAgIHBpdGNoOiBwaXRjaC52YWwsXG4gICAgICAgIHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBTeW5jaHJvbml6ZSB0aGlzIGNvbnRyb2wncyBzdGF0ZSB0byBjdXJyZW50IGNhbWVyYSBzdGF0ZVxyXG4gICAqIEBrbyDsu6jtirjroaTsnYQg7Lm066mU65287J2YIO2YhOyerCDsg4Htg5zsmYAg64+Z6riw7ZmU7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBzeW5jKCkge1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcbiAgICB0aGlzLl96b29tQ29udHJvbC5zeW5jKGNhbWVyYSk7XG4gICAgdGhpcy5fcm90YXRlQ29udHJvbC5zeW5jKGNhbWVyYSk7XG4gIH1cbiAgX2Jsb2NrQ29udGV4dE1lbnUoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLl9jb250cm9sRWw7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5DT05URVhUX01FTlUsIHRoaXMuX3ByZXZlbnRDb250ZXh0TWVudSk7XG4gIH1cbiAgX3Jlc3RvcmVDb250ZXh0TWVudSgpIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuX2NvbnRyb2xFbDtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLkNPTlRFWFRfTUVOVSwgdGhpcy5fcHJldmVudENvbnRleHRNZW51KTtcbiAgfVxuICBfc2V0Q3Vyc29yKG5ld0N1cnNvcikge1xuICAgIGlmICghdGhpcy5fdXNlR3JhYkN1cnNvciAmJiBuZXdDdXJzb3IgIT09IENVUlNPUi5OT05FKSByZXR1cm47XG4gICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLl9jb250cm9sRWw7XG4gICAgdGFyZ2V0RWwuc3R5bGUuY3Vyc29yID0gbmV3Q3Vyc29yO1xuICB9XG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIGNvbnN0IHJvdGF0ZUNvbnRyb2wgPSB0aGlzLl9yb3RhdGVDb250cm9sO1xuICAgIGNvbnN0IHpvb21Db250cm9sID0gdGhpcy5fem9vbUNvbnRyb2w7XG4gICAgcm90YXRlQ29udHJvbC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgdGhpcy5fb25JbnB1dFN0YXJ0KTtcbiAgICByb3RhdGVDb250cm9sLm9uKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCwgdGhpcy5fb25JbnB1dEVuZCk7XG4gICAgcm90YXRlQ29udHJvbC5vbihDT05UUk9MX0VWRU5UUy5FTkFCTEUsIHRoaXMuX29uRW5hYmxlKTtcbiAgICByb3RhdGVDb250cm9sLm9uKENPTlRST0xfRVZFTlRTLkRJU0FCTEUsIHRoaXMuX29uRGlzYWJsZSk7XG4gICAgem9vbUNvbnRyb2wub24oQ09OVFJPTF9FVkVOVFMuRU5BQkxFLCB0aGlzLl9vbkVuYWJsZSk7XG4gICAgem9vbUNvbnRyb2wub24oQ09OVFJPTF9FVkVOVFMuRElTQUJMRSwgdGhpcy5fb25EaXNhYmxlKTtcbiAgICB0aGlzLl9jYW1lcmEub24oQ0FNRVJBX0VWRU5UUy5BTklNQVRJT05fRU5ELCB0aGlzLl9vbkNhbWVyYUFuaW1hdGlvbkVuZCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXG5jbGFzcyBUZXh0dXJlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmbGlwWVxuICB9KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZmxpcFkgPSBmbGlwWTtcbiAgICB0aGlzLndyYXBTID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0U7XG4gICAgdGhpcy53cmFwVCA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gRE9fTk9USElOR1xuICB9XG4gIGlzVmlkZW8oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzQ3ViZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXG5jbGFzcyBUZXh0dXJlMkQgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHNvdXJjZSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZmxpcFlcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZmxpcFlcbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cbmNsYXNzIFRleHR1cmVWaWRlbyBleHRlbmRzIFRleHR1cmUyRCB7XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLnNvdXJjZTtcbiAgICB2aWRlby5wYXVzZSgpO1xuICAgIHZpZGVvLnJlbW92ZUF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICB2aWRlby5sb2FkKCk7XG4gIH1cbiAgaXNWaWRlbygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc1BhdXNlZCgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMuc291cmNlO1xuICAgIHJldHVybiB2aWRlby5wYXVzZWQgfHwgdmlkZW8uZW5kZWQgfHwgdmlkZW8ucmVhZHlTdGF0ZSA8PSAyO1xuICB9XG4gIGhhc0F1ZGlvKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5zb3VyY2U7XG4gICAgaWYgKHZpZGVvLmF1ZGlvVHJhY2tzKSB7XG4gICAgICByZXR1cm4gdmlkZW8uYXVkaW9UcmFja3MubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgaWYgKHZpZGVvLndlYmtpdEF1ZGlvRGVjb2RlZEJ5dGVDb3VudCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdmlkZW8ud2Via2l0QXVkaW9EZWNvZGVkQnl0ZUNvdW50ID4gMDtcbiAgICB9XG4gICAgaWYgKHZpZGVvLm1vekhhc0F1ZGlvICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB2aWRlby5tb3pIYXNBdWRpbztcbiAgICB9XG4gICAgLy8gV2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoZSB2aWRlbyBoYXMgYXVkaW8gb3Igbm90LCByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xuY2xhc3MgVGV4dHVyZUN1YmUgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHNvdXJjZXMsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZsaXBZXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGZsaXBZXG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgfVxuICBpc0N1YmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXG5jbGFzcyBUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbG9hZENoZWNrZXIgPSBuZXcgSW1SZWFkeSgpO1xuICB9XG4gIGxvYWQoc3JjLCB2aWRlbykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFZpZGVvKHNyYywgZ2V0T2JqZWN0T3B0aW9uKHZpZGVvKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpICYmIHNyYy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEN1YmVJbWFnZShzcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGltZ1NyYyA9IEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyY1swXSA6IHNyYztcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkSW1hZ2UoaW1nU3JjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxvYWRJbWFnZShzcmMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgaW1hZ2VzID0gdGhpcy5fdG9JbWFnZUFycmF5KHNyYyk7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZChpbWFnZXMsIHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1swXTtcbiAgICAgICAgcmVzb2x2ZShuZXcgVGV4dHVyZTJEKHtcbiAgICAgICAgICBzb3VyY2U6IGltYWdlLFxuICAgICAgICAgIHdpZHRoOiBpbWFnZS5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBpbWFnZS5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgIGZsaXBZOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGxvYWRDdWJlSW1hZ2Uoc3JjKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGltYWdlcyA9IHRoaXMuX3RvSW1hZ2VBcnJheShzcmMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWQoaW1hZ2VzLCByZXNvbHZlID0+IHtcbiAgICAgICAgcmVzb2x2ZShuZXcgVGV4dHVyZUN1YmUoe1xuICAgICAgICAgIHNvdXJjZXM6IGltYWdlcyxcbiAgICAgICAgICB3aWR0aDogaW1hZ2VzWzBdLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGltYWdlc1swXS5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgIGZsaXBZOiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBsb2FkVmlkZW8oc3JjLCB2aWRlb0NvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYXV0b3BsYXk6IHRydWUsXG4gICAgICAgIG11dGVkOiB0cnVlLFxuICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgdm9sdW1lOiAxXG4gICAgICB9LCB2aWRlb0NvbmZpZyk7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3RvVmlkZW9FbGVtZW50KHNyYywgY29uZmlnKTtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkKFt2aWRlb10sIHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXV0b3BsYXksXG4gICAgICAgICAgbXV0ZWRcbiAgICAgICAgfSA9IGNvbmZpZztcbiAgICAgICAgdmlkZW8uY3VycmVudFRpbWUgPSAwO1xuICAgICAgICBpZiAoYXV0b3BsYXkgJiYgbXV0ZWQpIHtcbiAgICAgICAgICB2aWRlby5wbGF5KCkuY2F0Y2goKCkgPT4gdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG5ldyBUZXh0dXJlVmlkZW8oe1xuICAgICAgICAgIHNvdXJjZTogdmlkZW8sXG4gICAgICAgICAgd2lkdGg6IHZpZGVvLnZpZGVvV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWRlby52aWRlb0hlaWdodCxcbiAgICAgICAgICBmbGlwWTogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfbG9hZChjb250ZW50LCBvbkxvYWQpIHtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLl9sb2FkQ2hlY2tlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbG9hZGVyLm9uY2UoXCJyZWFkeVwiLCBldnQgPT4ge1xuICAgICAgICBpZiAoZXZ0LmVycm9yQ291bnQgPiAwKSByZXR1cm47XG4gICAgICAgIG9uTG9hZChyZXNvbHZlKTtcbiAgICAgIH0pO1xuICAgICAgbG9hZGVyLm9uY2UoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgbG9hZGVyLmNoZWNrKGNvbnRlbnQpO1xuICAgIH0pO1xuICB9XG4gIF90b0ltYWdlQXJyYXkoc3JjKSB7XG4gICAgY29uc3Qgc3JjcyA9IEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtzcmNdO1xuICAgIHJldHVybiBzcmNzLm1hcChzb3VyY2UgPT4ge1xuICAgICAgaWYgKGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICAgICAgY29uc3QgaW1nRWwgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nRWwuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgICBpbWdFbC5zcmMgPSBzb3VyY2U7XG4gICAgICAgIHJldHVybiBpbWdFbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3RvVmlkZW9FbGVtZW50KHNyYywge1xuICAgIG11dGVkLFxuICAgIGxvb3AsXG4gICAgdm9sdW1lXG4gIH0pIHtcbiAgICBpZiAoc3JjIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgdmlkZW8uY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIHZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICB2aWRlby5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIiwgXCJcIik7XG4gICAgdmlkZW8ubXV0ZWQgPSBtdXRlZDtcbiAgICB2aWRlby52b2x1bWUgPSB2b2x1bWU7XG4gICAgdmlkZW8ubG9vcCA9IGxvb3A7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgc3JjLmZvckVhY2goc291cmNlID0+IHRoaXMuX2FwcGVuZFNvdXJjZUVsZW1lbnQodmlkZW8sIHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcHBlbmRTb3VyY2VFbGVtZW50KHZpZGVvLCBzcmMpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VDb3VudCA9IHZpZGVvLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIikubGVuZ3RoO1xuICAgIGlmIChzb3VyY2VDb3VudCA+IDAgJiYgdmlkZW8ucmVhZHlTdGF0ZSA8IDEpIHtcbiAgICAgIHZpZGVvLmxvYWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZGVvO1xuICB9XG4gIF9hcHBlbmRTb3VyY2VFbGVtZW50KHZpZGVvLCBzcmMpIHtcbiAgICBpZiAoc3JjIGluc3RhbmNlb2YgSFRNTFNvdXJjZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcbiAgICBzb3VyY2VFbC5zcmMgPSBzcmM7XG4gICAgdmlkZW8uYXBwZW5kQ2hpbGQoc291cmNlRWwpO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG5jbGFzcyBGcmFtZUFuaW1hdG9yIHtcbiAgLyoqICovXG4gIGNvbnN0cnVjdG9yKG1heERlbHRhVGltZSwgY29udGV4dCA9IHdpbmRvdykge1xuICAgIHRoaXMubWF4RGVsdGFUaW1lID0gbWF4RGVsdGFUaW1lO1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX3JhZklkID0gLTE7XG4gICAgdGhpcy5fcmFmVGltZXIgPSAtMTtcbiAgICB0aGlzLl9sYXN0VXBkYXRlVGltZSA9IC0xO1xuICB9XG4gIHN0YXJ0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgLy8gTm8gY29udGV4dCAvIGNhbGxiYWNrIHNldFxuICAgIGlmICghY29udGV4dCB8fCAhY2FsbGJhY2spIHJldHVybjtcbiAgICAvLyBBbmltYXRpb24gYWxyZWFkeSBzdGFydGVkXG4gICAgaWYgKHRoaXMuX3JhZklkID49IDAgfHwgdGhpcy5fcmFmVGltZXIgPj0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGxvb3AgPSAoX3RpbWUsIGZyYW1lKSA9PiB7XG4gICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5taW4odGltZSAtIHRoaXMuX2xhc3RVcGRhdGVUaW1lLCB0aGlzLm1heERlbHRhVGltZSAqIDEwMDApO1xuICAgICAgY2FsbGJhY2soZGVsdGEsIGZyYW1lKTtcbiAgICAgIHRoaXMuX2xhc3RVcGRhdGVUaW1lID0gdGltZTtcbiAgICAgIHRoaXMuX3JhZklkID0gY29udGV4dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfTtcbiAgICB0aGlzLl9sYXN0VXBkYXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5fcmFmSWQgPSBjb250ZXh0LnJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9yYWZJZCA+PSAwKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZklkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JhZlRpbWVyID49IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yYWZUaW1lcik7XG4gICAgfVxuICAgIHRoaXMuX3JhZklkID0gLTE7XG4gICAgdGhpcy5fcmFmVGltZXIgPSAtMTtcbiAgfVxuICBjaGFuZ2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogQXV0b21hdGljIHJlc2l6ZXIgdGhhdCB1c2VzIGJvdGggUmVzaXplT2JzZXJ2ZXIgYW5kIHdpbmRvdyByZXNpemUgZXZlbnRcclxuICovXG5jbGFzcyBBdXRvUmVzaXplciB7XG4gIGdldCB1c2VSZXNpemVPYnNlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlUmVzaXplT2JzZXJ2ZXI7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIEF1dG9SZXNpemVyIGlzIGVuYWJsZWRcclxuICAgKi9cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgLyoqICovXG4gIGNvbnN0cnVjdG9yKHVzZVJlc2l6ZU9ic2VydmVyLCBvblJlc2l6ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgdGhpcy5fc2tpcEZpcnN0UmVzaXplID0gKCgpID0+IHtcbiAgICAgIGxldCBpc0ZpcnN0UmVzaXplID0gdHJ1ZTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChpc0ZpcnN0UmVzaXplKSB7XG4gICAgICAgICAgaXNGaXJzdFJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vblJlc2l6ZSgpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHRoaXMuX3VzZVJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXI7XG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9vblJlc2l6ZSA9IG9uUmVzaXplO1xuICB9XG4gIC8qKlxyXG4gICAqIEVuYWJsZSByZXNpemVyXHJcbiAgICovXG4gIGVuYWJsZShlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdXNlUmVzaXplT2JzZXJ2ZXIgJiYgISF3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGJib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgcmVzaXplSW1tZWRpYXRlID0gYmJveC53aWR0aCAhPT0gMCB8fCBiYm94LmhlaWdodCAhPT0gMDtcbiAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJlc2l6ZUltbWVkaWF0ZSA/IHRoaXMuX3NraXBGaXJzdFJlc2l6ZSA6IHRoaXMuX29uUmVzaXplKTtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5SRVNJWkUsIHRoaXMuX29uUmVzaXplKTtcbiAgICB9XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogRGlzYWJsZSByZXNpemVyXHJcbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IHRoaXMuX3Jlc2l6ZU9ic2VydmVyO1xuICAgIGlmIChyZXNpemVPYnNlcnZlcikge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5SRVNJWkUsIHRoaXMuX29uUmVzaXplKTtcbiAgICB9XG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxyXG4gKiBBIG1hbmFnZXIgY2xhc3MgZm9yIGF1dG9wbGF5IGZlYXR1cmUuXHJcbiAqIEBrbyBBdXRvcGxheSDquLDriqXsnZgg66ek64uI7KCAIO2BtOuemOyKpC5cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgQXV0b3BsYXkge1xuICAvKipcclxuICAgKiBXaGV0aGVyIGF1dG9wbGF5IGlzIGVuYWJsZWQgb3Igbm90XHJcbiAgICogQGtvIOyekOuPmeyerOyDnSDtmZzshLHtmZQg7Jes67aA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQGhpZGRlblxyXG4gICAqL1xuICBnZXQgZW5hYmxlQmxvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlQmxvY2tlZDtcbiAgfVxuICAvKipcclxuICAgKiBXaGV0aGVyIGF1dG9wbGF5IGlzIHVwZGF0aW5nIHRoZSBjYW1lcmEgYXQgdGhlIG1vbWVudFxyXG4gICAqIEBrbyDtmITsnqwg7J6Q64+Z7J6s7IOd7J20IOuPmeyekeykkeyduOyngCDsl6zrtoDrpbwg64KY7YOA64K064qUIOqwklxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgcGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlZCAmJiAhdGhpcy5faW50ZXJydXB0ZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVhY3RpdmF0aW9uIGRlbGF5IGFmdGVyIG1vdXNlIGlucHV0IGluIG1pbGlzZWNvbmQuXHJcbiAgICogQGtvIOyerO2ZnOyEse2ZlOuQmOq4sOq5jOyngOydmCDsi5zqsIQgKOuwgOumrOy0iCDri6jsnIQpXHJcbiAgICogQGRlZmF1bHQgMjAwMFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgZGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGF5O1xuICB9XG4gIHNldCBkZWxheSh2YWwpIHtcbiAgICB0aGlzLl9kZWxheSA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBSZWFjdGl2YXRpb24gZGVsYXkgYWZ0ZXIgbW91c2UgbGVhdmUgd2hlbiB1c2luZyB7QGxpbmsgQXV0b3BsYXlPcHRpb25zI3BhdXNlT25Ib3Zlcn1cclxuICAgKiBAa28ge0BsaW5rIEF1dG9wbGF5T3B0aW9ucyNwYXVzZU9uSG92ZXJ9IOyCrOyaqeyLnCDrp4jsmrDsiqTqsIAg7LqU67KE7IqkIOyYgeyXreydhCDrlqDrgpwg65KkIOyekOuPmeyerOyDneydtCDri6Tsi5wg7Zmc7ISx7ZmU65CY6riw6rmM7KeA7J2YIOyLnOqwhFxyXG4gICAqIEBkZWZhdWx0IDBcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGRlbGF5T25Nb3VzZUxlYXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxheU9uTW91c2VMZWF2ZTtcbiAgfVxuICBzZXQgZGVsYXlPbk1vdXNlTGVhdmUodmFsKSB7XG4gICAgdGhpcy5fZGVsYXlPbk1vdXNlTGVhdmUgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogWS1heGlzKHlhdykgcm90YXRpb24gc3BlZWRcclxuICAgKiBAa28gWS3stpUg7ZqM7KCEKHlhdynsnZgg7IaN64+EXHJcbiAgICogQGRlZmF1bHQgMVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVkO1xuICB9XG4gIHNldCBzcGVlZCh2YWwpIHtcbiAgICB0aGlzLl9zcGVlZCA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHBhdXNlIHJvdGF0aW9uIG9uIG1vdXNlIGhvdmVyXHJcbiAgICogQGtvIOuniOyasOyKpOqwgCDsupTrsoTsiqQg7JiB7Jet7JeQIOuTpOyWtOyZlOydhCDrlYwg7J6Q64+Z7J6s7IOd7J2EIOygleyngO2VoOyngCDsl6zrtoBcclxuICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgcGF1c2VPbkhvdmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZU9uSG92ZXI7XG4gIH1cbiAgc2V0IHBhdXNlT25Ib3Zlcih2YWwpIHtcbiAgICB0aGlzLl9wYXVzZU9uSG92ZXIgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hldGhlciB1c2VyIGNhbiBpbnRlcnJ1cHQgdGhlIHJvdGF0aW9uIHdpdGggY2xpY2svd2hlZWwgaW5wdXRcclxuICAgKiBAa28g7YG066at7J2064KYIO2coOqwmeydgCDsgqzsmqnsnpAg7J247YSw656Z7IWY7IucIOyekOuPmeyerOyDneydhCDrqYjstpzsp4Ag7Jes67aAXHJcbiAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgY2FuSW50ZXJydXB0KCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5JbnRlcnJ1cHQ7XG4gIH1cbiAgc2V0IGNhbkludGVycnVwdCh2YWwpIHtcbiAgICB0aGlzLl9jYW5JbnRlcnJ1cHQgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBkaXNhYmxlIGF1dG9wbGF5IG9uIHVzZXIgaW50ZXJydXB0XHJcbiAgICogQGtvIOyCrOyaqeyekCDrj5nsnpHsl5Ag7J2Y7ZW0IOyekOuPmeyerOyDneydtCDsoJXsp4DtlaAg65WMLCB7QGxpbmsgQXV0b3BsYXkjZGlzYWJsZX3snYQg7Zi47Lac7ZWY7JesIOyekOuPmeyerOyDneydhCDsmIHqtaztnogg7KCV7KeA7ZWg7KeAIOyXrOu2gFxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBkaXNhYmxlT25JbnRlcnJ1cHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVPbkludGVycnVwdDtcbiAgfVxuICBzZXQgZGlzYWJsZU9uSW50ZXJydXB0KHZhbCkge1xuICAgIHRoaXMuX2Rpc2FibGVPbkludGVycnVwdCA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IEF1dG9QbGF5ZXIgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gY2FtZXJhIC0gSW5zdGFuY2Ugb2YgdGhlIHtAbGluayBDYW1lcmF9IHtAa28gQ2FtZXJh7J2YIOyduOyKpO2EtOyKpH1cclxuICAgKiBAcGFyYW0gZWxlbWVudCAtIENhbnZhcyBlbGVtZW50IHtAa28g7LqU67KE7IqkIOyXmOumrOuovO2KuH1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEF1dG9wbGF5IG9wdGlvbnMge0BrbyDsnpDrj5nsnqzsg50g7Ji17IWY65OkfVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2aWV3ZXIsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vbklucHV0U3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2NhbkludGVycnVwdCkgcmV0dXJuO1xuICAgICAgdGhpcy5faW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbklucHV0RW5kID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0VW5pbnRlcnJ1cHRlZEFmdGVyRGVsYXkodGhpcy5fZGVsYXkpO1xuICAgIH07XG4gICAgdGhpcy5fb25HeXJvRW5hYmxlID0gKCkgPT4ge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1vdXNlRW50ZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3BhdXNlT25Ib3ZlcikgcmV0dXJuO1xuICAgICAgdGhpcy5faW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5faG92ZXJpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5fb25Nb3VzZUxlYXZlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9wYXVzZU9uSG92ZXIpIHJldHVybjtcbiAgICAgIHRoaXMuX2hvdmVyaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9zZXRVbmludGVycnVwdGVkQWZ0ZXJEZWxheSh0aGlzLl9kZWxheU9uTW91c2VMZWF2ZSk7XG4gICAgfTtcbiAgICB0aGlzLl9jYW1lcmEgPSB2aWV3ZXIuY2FtZXJhO1xuICAgIHRoaXMuX2NvbnRyb2wgPSB2aWV3ZXIuY29udHJvbDtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlcnJ1cHRpb25UaW1lciA9IC0xO1xuICAgIHRoaXMuX2hvdmVyaW5nID0gZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgZGVsYXkgPSAyMDAwLFxuICAgICAgZGVsYXlPbk1vdXNlTGVhdmUgPSAwLFxuICAgICAgc3BlZWQgPSAxLFxuICAgICAgcGF1c2VPbkhvdmVyID0gZmFsc2UsXG4gICAgICBjYW5JbnRlcnJ1cHQgPSB0cnVlLFxuICAgICAgZGlzYWJsZU9uSW50ZXJydXB0ID0gZmFsc2VcbiAgICB9ID0gZ2V0T2JqZWN0T3B0aW9uKG9wdGlvbnMpO1xuICAgIHRoaXMuX2VuYWJsZUJsb2NrZWQgPSAhb3B0aW9ucztcbiAgICB0aGlzLl9kZWxheSA9IGRlbGF5O1xuICAgIHRoaXMuX2RlbGF5T25Nb3VzZUxlYXZlID0gZGVsYXlPbk1vdXNlTGVhdmU7XG4gICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcbiAgICB0aGlzLl9wYXVzZU9uSG92ZXIgPSBwYXVzZU9uSG92ZXI7XG4gICAgdGhpcy5fY2FuSW50ZXJydXB0ID0gY2FuSW50ZXJydXB0O1xuICAgIHRoaXMuX2Rpc2FibGVPbkludGVycnVwdCA9IGRpc2FibGVPbkludGVycnVwdDtcbiAgfVxuICAvKipcclxuICAgKiBEZXN0cm95IHRoZSBpbnN0YW5jZSBhbmQgcmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWRcclxuICAgKiBAa28g7J247Iqk7YS07Iqk66W8IOygnOqxsO2VmOqzoCDsl7DqsrDrkJwg66qo65OgIOydtOuypO2KuCDtlbjrk6Trn6zrpbwg7IKt7KCc7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJvdGF0ZSBjYW1lcmEgYnkgZ2l2ZW4gZGVsdGFUaW1lXHJcbiAgICogQGtvIOyjvOyWtOynhCBkZWx0YVRpbWXrp4ztgbwg7Lm066mU652866W8IO2ajOyghOyLnO2CteuLiOuLpC5cclxuICAgKiBAcGFyYW0gZGVsdGFUaW1lIC0gTnVtYmVyIG9mIG1pbGlzZWMgdG8gdXBkYXRlIHtAa28g7JeF642w7J207Yq47ZWgIOyLnOqwhCwg67CA66as7LSIIOuLqOychH1cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9pbnRlcnJ1cHRlZCkge1xuICAgICAgaWYgKHRoaXMuX2Rpc2FibGVPbkludGVycnVwdCkge1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIGNvbnN0IGRlbHRhID0gLXRoaXMuX3NwZWVkICogZGVsdGFUaW1lIC8gMTAwO1xuICAgIGNhbWVyYS55YXcgPSBjaXJjdWxhdGUoY2FtZXJhLnlhdyArIGRlbHRhLCAwLCAzNjApO1xuICB9XG4gIC8qKlxyXG4gICAqIEVuYWJsZSBhdXRvcGxheSBhbmQgYWRkIGV2ZW50IGxpc3RlbmVycy5cclxuICAgKiBAa28g7J6Q64+Z7J6s7IOd7J2EIO2ZnOyEse2ZlO2VmOqzoCDsnbTrsqTtirjrpqzsiqTrhIjrk6TsnYQg7LaU6rCA7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWQgfHwgY29udHJvbC5neXJvLmVuYWJsZWQpIHJldHVybjtcbiAgICBjb250cm9sLnJvdGF0ZS5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgdGhpcy5fb25JbnB1dFN0YXJ0KTtcbiAgICBjb250cm9sLnJvdGF0ZS5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHRoaXMuX29uSW5wdXRFbmQpO1xuICAgIGNvbnRyb2wuem9vbS5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgdGhpcy5fb25JbnB1dFN0YXJ0KTtcbiAgICBjb250cm9sLnpvb20ub24oQ09OVFJPTF9FVkVOVFMuSU5QVVRfRU5ELCB0aGlzLl9vbklucHV0RW5kKTtcbiAgICBjb250cm9sLmd5cm8ub24oQ09OVFJPTF9FVkVOVFMuRU5BQkxFLCB0aGlzLl9vbkd5cm9FbmFibGUpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5NT1VTRV9FTlRFUiwgdGhpcy5fb25Nb3VzZUVudGVyLCBmYWxzZSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX0xFQVZFLCB0aGlzLl9vbk1vdXNlTGVhdmUsIGZhbHNlKTtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9lbmFibGVCbG9ja2VkID0gZmFsc2U7XG4gIH1cbiAgLyoqXHJcbiAgICogRW5hYmxlIGF1dG9wbGF5IGFmdGVyIGN1cnJlbnQgYGRlbGF5YCB2YWx1ZS5cclxuICAgKiBAa28g7ZiE7J6s7J2YIGBkZWxheWDqsJLrp4ztgbwg7Iuc6rCE7J20IOyngOuCnCDri6TsnYzsl5Ag7J6Q64+Z7J6s7IOd7J2EIO2ZnOyEse2ZlO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZW5hYmxlQWZ0ZXJEZWxheSgpIHtcbiAgICB0aGlzLmVuYWJsZSgpO1xuICAgIHRoaXMuX2ludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZXRVbmludGVycnVwdGVkQWZ0ZXJEZWxheSh0aGlzLl9kZWxheSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRGlzYWJsZSBhdXRvcGxheSBhbmQgcmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycy5cclxuICAgKiBAa28g7J6Q64+Z7J6s7IOd7J2EIOu5hO2ZnOyEse2ZlO2VmOqzoCDrqqjrk6Ag7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJzqsbDtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKSByZXR1cm47XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgY29udHJvbC5yb3RhdGUub2ZmKENPTlRST0xfRVZFTlRTLklOUFVUX1NUQVJULCB0aGlzLl9vbklucHV0U3RhcnQpO1xuICAgIGNvbnRyb2wucm90YXRlLm9mZihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHRoaXMuX29uSW5wdXRFbmQpO1xuICAgIGNvbnRyb2wuem9vbS5vZmYoQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIHRoaXMuX29uSW5wdXRTdGFydCk7XG4gICAgY29udHJvbC56b29tLm9mZihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHRoaXMuX29uSW5wdXRFbmQpO1xuICAgIGNvbnRyb2wuZ3lyby5vZmYoQ09OVFJPTF9FVkVOVFMuRU5BQkxFLCB0aGlzLl9vbkd5cm9FbmFibGUpO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5NT1VTRV9FTlRFUiwgdGhpcy5fb25Nb3VzZUVudGVyLCBmYWxzZSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX0xFQVZFLCB0aGlzLl9vbk1vdXNlTGVhdmUsIGZhbHNlKTtcbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ob3ZlcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICB9XG4gIF9zZXRVbmludGVycnVwdGVkQWZ0ZXJEZWxheShkZWxheSkge1xuICAgIGlmICh0aGlzLl9ob3ZlcmluZykgcmV0dXJuO1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgIHRoaXMuX2ludGVycnVwdGlvblRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnRlcnJ1cHRpb25UaW1lciA9IC0xO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faW50ZXJydXB0aW9uVGltZXIgPSAtMTtcbiAgICB9XG4gIH1cbiAgX2NsZWFyVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5faW50ZXJydXB0aW9uVGltZXIgPj0gMCkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9pbnRlcnJ1cHRpb25UaW1lcik7XG4gICAgICB0aGlzLl9pbnRlcnJ1cHRpb25UaW1lciA9IC0xO1xuICAgIH1cbiAgfVxufVxuXG4vKipcclxuICogV2ViWFIgbWFuYWdlciBjbGFzc1xyXG4gKiBAa28gV2ViWFIg66ek64uI7KCAIO2BtOuemOyKpFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBYUk1hbmFnZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlLlxyXG4gICAqIOyDiCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBjdHggLSBJbnN0YW5jZSBvZiBXZWJHTCBjb250ZXh0IGhlbHBlciB7QGtvIFdlYkdMIOy9mO2FjeyKpO2KuCDtl6ztjbzsnZgg7J247Iqk7YS07IqkfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKi9cbiAgY29uc3RydWN0b3IoY3R4LCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSBpbnN0YW5jZSBhbmQgZW5kIFhSIHNlc3Npb24gaWYgdGhlcmUgd2FzIGFueS5cclxuICAgICAqIEBrbyDsnbjsiqTthLTsiqTrpbwg7KCc6rGw7ZWY6rOgLCBYUiDshLjshZjsnbQg7KG07J6s7ZWgIOqyveyasCDsooXro4ztlanri4jri6QuXHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqL1xuICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZXhpdCgpO1xuICAgICAgdGhpcy5vZmYoKTtcbiAgICB9O1xuICAgIHRoaXMuX29uU2Vzc2lvbkVuZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZXhpdCgpO1xuICAgICAgdGhpcy50cmlnZ2VyKEVWRU5UUy5WUl9FTkQpO1xuICAgIH07XG4gICAgdGhpcy5feHJTZXNzaW9uID0gbnVsbDtcbiAgICB0aGlzLl94clJlZlNwYWNlID0gbnVsbDtcbiAgICB0aGlzLl9jdHggPSBjdHg7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyBXZWJYUiBhdmFpbGFiaWxpdHkuXHJcbiAgICogQGtvIFdlYlhSIOyCrOyaqSDqsIDriqUg7Jes67aA66W8IOuwmO2ZmO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgaXNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG4gICAgICBjb25zdCB4ciA9IHdpbmRvdy5uYXZpZ2F0b3IueHI7XG4gICAgICBpZiAoIXhyKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4geHIuaXNTZXNzaW9uU3VwcG9ydGVkKFNFU1NJT05fVlIpLnRoZW4oYXZhaWxhYmxlID0+IHtcbiAgICAgICAgcmV0dXJuIGF2YWlsYWJsZTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRW50ZXIgVlIgc2Vzc2lvblxyXG4gICAqIEBrbyBWUiDshLjshZjsl5Ag7KeE7J6F7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBlbnRlcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgICAgIGNvbnN0IHhyID0gd2luZG93Lm5hdmlnYXRvci54cjtcbiAgICAgIGlmICgheHIpIHJldHVybjtcbiAgICAgIHlpZWxkIEd5cm9Db250cm9sLnJlcXVlc3RTZW5zb3JQZXJtaXNzaW9uKCk7XG4gICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHJlcXVpcmVkRmVhdHVyZXM6IFtYUl9SRUZFUkVOQ0VfU1BBQ0VdXG4gICAgICB9LCB0aGlzLl9vcHRpb25zKTtcbiAgICAgIHlpZWxkIGN0eC5tYWtlWFJDb21wYXRpYmxlKCk7XG4gICAgICBjb25zdCBzZXNzaW9uID0geWllbGQgeHIucmVxdWVzdFNlc3Npb24oU0VTU0lPTl9WUiwgb3B0aW9ucyk7XG4gICAgICBjdHguYmluZFhSTGF5ZXIoc2Vzc2lvbik7XG4gICAgICBjb25zdCByZWZTcGFjZSA9IHlpZWxkIHNlc3Npb24ucmVxdWVzdFJlZmVyZW5jZVNwYWNlKFhSX1JFRkVSRU5DRV9TUEFDRSk7XG4gICAgICB0aGlzLl9zZXRTZXNzaW9uKHNlc3Npb24sIHJlZlNwYWNlKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFVkVOVFMuVlJfU1RBUlQsIHtcbiAgICAgICAgc2Vzc2lvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRXhpdCBWUiBzZXNzaW9uXHJcbiAgICogQGtvIFZSIOyEuOyFmOyXkOyEnCDrgpjqsJHri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGV4aXQoKSB7XG4gICAgY29uc3QgeHJTZXNzaW9uID0gdGhpcy5feHJTZXNzaW9uO1xuICAgIGlmICh4clNlc3Npb24pIHtcbiAgICAgIHhyU2Vzc2lvbi5lbmQoKS5jYXRjaCgoKSA9PiB2b2lkIDApO1xuICAgIH1cbiAgICB0aGlzLl94clNlc3Npb24gPSBudWxsO1xuICAgIHRoaXMuX3hyUmVmU3BhY2UgPSBudWxsO1xuICB9XG4gIC8qKlxyXG4gICAqIEBoaWRkZW5cclxuICAgKi9cbiAgY2FuUmVuZGVyKGZyYW1lKSB7XG4gICAgY29uc3QgcmVmU3BhY2UgPSB0aGlzLl94clJlZlNwYWNlO1xuICAgIGlmICghcmVmU3BhY2UpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwb3NlID0gZnJhbWUuZ2V0Vmlld2VyUG9zZShyZWZTcGFjZSk7XG4gICAgcmV0dXJuICEhcG9zZTtcbiAgfVxuICAvKipcclxuICAgKiBAaGlkZGVuXHJcbiAgICovXG4gIGdldEV5ZVBhcmFtcyhmcmFtZSkge1xuICAgIGNvbnN0IHNlc3Npb24gPSBmcmFtZS5zZXNzaW9uO1xuICAgIGNvbnN0IHBvc2UgPSBmcmFtZS5nZXRWaWV3ZXJQb3NlKHRoaXMuX3hyUmVmU3BhY2UpO1xuICAgIGlmICghcG9zZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZ2xMYXllciA9IHNlc3Npb24ucmVuZGVyU3RhdGUuYmFzZUxheWVyO1xuICAgIGlmICghZ2xMYXllcikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBvc2Uudmlld3MubWFwKHZpZXcgPT4ge1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSBnbExheWVyLmdldFZpZXdwb3J0KHZpZXcpO1xuICAgICAgY29uc3Qgdk1hdHJpeCA9IHZpZXcudHJhbnNmb3JtLmludmVyc2UubWF0cml4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHZNYXRyaXgsXG4gICAgICAgIHBNYXRyaXg6IHZpZXcucHJvamVjdGlvbk1hdHJpeFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBfc2V0U2Vzc2lvbihzZXNzaW9uLCByZWZTcGFjZSkge1xuICAgIHRoaXMuX3hyU2Vzc2lvbiA9IHNlc3Npb247XG4gICAgdGhpcy5feHJSZWZTcGFjZSA9IHJlZlNwYWNlO1xuICAgIHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5YUl9FTkQsIHRoaXMuX29uU2Vzc2lvbkVuZCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEhvdHNwb3QgZGF0YVxyXG4gKiBAa28g7ZWr7Iqk7YyfIOuNsOydtO2EsFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBIb3RzcG90IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogSG90c3BvdCByZW5kZXJlclxyXG4gKiBAa28gSG90c3BvdCDroIzrjZTrn6xcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgSG90c3BvdFJlbmRlcmVyIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBpbnN0YW5jZVxyXG4gICAqIEBrbyDsg4gg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gcm9vdEVsIC0gQ29udGFpbmVyIGVsZW1lbnQgZm9yIGhvdHNwb3RzIHtAa28g7ZWr7Iqk7Yyf65Ok7J2YIOy7qO2FjOydtOuEiCDsl5jrpqzrqLztirh9XHJcbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gaW5zdGFuY2Ugb2YgV2ViR0xSZW5kZXJlciB7QGtvIFdlYkdMUmVuZGVyZXLsnZgg7J247Iqk7YS07IqkfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gSG90c3BvdCBvcHRpb25zIHtAa28gSG90c3BvdCDsmLXshZjrk6QgfVxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290RWwsIHJlbmRlcmVyLCB7XG4gICAgem9vbSA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLl9jb250YWluZXJFbCA9IGdldE51bGxhYmxlRWxlbWVudChgLiR7REVGQVVMVF9DTEFTUy5IT1RTUE9UX0NPTlRBSU5FUn1gLCByb290RWwpO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5faG90c3BvdHMgPSBbXTtcbiAgICB0aGlzLl96b29tID0gem9vbTtcbiAgfVxuICAvKipcclxuICAgKiBSZWZyZXNoIGhvdHNwb3RzIGJ5IGNvbGxlY3RpbmcgaG90c3BvdCBlbGVtZW50cyBmcm9tIGN1cnJlbnQgaG90c3BvdCByb290IGVsZW1lbnRcclxuICAgKiBAa28g7ZiE7J6sIO2Vq+yKpO2MnyDro6jtirgg7JeY66as66i87Yq4IOuCtOyXkOyEnCDtlavsiqTtjJ8g7JeY66as66i87Yq465Ok7J2EIOyImOynke2VmOyXrCDqsLHsi6Dtlanri4jri6QuXHJcbiAgICogQHRocm93cyB7RVJST1JfQ09ERVMuSU5TVUZGSUNJRU5UX0FSR1N9IGlmIGRhdGEtcG9zaXRpb24gZG9lc24ndCBpbmNsdWRlIGFsbCB4LCB5LCB6IHZhbHVlcyB7QGtvIGRhdGEtcG9zaXRpb27snbQgeCwgeSwgeuyijO2RnOulvCDsoITrtoAg7Y+s7ZWo7ZWY6rOgIOyeiOyngCDslYrsnYQg65WMfVxyXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lckVsO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgY29uc3QgaG90c3BvdEVscyA9IFtdLnNsaWNlLmFwcGx5KGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKGAuJHtERUZBVUxUX0NMQVNTLkhPVFNQT1R9YCkpO1xuICAgIHRoaXMuX2hvdHNwb3RzID0gaG90c3BvdEVscy5tYXAoZWwgPT4gdGhpcy5fcGFyc2VIb3RzcG90KGVsKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVuZGVyIGhvdHNwb3RzXHJcbiAgICogQGtvIO2Vq+yKpO2Mn+uTpOydhCDroIzrjZTrp4Htlanri4jri6QuXHJcbiAgICogQHBhcmFtIGNhbWVyYSAtIEluc3RhbmNlIG9mIENhbWVyYSB7QGtvIENhbWVyYeydmCDsnbjsiqTthLTsiqR9XHJcbiAgICovXG4gIHJlbmRlcihjYW1lcmEpIHtcbiAgICBjb25zdCBob3RzcG90cyA9IHRoaXMuX2hvdHNwb3RzO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRoaXMuX3JlbmRlcmVyLndpZHRoICogMC41O1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSB0aGlzLl9yZW5kZXJlci5oZWlnaHQgKiAwLjU7XG4gICAgY29uc3Qgem9vbSA9IGNhbWVyYS56b29tO1xuICAgIGNvbnN0IGNlbnRlclRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKC01MCUsIC01MCUpXCI7XG4gICAgY29uc3Qgem9vbVRyYW5zZm9ybSA9IHRoaXMuX3pvb20gPyBgc2NhbGUoJHt6b29tfSlgIDogXCJcIjtcbiAgICBob3RzcG90cy5mb3JFYWNoKGhvdHNwb3QgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBob3RzcG90LnBvc2l0aW9uO1xuICAgICAgY29uc3QgcmVsUG9zID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgIHZlYzMuY29weShyZWxQb3MsIHBvc2l0aW9uKTtcbiAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChyZWxQb3MsIHJlbFBvcywgY2FtZXJhLnZpZXdNYXRyaXgpO1xuICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHJlbFBvcywgcmVsUG9zLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICBpZiAocmVsUG9zWzJdID4gMSB8fCByZWxQb3NbMl0gPCAwKSB7XG4gICAgICAgIGhvdHNwb3QuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKERFRkFVTFRfQ0xBU1MuSE9UU1BPVF9WSVNJQkxFKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2NyZWVuUG9zID0gdmVjMi5mcm9tVmFsdWVzKHJlbFBvc1swXSAqIGhhbGZXaWR0aCArIGhhbGZXaWR0aCwgLXJlbFBvc1sxXSAqIGhhbGZIZWlnaHQgKyBoYWxmSGVpZ2h0KTtcbiAgICAgIGhvdHNwb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKERFRkFVTFRfQ0xBU1MuSE9UU1BPVF9WSVNJQkxFKTtcbiAgICAgIGhvdHNwb3QuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBbY2VudGVyVHJhbnNmb3JtLCBgdHJhbnNsYXRlKCR7c2NyZWVuUG9zWzBdfXB4LCAke3NjcmVlblBvc1sxXX1weClgLCB6b29tVHJhbnNmb3JtXS5qb2luKFwiIFwiKTtcbiAgICB9KTtcbiAgfVxuICBfcGFyc2VIb3RzcG90KGVsZW1lbnQpIHtcbiAgICBjb25zdCB5YXdTdHIgPSBlbGVtZW50LmRhdGFzZXQueWF3O1xuICAgIGNvbnN0IHBpdGNoU3RyID0gZWxlbWVudC5kYXRhc2V0LnBpdGNoO1xuICAgIGNvbnN0IHBvc2l0aW9uU3RyID0gZWxlbWVudC5kYXRhc2V0LnBvc2l0aW9uO1xuICAgIGlmICh5YXdTdHIgfHwgcGl0Y2hTdHIpIHtcbiAgICAgIGNvbnN0IHlhdyA9IHlhd1N0ciA/IHBhcnNlRmxvYXQoeWF3U3RyKSA6IDA7XG4gICAgICBjb25zdCBwaXRjaCA9IHBpdGNoU3RyID8gcGFyc2VGbG9hdChwaXRjaFN0cikgOiAwO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl95YXdQaXRjaFRvVmVjMyh5YXcsIHBpdGNoKTtcbiAgICAgIHJldHVybiBuZXcgSG90c3BvdChlbGVtZW50LCBwb3NpdGlvbik7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblN0cikge1xuICAgICAgY29uc3QgcG9zID0gcG9zaXRpb25TdHIuc3BsaXQoXCIgXCIpLm1hcCh2YWwgPT4gcGFyc2VGbG9hdCh2YWwpKTtcbiAgICAgIGlmIChwb3MubGVuZ3RoIDwgMykge1xuICAgICAgICB0aHJvdyBuZXcgVmlldzM2MEVycm9yKEVSUk9SLk1FU1NBR0VTLklOU1VGRklDSUVOVF9BUkdTKHBvc2l0aW9uU3RyLCBcImhvdHNwb3QgYXR0cmlidXRlIFxcXCJkYXRhLXBvc2l0aW9uXFxcIlwiKSwgRVJST1IuQ09ERVMuSU5TVUZGSUNJRU5UX0FSR1MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBIb3RzcG90KGVsZW1lbnQsIHZlYzMuZnJvbVZhbHVlcyhwb3NbMF0sIHBvc1sxXSwgcG9zWzJdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBsYWNlIGhvdHNwb3QgYXQgeWF3OiAwLCBwaXRjaDogMFxuICAgICAgY29uc3QgZGVmYXVsdFBvcyA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAtMSk7XG4gICAgICByZXR1cm4gbmV3IEhvdHNwb3QoZWxlbWVudCwgZGVmYXVsdFBvcyk7XG4gICAgfVxuICB9XG4gIF95YXdQaXRjaFRvVmVjMyh5YXcsIHBpdGNoKSB7XG4gICAgY29uc3QgeWF3UmFkID0geWF3ICogREVHX1RPX1JBRDtcbiAgICBjb25zdCBwaXRjaFJhZCA9IHBpdGNoICogREVHX1RPX1JBRDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgcG9zaXRpb25bMV0gPSBNYXRoLnNpbihwaXRjaFJhZCk7XG4gICAgcG9zaXRpb25bMl0gPSBNYXRoLmNvcyhwaXRjaFJhZCk7XG4gICAgcG9zaXRpb25bMF0gPSBwb3NpdGlvblsyXSAqIE1hdGguc2luKC15YXdSYWQpO1xuICAgIHBvc2l0aW9uWzJdID0gLXBvc2l0aW9uWzJdICogTWF0aC5jb3MoLXlhd1JhZCk7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG59XG5cbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xuY2xhc3MgVmVydGV4QXJyYXlPYmplY3Qge1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuaW5kaWNpZXMuY291bnQ7XG4gIH1cbiAgY29uc3RydWN0b3Iob2JqLCBnZW9tZXRyeSwgYnVmZmVycykge1xuICAgIHRoaXMub2JqID0gb2JqO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICB9XG59XG5cbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xuY2xhc3MgV2ViR0xDb250ZXh0IHtcbiAgZ2V0IGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICB9XG4gIGdldCBtYXhUZXh0dXJlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4VGV4dHVyZVNpemU7XG4gIH1cbiAgZ2V0IGlzV2ViR0wyKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1dlYkdMMjtcbiAgfVxuICBnZXQgc3VwcG9ydFZBTygpIHtcbiAgICByZXR1cm4gdGhpcy5faXNXZWJHTDIgfHwgISF0aGlzLl9leHRlbnNpb25zLnZhbztcbiAgfVxuICBnZXQgbG9zdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dExvc3Q7XG4gIH1cbiAgZ2V0IGRlYnVnKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWJ1ZztcbiAgfVxuICBjb25zdHJ1Y3RvcihjYW52YXMsIGRlYnVnKSB7XG4gICAgdGhpcy5fb25Db250ZXh0TG9zdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICAgIGNhbnZhcy5jbGFzc0xpc3QuYWRkKERFRkFVTFRfQ0xBU1MuQ1RYX0xPU1QpO1xuICAgICAgdGhpcy5fY29udGV4dExvc3QgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5fb25Db250ZXh0UmVzdG9yZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICAgIGNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKERFRkFVTFRfQ0xBU1MuQ1RYX0xPU1QpO1xuICAgICAgdGhpcy5fY29udGV4dExvc3QgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLl9jb250ZXh0TG9zdCA9IGZhbHNlO1xuICAgIHRoaXMuX2RlYnVnID0gZGVidWc7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IHtcbiAgICAgIHZhbzogbnVsbCxcbiAgICAgIGxvc2VDb250ZXh0OiBudWxsXG4gICAgfTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICBjb25zdCB7XG4gICAgICBnbCxcbiAgICAgIGlzV2ViR0wyXG4gICAgfSA9IHRoaXMuX2dldENvbnRleHQoY2FudmFzKTtcbiAgICB0aGlzLl9nbCA9IGdsO1xuICAgIHRoaXMuX21heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgIHRoaXMuX2lzV2ViR0wyID0gaXNXZWJHTDI7XG4gICAgaWYgKCF0aGlzLl9pc1dlYkdMMikge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9ucy52YW8gPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtcbiAgICB9XG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5sb3NlQ29udGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5DT05URVhUX0xPU1QsIHRoaXMuX29uQ29udGV4dExvc3QpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLkNPTlRFWFRfUkVTVE9SRUQsIHRoaXMuX29uQ29udGV4dFJlc3RvcmUpO1xuICAgIC8vIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgaWYgKGdsKSB7XG4gICAgICAvLyBnbCBpcyBub3QgZGVmaW5lZCB3aGVuIGRlc3Ryb3kgaXMgY2FsbGVkIGJlZm9yZSBpbml0XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICB9XG4gICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuQ09OVEVYVF9MT1NULCB0aGlzLl9vbkNvbnRleHRMb3N0KTtcbiAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5DT05URVhUX1JFU1RPUkVELCB0aGlzLl9vbkNvbnRleHRSZXN0b3JlKTtcbiAgfVxuICBmb3JjZUxvc2VDb250ZXh0KCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuX2V4dGVuc2lvbnMubG9zZUNvbnRleHQ7XG4gICAgaWYgKCFleHRlbnNpb24pIHJldHVybjtcbiAgICBleHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgfVxuICBmb3JjZVJlc3RvcmVDb250ZXh0KCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuX2V4dGVuc2lvbnMubG9zZUNvbnRleHQ7XG4gICAgaWYgKCFleHRlbnNpb24pIHJldHVybjtcbiAgICBleHRlbnNpb24ucmVzdG9yZUNvbnRleHQoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gIH1cbiAgdmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgY3JlYXRlVkFPKGdlb21ldHJ5LCBzaGFkZXJQcm9ncmFtKSB7XG4gICAgY29uc3QgbmF0aXZlVkFPID0gdGhpcy5fY3JlYXRlTmF0aXZlVkFPKCk7XG4gICAgY29uc3QgdmFvID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KG5hdGl2ZVZBTywgZ2VvbWV0cnksIHtcbiAgICAgIGluZGljaWVzOiB0aGlzLl9jcmVhdGVCdWZmZXIoKSxcbiAgICAgIHBvc2l0aW9uOiB0aGlzLl9jcmVhdGVCdWZmZXIoKSxcbiAgICAgIHV2OiB0aGlzLl9jcmVhdGVCdWZmZXIoKVxuICAgIH0pO1xuICAgIGlmIChuYXRpdmVWQU8pIHtcbiAgICAgIHRoaXMuX2JpbmROYXRpdmVWQU8obmF0aXZlVkFPKTtcbiAgICAgIHRoaXMuX3N1cHBseUdlb21ldHJ5RGF0YSh2YW8sIHNoYWRlclByb2dyYW0pO1xuICAgICAgdGhpcy5fYmluZE5hdGl2ZVZBTyhudWxsKTtcbiAgICAgIHRoaXMuX3VuYmluZEJ1ZmZlcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbztcbiAgfVxuICBkcmF3KHZhbywgc2hhZGVyUHJvZ3JhbSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgaWYgKHZhby5vYmopIHtcbiAgICAgIHRoaXMuX2JpbmROYXRpdmVWQU8odmFvLm9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N1cHBseUdlb21ldHJ5RGF0YSh2YW8sIHNoYWRlclByb2dyYW0pO1xuICAgIH1cbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB2YW8uY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICBpZiAodmFvLm9iaikge1xuICAgICAgdGhpcy5fYmluZE5hdGl2ZVZBTyhudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdW5iaW5kQnVmZmVycygpO1xuICAgIH1cbiAgfVxuICByZWxlYXNlVkFPKHZhbykge1xuICAgIGlmICh2YW8ub2JqKSB7XG4gICAgICB0aGlzLl9kZWxldGVOYXRpdmVWQU8odmFvLm9iaik7XG4gICAgfVxuICAgIHRoaXMuX2RlbGV0ZUJ1ZmZlcih2YW8uYnVmZmVycy5pbmRpY2llcyk7XG4gICAgdGhpcy5fZGVsZXRlQnVmZmVyKHZhby5idWZmZXJzLnBvc2l0aW9uKTtcbiAgICB0aGlzLl9kZWxldGVCdWZmZXIodmFvLmJ1ZmZlcnMudXYpO1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbnMocHJvZ3JhbSwgdW5pZm9ybXMpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnMgPSBPYmplY3Qua2V5cyh1bmlmb3JtcykucmVkdWNlKChsb2NhdGlvbnMsIGtleSkgPT4ge1xuICAgICAgbG9jYXRpb25zW2tleV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwga2V5KTtcbiAgICAgIHJldHVybiBsb2NhdGlvbnM7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2dldENvbW1vblVuaWZvcm1Mb2NhdGlvbnMocHJvZ3JhbSkpLCB1bmlmb3JtTG9jYXRpb25zKTtcbiAgfVxuICB1cGRhdGVDb21tb25Vbmlmb3JtcyhlbnRpdHksIGNhbWVyYSwgc2hhZGVyUHJvZ3JhbSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgY29uc3QgdW5pZm9ybUxvY2F0aW9ucyA9IHNoYWRlclByb2dyYW0udW5pZm9ybUxvY2F0aW9ucztcbiAgICAvLyBXZSdyZSB1c2luZyBcIm1hdHJpeFwiKD1sb2NhbCBtYXRyaXgpIGhlcmUgZm9yIGVmZmljaWVuY3lcbiAgICAvLyBBcyBwcm9qZWN0aW9uIGRvZXNuJ3QgcmVxdWlyZSB3b3JsZCBtYXRyaXgsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgcGFyZW50IG9yIGNoaWxkXG4gICAgY29uc3QgbWF0cml4ID0gZW50aXR5Lm1hdHJpeDtcbiAgICBjb25zdCBtdk1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgbWF0NC5tdWx0aXBseShtdk1hdHJpeCwgY2FtZXJhLnZpZXdNYXRyaXgsIG1hdHJpeCk7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtTG9jYXRpb25zLnVNVk1hdHJpeCwgZmFsc2UsIG12TWF0cml4KTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbnMudVBNYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG4gIH1cbiAgdXBkYXRlVlJVbmlmb3JtcyhzaGFkZXJQcm9ncmFtLCBtdk1hdHJpeCwgcE1hdHJpeCwgZXllSW5kZXgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnMgPSBzaGFkZXJQcm9ncmFtLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtTG9jYXRpb25zLnVNVk1hdHJpeCwgZmFsc2UsIG12TWF0cml4KTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbnMudVBNYXRyaXgsIGZhbHNlLCBwTWF0cml4KTtcbiAgICBpZiAodW5pZm9ybUxvY2F0aW9ucy51RXllKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51RXllLCBleWVJbmRleCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVVuaWZvcm1zKHNoYWRlclByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gc2hhZGVyUHJvZ3JhbS51bmlmb3JtcztcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zID0gc2hhZGVyUHJvZ3JhbS51bmlmb3JtTG9jYXRpb25zO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB1bmlmb3JtID0gdW5pZm9ybXNba2V5XTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdW5pZm9ybUxvY2F0aW9uc1trZXldO1xuICAgICAgaWYgKCF1bmlmb3JtKSBjb250aW51ZTtcbiAgICAgIGlmICh1bmlmb3JtLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgIHVuaWZvcm0udXBkYXRlKGdsLCBsb2NhdGlvbiwgdGhpcy5faXNXZWJHTDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWxlYXNlU2hhZGVyUmVzb3VyY2VzKHNoYWRlclByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gc2hhZGVyUHJvZ3JhbS51bmlmb3JtcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB1bmlmb3Jtcykge1xuICAgICAgY29uc3QgdW5pZm9ybSA9IHVuaWZvcm1zW2tleV07XG4gICAgICBpZiAoIXVuaWZvcm0pIGNvbnRpbnVlO1xuICAgICAgaWYgKHVuaWZvcm0ubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgdW5pZm9ybS5kZXN0cm95KGdsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShzaGFkZXJQcm9ncmFtLnByb2dyYW0pO1xuICB9XG4gIHVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgZ2wudXNlUHJvZ3JhbShzaGFkZXJQcm9ncmFtLnByb2dyYW0pO1xuICB9XG4gIGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBjb25zdCB2cyA9IHRoaXMuX2NvbXBpbGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyKTtcbiAgICBjb25zdCBmcyA9IHRoaXMuX2NvbXBpbGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZzKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnMpO1xuICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAwLCBcInBvc2l0aW9uXCIpO1xuICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAxLCBcInV2XCIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGlmICh0aGlzLl9kZWJ1ZyAmJiAhZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIGxldCBzaGFkZXJMb2cgPSBudWxsO1xuICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodnMsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICBzaGFkZXJMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHZzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcywgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIHNoYWRlckxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coZnMpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFZpZXczNjBFcnJvcihFUlJPUi5NRVNTQUdFUy5GQUlMRURfTElOS0lOR19QUk9HUkFNKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pLCBzaGFkZXJMb2cpLCBFUlJPUi5DT0RFUy5GQUlMRURfTElOS0lOR19QUk9HUkFNKTtcbiAgICB9XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHZzKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnMpO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG4gIGNyZWF0ZVdlYkdMVGV4dHVyZSh0ZXhEYXRhKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRleERhdGEud3JhcFMpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRleERhdGEud3JhcFQpO1xuICAgIGlmICghdGV4RGF0YS5pc1ZpZGVvKCkgJiYgdGhpcy5faXNXZWJHTDIpIHtcbiAgICAgIGNvbnN0IGdsMiA9IGdsO1xuICAgICAgZ2wyLnRleFN0b3JhZ2UyRChnbDIuVEVYVFVSRV8yRCwgMSwgZ2wyLlJHQkE4LCB0ZXhEYXRhLndpZHRoLCB0ZXhEYXRhLmhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIGNyZWF0ZVdlYkdMQ3ViZVRleHR1cmUodGV4RGF0YSwgc2l6ZSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9TLCB0ZXhEYXRhLndyYXBTKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9ULCB0ZXhEYXRhLndyYXBUKTtcbiAgICBpZiAodGhpcy5faXNXZWJHTDIpIHtcbiAgICAgIGNvbnN0IGdsMiA9IGdsO1xuICAgICAgZ2wyLnRleFN0b3JhZ2UyRChnbDIuVEVYVFVSRV9DVUJFX01BUCwgMSwgZ2wyLlJHQkE4LCBzaXplLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgbWFrZVhSQ29tcGF0aWJsZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy54ckNvbXBhdGlibGUgIT09IHRydWUpIHtcbiAgICAgICAgeWllbGQgZ2wubWFrZVhSQ29tcGF0aWJsZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGJpbmRYUkxheWVyKHNlc3Npb24pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHhyTGF5ZXIgPSBuZXcgWFJXZWJHTExheWVyKHNlc3Npb24sIGdsKTtcbiAgICBzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKHtcbiAgICAgIGJhc2VMYXllcjogeHJMYXllclxuICAgIH0pO1xuICB9XG4gIGJpbmRYUkZyYW1lKGZyYW1lKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBjb25zdCBzZXNzaW9uID0gZnJhbWUuc2Vzc2lvbjtcbiAgICBjb25zdCBiYXNlTGF5ZXIgPSBzZXNzaW9uLnJlbmRlclN0YXRlLmJhc2VMYXllcjtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGJhc2VMYXllci5mcmFtZWJ1ZmZlcik7XG4gIH1cbiAgdXNlRGVmYXVsdEZyYW1lQnVmZmVyKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgfVxuICBfY3JlYXRlQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgfVxuICBfZGVsZXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLl9nbC5kZWxldGVCdWZmZXIoYnVmZmVyKTtcbiAgfVxuICBfY3JlYXRlTmF0aXZlVkFPKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgaWYgKHRoaXMuX2lzV2ViR0wyKSB7XG4gICAgICByZXR1cm4gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXh0ID0gdGhpcy5fZXh0ZW5zaW9ucy52YW87XG4gICAgICByZXR1cm4gKGV4dCA9PT0gbnVsbCB8fCBleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dC5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpKSB8fCBudWxsO1xuICAgIH1cbiAgfVxuICBfYmluZE5hdGl2ZVZBTyh2YW8pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGlmICh0aGlzLl9pc1dlYkdMMikge1xuICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4dCA9IHRoaXMuX2V4dGVuc2lvbnMudmFvO1xuICAgICAgZXh0ID09PSBudWxsIHx8IGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8pO1xuICAgIH1cbiAgfVxuICBfZGVsZXRlTmF0aXZlVkFPKHZhbykge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgaWYgKHRoaXMuX2lzV2ViR0wyKSB7XG4gICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLl9leHRlbnNpb25zLnZhbztcbiAgICAgIGV4dCA9PT0gbnVsbCB8fCBleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dC5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pO1xuICAgIH1cbiAgfVxuICBfc3VwcGx5R2VvbWV0cnlEYXRhKHZhbywgc2hhZGVyUHJvZ3JhbSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdmFvLmdlb21ldHJ5O1xuICAgIHRoaXMuX3N1cHBseUluZGljaWVzRGF0YShnZW9tZXRyeS5pbmRpY2llcywgdmFvLmJ1ZmZlcnMuaW5kaWNpZXMpO1xuICAgIHRoaXMuX3N1cHBseUF0dHJpYnV0ZURhdGEoZ2VvbWV0cnkudmVydGljZXMsIHNoYWRlclByb2dyYW0ucHJvZ3JhbSwgXCJwb3NpdGlvblwiLCB2YW8uYnVmZmVycy5wb3NpdGlvbik7XG4gICAgdGhpcy5fc3VwcGx5QXR0cmlidXRlRGF0YShnZW9tZXRyeS51dnMsIHNoYWRlclByb2dyYW0ucHJvZ3JhbSwgXCJ1dlwiLCB2YW8uYnVmZmVycy51dik7XG4gIH1cbiAgX3VuYmluZEJ1ZmZlcnMoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIH1cbiAgX3N1cHBseUluZGljaWVzRGF0YShpbmRpY2llcywgYnVmZmVyKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGljaWVzLmRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcbiAgfVxuICBfc3VwcGx5QXR0cmlidXRlRGF0YShhdHRyaWJ1dGUsIHByb2dyYW0sIG5hbWUsIGJ1ZmZlcikge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XG4gICAgY29uc3QgYXR0cmliTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICAvLyBBdHRyaWJ1dGUgbm90IHVzZWRcbiAgICBpZiAoYXR0cmliTG9jYXRpb24gPCAwKSByZXR1cm47XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5kYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJMb2NhdGlvbiwgYXR0cmlidXRlLml0ZW1TaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYkxvY2F0aW9uKTtcbiAgfVxuICBfY29tcGlsZVNoYWRlcih0eXBlLCBzcmMpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG4gIF9nZXRDb21tb25Vbmlmb3JtTG9jYXRpb25zKHByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xuICAgIHJldHVybiB7XG4gICAgICB1TVZNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVNVk1hdHJpeFwiKSxcbiAgICAgIHVQTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1UE1hdHJpeFwiKVxuICAgIH07XG4gIH1cbiAgX2dldENvbnRleHQoY2FudmFzKSB7XG4gICAgY29uc3Qgd2ViZ2xJZGVudGlmaWVycyA9IFtcIndlYmdsMlwiLCBcIndlYmdsXCIsIFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIFwid2Via2l0LTNkXCIsIFwibW96LXdlYmdsXCJdO1xuICAgIGxldCBjb250ZXh0ID0gbnVsbDtcbiAgICBsZXQgaXNXZWJHTDIgPSBmYWxzZTtcbiAgICBjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBvbldlYmdsQ29udGV4dENyZWF0aW9uRXJyb3IgPSBlID0+IGUuc3RhdHVzTWVzc2FnZTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5DT05URVhUX0NSRUFURV9FUlJPUiwgb25XZWJnbENvbnRleHRDcmVhdGlvbkVycm9yKTtcbiAgICBmb3IgKGNvbnN0IGlkZW50aWZpZXIgb2Ygd2ViZ2xJZGVudGlmaWVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KGlkZW50aWZpZXIsIGNvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICAgICAgaXNXZWJHTDIgPSBpZGVudGlmaWVyID09PSBcIndlYmdsMlwiO1xuICAgICAgfSBjYXRjaCAodCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLkNPTlRFWFRfQ1JFQVRFX0VSUk9SLCBvbldlYmdsQ29udGV4dENyZWF0aW9uRXJyb3IpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IFZpZXczNjBFcnJvcihFUlJPUi5NRVNTQUdFUy5XRUJHTF9OT1RfU1VQUE9SVEVELCBFUlJPUi5DT0RFUy5XRUJHTF9OT1RfU1VQUE9SVEVEKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGdsOiBjb250ZXh0LFxuICAgICAgaXNXZWJHTDJcbiAgICB9O1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBQcm9qZWN0aW9uIHJlbmRlcmVyLCBiYXNlZCBvbiBXZWJHTFxyXG4gKiBAa28gV2ViR0wg6riw67CY7J2YIO2UhOuhnOygneyFmCDroIzrjZTrn6xcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgV2ViR0xSZW5kZXJlciB7XG4gIC8qKlxyXG4gICAqIENhbnZhcyBlbGVtZW50XHJcbiAgICogQGtvIOy6lOuyhOyKpCDsl5jrpqzrqLztirhcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbnZhcydzIHdpZHRoIChgZGV2aWNlUGl4ZWxSYXRpb2AgaXMgbm90IGFwcGxpZWQpXHJcbiAgICogQGtvIOy6lOuyhOyKpOydmCDrs7TsnbTripQg64SI67mEIChgZGV2aWNlUGl4ZWxSYXRpb2DqsIAg7KCB7Jqp65CY7KeAIOyViuydgClcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50U2l6ZS54O1xuICB9XG4gIC8qKlxyXG4gICAqIENhbnZhcydzIGhlaWdodCAoYGRldmljZVBpeGVsUmF0aW9gIGlzIG5vdCBhcHBsaWVkKVxyXG4gICAqIEBrbyDsupTrsoTsiqTsnZgg64aS7J20IChgZGV2aWNlUGl4ZWxSYXRpb2DqsIAg7KCB7Jqp65CY7KeAIOyViuydgClcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFNpemUueTtcbiAgfVxuICAvKipcclxuICAgKiBDdXJyZW50IGBkZXZpY2VQaXhlbFJhdGlvYCB2YWx1ZS5cclxuICAgKiBAa28g7ZiE7J6sIGBkZXZpY2VQaXhlbFJhdGlvYCDqsJIuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvc250IHJlbmRlcmluZ1dpZHRoID0gdmlldzM2MC5yZW5kZXJlci53aWR0aCAqIHZpZXczNjAucmVuZGVyZXIucGl4ZWxSYXRpbztcclxuICAgKiBgYGBcclxuICAgKi9cbiAgZ2V0IHBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG4gIH1cbiAgLyoqXHJcbiAgICogV2lkdGggLyBoZWlnaHQgcmF0aW8gKD0gd2lkdGggLyBoZWlnaHQpXHJcbiAgICogQGtvIOuEiOu5hCAvIOuGkuydtOydmCDruYTsnKggKD0gd2lkdGggLyBoZWlnaHQpXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBqc1xyXG4gICAqIGNvbnN0IGFzcGVjdCA9IHZpZXczNjAucmVuZGVyZXIud2lkdGggLyB2aWV3MzYwLnJlbmRlcmVyLnBpeGVsUmF0aW87XHJcbiAgICogYXNzZXJ0KGFzcGVjdCA9PT0gdmlldzM2MC5yZW5kZXJlci5hc3BlY3QpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgYXNwZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50U2l6ZS54IC8gdGhpcy5fZWxlbWVudFNpemUueTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlXHJcbiAgICogQGtvIOyDiCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBjYW52YXMgLSBDYW52YXMgZWxlbWVudCB7QGtvIOy6lOuyhOyKpCDsl5jrpqzrqLztirh9XHJcbiAgICogQHBhcmFtIGRlYnVnIC0gV2hldGhlciB0byBlbmFibGUgV2ViR0wgZGVidWdnaW5nIHtAa28gV2ViR0wgZGVidWcg7Zmc7ISx7ZmUIOyXrOu2gCB9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbnZhcywgZGVidWcpIHtcbiAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5fZWxlbWVudFNpemUgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgdGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG4gICAgdGhpcy5jdHggPSBuZXcgV2ViR0xDb250ZXh0KGNhbnZhcywgZGVidWcpO1xuICB9XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgaW5zdGFuY2UgYW5kIHJlbGVhc2UgYWxsIHJlc291cmNlcy5cclxuICAgKiBAa28g7J247Iqk7YS07Iqk66W8IOygnOqxsO2VmOqzoCDsgqzsmqnrkJwg66as7IaM7Iqk66W8IOyghOu2gCDtlbTsoJztlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgIHRoaXMuY3R4LmRlc3Ryb3koKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2l6ZSBjYW52YXMgYW5kIHJlbmV3IGlubmVyIHNpemUgY2FjaGUuXHJcbiAgICogQGtvIOy6lOuyhOyKpOydmCDtgazquLDrpbwg7J6s6rOE7IKw7ZW07IScIOuCtOu2gOydmCDsgqzsnbTspogg7LqQ7Iuc6rCS7J2EIOqwseyLoO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgcmVzaXplKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICBjb25zdCBjYW52YXNTaXplID0gdGhpcy5fZWxlbWVudFNpemU7XG4gICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGNhbnZhc1NpemUueCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICBjYW52YXNTaXplLnkgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueCAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc1NpemUueSAqIGRldmljZVBpeGVsUmF0aW87XG4gICAgdGhpcy5fcGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG4gICAgdGhpcy5jdHgucmVzaXplKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVuZGVyIHByb2plY3Rpb25cclxuICAgKiBAa28g7ZSE66Gc7KCd7IWY7J2EIOugjOuNlOunge2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gcHJvamVjdGlvbiAtIFByb2plY3Rpb24gdG8gcmVuZGVyIHtAa28g66CM642U66eB7ZWgIO2UhOuhnOygneyFmH1cclxuICAgKiBAcGFyYW0gY2FtZXJhYSAtIENhbWVyYSBpbnN0YW5jZSB7QGtvIOy5tOuplOudvOydmCDsnbjsiqTthLTsiqR9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIHJlbmRlcihtZXNoLCBjYW1lcmEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAoY3R4Lmxvc3QpIHJldHVybjtcbiAgICBjdHguY2xlYXIoKTtcbiAgICBjdHgudXNlUHJvZ3JhbShtZXNoLnByb2dyYW0pO1xuICAgIGN0eC51cGRhdGVDb21tb25Vbmlmb3JtcyhtZXNoLCBjYW1lcmEsIG1lc2gucHJvZ3JhbSk7XG4gICAgbWVzaC51cGRhdGUoe1xuICAgICAgY2FtZXJhXG4gICAgfSk7XG4gICAgY3R4LnVwZGF0ZVVuaWZvcm1zKG1lc2gucHJvZ3JhbSk7XG4gICAgY3R4LmRyYXcobWVzaC52YW8sIG1lc2gucHJvZ3JhbSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVuZGVyIFZSIGZyYW1lLCBvbmx5IHVzZWQgZm9yIHJlbmRlcmluZyBmcmFtZXMgaW5zaWRlIFZSIHNlc3Npb25zLlxyXG4gICAqIEBrbyBWUiDtlITroIjsnoTsnYQg66CM642U66eB7ZWp64uI64ukLiBWUiDshLjshZgg7KeE7J6FIOuPhOykkeyXkOunjCDsgqzsmqnrkKnri4jri6QuXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQHBhcmFtIG1lc2ggLSBUcmlhbmdsZSBtZXNoIHRvIHJlbmRlciB7QGtvIOugjOuNlOunge2VoCDrqZTsiax9XHJcbiAgICogQHBhcmFtIHZyIC0gSW5zdGFuY2Ugb2YgWFJNYW5hZ2VyIHtAa28gWFJNYW5hZ2Vy7J2YIOyduOyKpO2EtOyKpH1cclxuICAgKiBAcGFyYW0gZnJhbWUgLSBWUiBmcmFtZSB7QGtvIFZSIO2UhOugiOyehH1cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgcmVuZGVyVlIobWVzaCwgdnIsIGZyYW1lKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZXllUGFyYW1zID0gdnIuZ2V0RXllUGFyYW1zKGZyYW1lKTtcbiAgICBpZiAoIWV5ZVBhcmFtcyB8fCAhbWVzaCkgcmV0dXJuO1xuICAgIGN0eC5iaW5kWFJGcmFtZShmcmFtZSk7XG4gICAgY3R4LnVzZVByb2dyYW0obWVzaC5wcm9ncmFtKTtcbiAgICBjdHgudXBkYXRlVW5pZm9ybXMobWVzaC5wcm9ncmFtKTtcbiAgICBleWVQYXJhbXMuZm9yRWFjaCgoZXllLCBleWVJbmRleCkgPT4ge1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSBleWUudmlld3BvcnQ7XG4gICAgICAvLyBXZSdyZSB1c2luZyBcIm1lc2gubWF0cml4XCIoPWxvY2FsIG1hdHJpeCkgaGVyZSBmb3IgZWZmaWNpZW5jeVxuICAgICAgLy8gQXMgcHJvamVjdGlvbiBkb2Vzbid0IHJlcXVpcmUgd29ybGQgbWF0cml4LCBhcyBpdCBkb2Vzbid0IGhhdmUgYW55IHBhcmVudCBvciBjaGlsZFxuICAgICAgY29uc3QgbXZNYXRyaXggPSBtYXQ0Lm11bHRpcGx5KG1hdDQuY3JlYXRlKCksIGV5ZS52TWF0cml4LCBtZXNoLm1hdHJpeCk7XG4gICAgICBjdHgudmlld3BvcnQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XG4gICAgICBjdHgudXBkYXRlVlJVbmlmb3JtcyhtZXNoLnByb2dyYW0sIG12TWF0cml4LCBleWUucE1hdHJpeCwgZXllSW5kZXgpO1xuICAgICAgY3R4LmRyYXcobWVzaC52YW8sIG1lc2gucHJvZ3JhbSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFBhbm9yYW1hIDM2MCBpbWFnZSB2aWV3ZXJcclxuICogQGtvIO2MjOuFuOudvOuniCAzNjAg7J2066+47KeAIOu3sOyWtFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQHNlZSBWaWV3MzYwT3B0aW9uc1xyXG4gKiBAc2VlIFZpZXczNjBFdmVudHNcclxuICovXG5jbGFzcyBWaWV3MzYwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXHJcbiAgICogUm9vdCBlbGVtZW50IChgLnZpZXczNjAtY29udGFpbmVyYClcclxuICAgKiBAa28g66Oo7Yq4IOyXmOumrOuovO2KuCAoYC52aWV3MzYwLWNvbnRhaW5lcmApXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGBodG1sXHJcbiAgICogPGRpdiBpZD1cInZpZXdlclwiIGNsYXNzPVwidmlldzM2MC1jb250YWluZXJcIj5cclxuICAgKiAgIDxjYW52YXMgY2xhc3M9XCJ2aWV3MzYwLWNhbnZhc1wiPjwvY2FudmFzPlxyXG4gICAqIDwvZGl2PlxyXG4gICAqIGBgYFxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IFZpZXczNjAgZnJvbSBcIkBlZ2pzL3ZpZXczNjBcIjtcclxuICAgKlxyXG4gICAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3MzYwKFwiI3ZpZXdlclwiKTtcclxuICAgKiBjb25zb2xlLmxvZyh2aWV3ZXIucm9vdEVsKTsgLy8gRWxlbWVudCB3aXRoIGlkIFwidmlld2VyXCJcclxuICAgKiBgYGBcclxuICAgKi9cbiAgZ2V0IHJvb3RFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdEVsO1xuICB9XG4gIC8qKlxyXG4gICAqIFByb2plY3Rpb24gcmVuZGVyZXIuXHJcbiAgICogQGtvIO2UhOuhnOygneyFmCDroIzrjZTrn6wuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXG4gIGdldCByZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gIH1cbiAgLyoqXHJcbiAgICogUHJvamVjdGlvbiBjYW1lcmEuXHJcbiAgICogQGtvIO2UhOuhnOygneyFmCDsubTrqZTrnbwuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXG4gIGdldCBjYW1lcmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbWVyYTtcbiAgfVxuICAvKipcclxuICAgKiBSb3RhdGUvWm9vbSBDb250cm9sbGVyLlxyXG4gICAqIEBrbyDtmozsoIQv7KSMIOy7qO2KuOuhpOufrC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cbiAgZ2V0IGNvbnRyb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2w7XG4gIH1cbiAgLyoqXHJcbiAgICogV2ViWFItYmFzZWQgVlIgbWFuYWdlci5cclxuICAgKiBAa28gV2ViWFIg6riw67CY7J2YIFZSIOq4sOuKpSDrp6Tri4jsoIAg7J247Iqk7YS07IqkLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiAvLyBFeGFtcGxlOiBFbnRlciBWUlxyXG4gICAqIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgb24gdXNlciBpbnRlcmFjdGlvbiwgZWxzZSB3aWxsIGJlIHJlamVjdGVkLlxyXG4gICAqIHZpZXdlci52ci5lbnRlcigpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgdnIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZyO1xuICB9XG4gIC8qKlxyXG4gICAqIEhvdHNwb3QgcmVuZGVyZXIuXHJcbiAgICogWW91IGNhbiBhbHNvIGNoYW5nZSBvcHRpb25zIG9mIHtAbGluayBWaWV3MzYwT3B0aW9ucyNob3RzcG90fSB3aXRoIHRoaXMuXHJcbiAgICogQGtvIO2Vq+yKpO2MnyDroIzrjZTrn6wg7J247Iqk7YS07IqkLlxyXG4gICAqIHtAbGluayBWaWV3MzYwT3B0aW9ucyNob3RzcG90fSDsmLXshZgg67OA6rK964+EIOqwgOuKpe2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cbiAgZ2V0IGhvdHNwb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvdHNwb3Q7XG4gIH1cbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgb2YgcGx1Z2lucyBhZGRlZC5cclxuICAgKiBAa28g7LaU6rCA65CcIO2UjOufrOq3uOyduOydmCDrsLDsl7RcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3Qgdmlld2VyID0gbmV3IFZpZXczNjAoXCIjZWxfaWRcIiwge1xyXG4gICAqICAgcGx1Z2luczogW25ldyBDb250cm9sQmFyKCldXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiBjb25zb2xlLmxvZyh2aWV3ZXIucGx1Z2lucyk7IC8vIFtDb250cm9sQmFyXVxyXG4gICAqXHJcbiAgICogdmlld2VyLmFkZFBsdWdpbnMobmV3IExvYWRpbmdTcGlubmVyKCkpIC8vIFtDb250cm9sQmFyLCBMb2FkaW5nU3Bpbm5lcl07XHJcbiAgICogYGBgXHJcbiAgICovXG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVnaW5zO1xuICB9XG4gIC8qKlxyXG4gICAqIEFuIGluc3RhbmNlIG9mIHtAbGluayBQcm9qZWN0aW9ufSB0aGF0IGN1cnJlbnRseSBlbmFibGVkLiBgbnVsbGAgaWYgbm90IGluaXRpYWxpemVkIHlldC5cclxuICAgKiBZb3Ugc2hvdWxkIGNhbGwge0BsaW5rIFZpZXczNjAjbG9hZH0gdG8gY2hhbmdlIHBhbm9yYW1hIHNyYyBvciBwcm9qZWN0aW9uIHR5cGUuXHJcbiAgICogQGtvIO2YhOyerCDsgqzsmqnspJHsnbgge0BsaW5rIFByb2plY3Rpb2597J2YIOyduOyKpO2EtOyKpC4g7ZSE66Gc7KCd7IWY7J2EIO2ZnOyEse2ZlO2VmOyngCDslYrslZjsnYQg6rK97JqwIGBudWxsYOyeheuLiOuLpC5cclxuICAgKiDtjIzrhbjrnbzrp4gg7J2066+47KeAIOyGjOyKpOuCmCDtlITroZzsoJ3shZgg7YOA7J6F7J2EIOuzgOqyve2VmOugpOuptCB7QGxpbmsgVmlldzM2MCNsb2FkfeulvCDtmLjstpztlZjrqbQg65Cp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlldzM2MFxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgcHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdGlvbjtcbiAgfVxuICBzZXQgcHJvamVjdGlvbih2YWwpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQgJiYgdmFsKSB7XG4gICAgICB0aGlzLmxvYWQodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJvamVjdGlvbiA9IHZhbDtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQW4gaW5zdGFuY2Ugb2YgdHJpYW5nbGUgbWVzaCB0byByZW5kZXIuXHJcbiAgICogQGtvIOugjOuNlOunge2VoCB0cmlhbmdsZSBtZXNo7J2YIOyduOyKpO2EtOyKpFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xuICBnZXQgbWVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVzaDtcbiAgfVxuICAvKipcclxuICAgKiBBIGJvb2xlYW4gdmFsdWUgd2hldGhlciB7QGxpbmsgVmlldzM2MCNpbml0IGluaXQoKX0gaXMgY2FsbGVkIGJlZm9yZS5cclxuICAgKiBAa28ge0BsaW5rIFZpZXczNjAjaW5pdCBpbml0KCl97J20IO2YuOy2nOuQmOyXiOuKlOyngCDsl6zrtoDrpbwg6rCA66as7YKk64qUIOqwklxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlldzM2MChcIiNlbFwiLCB7IGF1dG9Jbml0OiBmYWxzZSB9KTtcclxuICAgKlxyXG4gICAqIGNvbnNvbGUubG9nKHZpZXdlci5pbml0aWFsaXplZCk7IC8vIGZhbHNlXHJcbiAgICpcclxuICAgKiBhd2FpdCB2aWV3ZXIuaW5pdCgpO1xyXG4gICAqXHJcbiAgICogY29uc29sZS5sb2codmlld2VyLmluaXRpYWxpemVkKTsgLy8gdHJ1ZVxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgaW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVkO1xuICB9XG4gIC8qKlxyXG4gICAqIEluc3RhbmNlIG9mIHRoZSBBdXRvcGxheSBtYW5hZ2VyLlxyXG4gICAqIFlvdSBjYW4gYWxzbyBjaGFuZ2Uge0BsaW5rIFZpZXczNjBPcHRpb25zI2F1dG9wbGF5fSBvcHRpb25zIHdpdGggdGhpcy5cclxuICAgKiBAa28gQXV0b3BsYXkg6riw64ql7J2YIOunpOuLiOyggCDsnbjsiqTthLTsiqQuXHJcbiAgICog7J20IOyduOyKpO2EtOyKpOulvCDthrXtlbQge0BsaW5rIFZpZXczNjBPcHRpb25zI2F1dG9wbGF5fSDsmLXshZjsnYQg67OA6rK97ZWY64qUIOqyg+uPhCDqsIDriqXtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIC8vIERpc2FibGUgYXV0b3BsYXlcclxuICAgKiB2aWV3ZXIuYXV0b3BsYXkuZGlzYWJsZSgpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgYXV0b3BsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9wbGF5O1xuICB9XG4gIC8qKlxyXG4gICAqIFdoZW4gdGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgYW5kIHtAbGluayBWaWV3MzYwT3B0aW9ucyNwcm9qZWN0aW9ufSBpcyBzZXQsIHtAbGluayBWaWV3MzYwI2luaXQgaW5pdCgpfSB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gaW5zdGFuY2UgaXMgY3JlYXRlZC5cclxuICAgKiBAa28g7J20IOqwkuydtCBgdHJ1ZWDsnbTqs6AsIHtAbGluayBWaWV3MzYwT3B0aW9ucyNwcm9qZWN0aW9ufeydtCDshKTsoJXrkJjsl4jsnLzrqbQsIOyduOyKpO2EtOyKpCDsg53shLEg7Iuc7KCQ7JeQIOyekOuPmeycvOuhnCB7QGxpbmsgVmlldzM2MCNpbml0IGluaXQoKX3snYQg7Zi47Lac7ZWp64uI64ukLlxyXG4gICAqIEBkZWZhdWx0IHRydWVcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IFZpZXczNjAsIHsgRXF1aXJlY3RQcm9qZWN0aW9uLCBFVkVOVFMgfSBmcm9tIFwiQGVnanMvdmlldzM2MFwiO1xyXG4gICAqXHJcbiAgICogLy8gdmlld2VyLmluaXQoKSBpcyBjYWxsZWQgb24gaW5zdGFuY2UgY3JlYXRpb25cclxuICAgKiAvLyBCdXQgYXMgYGluaXRgIGlzIGFzeW5jaHJvbm91cywgeW91IHNob3VsZCB3YWl0IGZvciBcInJlYWR5XCIgZXZlbnQgaWYgeW91IHdhbnQgdG8gZG8gc29tZXRoaW5nIGFmdGVyIGluaXRpYWxpemF0aW9uLlxyXG4gICAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3MzYwKFwiI2VsX2lkXCIsIHtcclxuICAgKiAgIGF1dG9Jbml0OiB0cnVlLFxyXG4gICAqICAgcHJvamVjdGlvbjogbmV3IEVxdWlyZWN0UHJvamVjdGlvbih7IHNyYzogXCJTUkNfVE9fVVJMXCIgfSlcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIGNvbnNvbGUubG9nKHZpZXdlci5pbml0aWFsaXplZCk7IC8vIGZhbHNlLCBhcyBgaW5pdGAgaXMgYXN5bmNocm9ub3VzXHJcbiAgICpcclxuICAgKiB2aWV3ZXIub25jZShFVkVOVFMuUkVBRFksICgpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHZpZXdlci5pbml0aWFsaXplZCk7IC8vIHRydWVcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgZ2V0IGF1dG9Jbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRvSW5pdDtcbiAgfVxuICAvKipcclxuICAgKiBXaGVuIGB0cnVlYCwge0BsaW5rIFZpZXczNjAjcmVzaXplfSBpcyBjYWxsZWQgd2hlbiB0aGUgY2FudmFzIHNpemUgaXMgY2hhbmdlZC5cclxuICAgKiBAa28gYHRydWVg7J28IOqyveyasCwg7LqU67KE7Iqk7J2YIO2BrOq4sOqwgCDrs4Dqsr3rkJjsl4jsnYQg65WMIOyekOuPmeycvOuhnCB7QGxpbmsgVmlldzM2MCNyZXNpemV966W8IO2YuOy2nO2VqeuLiOuLpC5cclxuICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQHNlZSBWaWV3MzYwI3VzZVJlc2l6ZU9ic2VydmVyXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3MzYwKFwiI2VsX2lkXCIsIHtcclxuICAgKiAgIGF1dG9SZXNpemU6IHRydWVcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIC8vIFRoaXMgY2FuIHRyaWdnZXIgYHZpZXdlci5yZXNpemUoKWAgaWYgdGhlIGNhbnZhcyBzaXplIHdhcyBub3QgNDAwcHhcclxuICAgKiBjb25zdCBjYW52YXMgPSB2aWV3ZXIucmVuZGVyZXIuY2FudmFzO1xyXG4gICAqIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiNDAwcHhcIjtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgZ2V0IGF1dG9SZXNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9SZXNpemU7XG4gIH1cbiAgLyoqXHJcbiAgICogQ1NTIHNlbGVjdG9yIGZvciBjYW52YXMgZWxlbWVudCB0byByZW5kZXIgcGFub3JhbWEgaW1hZ2UvdmlkZW8uXHJcbiAgICogVGhlIGNhbnZhcyBlbGVtZW50IHNob3VsZCBiZSBwbGFjZWQgaW5zaWRlIHRoZSByb290IGVsZW1lbnQuIChEb250JyBoYXZlIHRvIGJlIGRpcmVjdCBjaGlsZClcclxuICAgKiBAa28g7YyM64W4652866eIIOydtOuvuOyngC/ruYTrlJTsmKTrpbwg66CM642U66eB7ZWgIGNhbnZhcyDsl5jrpqzrqLztirjsnZggQ1NTIOyEoO2DneyekFxyXG4gICAqIOy6lOuyhOyKpCDsl5jrpqzrqLztirjripQg66Oo7Yq4IOyXmOumrOuovO2KuCDrgrTrtoDsl5Ag7J6I7Ja07JW87ZWp64uI64ukLiDro6jtirgg7JeY66as66i87Yq47J2YIOyngeqzhCDsnpDsi50g7JeY66as66i87Yq4KERpcmVjdCBjaGlsZCBlbGVtZW50KeydvCDtlYTsmpTripQg7JeG7Iq164uI64ukLlxyXG4gICAqIEBkZWZhdWx0IFwiY2FudmFzXCJcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYGh0bWxcclxuICAgKiA8ZGl2IGNsYXNzPVwidmlldzM2MC1jb250YWluZXJcIj5cclxuICAgKiAgIDxjYW52YXMgaWQ9XCJub3RfdGhpc19vbmVcIj48L2NhbnZhcz5cclxuICAgKiAgIDwhLS0gVGhpcyB3aWxsIGJlIHNlbGVjdGVkIC0tPlxyXG4gICAqICAgPGNhbnZhcyBpZD1cImNhbnZhc190b19zZWxlY3RcIj48L2NhbnZhcz5cclxuICAgKiA8L2Rpdj5cclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3Qgdmlld2VyID0gbmV3IFZpZXczNjAoXCIjZWxfaWRcIiwge1xyXG4gICAqICAgY2FudmFzU2VsZWN0b3I6IFwiI2NhbnZhc190b19zZWxlY3RcIlxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgY2FudmFzU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhc1NlbGVjdG9yO1xuICB9XG4gIC8qKlxyXG4gICAqIFdoZW4gYHRydWVgLCBpdCB3aWxsIHVzZSB7QGxpbmsgUmVzaXplT2JzZXJ2ZXJ9IEFQSSB0byBkZXRlY3QgY2FudmFzIHNpemUgY2hhbmdlIHdoZW4ge0BsaW5rIFZpZXczNjBPcHRpb25zI2F1dG9SZXNpemV9IGlzIGVuYWJsZWQuXHJcbiAgICogQGtvIGB0cnVlYOydvCDrlYwge0BsaW5rIFZpZXczNjBPcHRpb25zI2F1dG9SZXNpemV96rCAIO2ZnOyEse2ZlOuQmOyXiOycvOuptCwg7IKs7JqpIOqwgOuKpe2VnCDtmZjqsr3sl5DshJwge0BsaW5rIFJlc2l6ZU9ic2VydmVyfSBBUEnrpbwg7IKs7Jqp7ZW07IScIOy6lOuyhOyKpCDtgazquLAg67OA7ZmU66W8IOy2lOygge2VqeuLiOuLpC5cclxuICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCB1c2VSZXNpemVPYnNlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlUmVzaXplT2JzZXJ2ZXI7XG4gIH1cbiAgLyoqXHJcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXggdGFiaW5kZXh9IGF0dHJpYnV0ZSBmb3IgdGhlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0aGUga2V5Ym9hcmQgY29udHJvbHMuXHJcbiAgICogQnkgZGVmYXVsdCwgYDBgIHdpbGwgYmUgYXNzaWduZWQuIGBudWxsYCB0byBkaXNhYmxlLlxyXG4gICAqIEBrbyDsupTrsoTsiqQg7JeY66as66i87Yq47JeQIOyggeyaqe2VoCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleCB0YWJpbmRleH0g7Ja07Yq466as67ew7Yq47J2YIOqwki5cclxuICAgKiDsnbQg6rCS7J2EIOyEpOygle2VtOyVvOunjCDtgqTrs7Trk5wg7Luo7Yq466Gk7J2EIOyCrOyaqSDqsIDriqXtlanri4jri6QuXHJcbiAgICog6riw67O46rCS7Jy866GcIGAwYOydtCDshKTsoJXrkKnri4jri6QuIGBudWxsYOuhnCDsp4DsoJXtlZjrqbQgYHRhYmluZGV4YOulvCDshKTsoJXtlZjsp4Ag7JWK7Iq164uI64ukLlxyXG4gICAqIEBzZWUgUm90YXRlQ29udHJvbE9wdGlvbnMjZGlzYWJsZUtleWJvYXJkXHJcbiAgICogQGRlZmF1bHQgMFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlldzM2MChcIiNlbF9pZFwiLCB7XHJcbiAgICogICB0YWJpbmRleDogNVxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogYGBgaHRtbFxyXG4gICAqIDwhLS0gQWZ0ZXIgaW5pdCAtLT5cclxuICAgKiA8ZGl2IGNsYXNzPVwidmlldzM2MC1jb250YWluZXJcIj5cclxuICAgKiAgIDxjYW52YXMgY2xhc3M9XCJ2aWV3MzYwLWNhbnZhc1wiIHRhYmluZGV4PVwiNVwiPjwvY2FudmFzPlxyXG4gICAqIDwvZGl2PlxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhYkluZGV4O1xuICB9XG4gIHNldCB0YWJJbmRleCh2YWwpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9yZW5kZXJlci5jYW52YXM7XG4gICAgdGhpcy5fdGFiSW5kZXggPSB2YWw7XG4gICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICBjYW52YXMudGFiSW5kZXggPSB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQSBtYXhpbXVtIGRlbHRhIHRpbWUgYmV0d2VlbiBmcmFtZXMgaW4gc2Vjb25kcy5cclxuICAgKiBJdCBjYW4gcHJldmVudCBjYW1lcmEgb3IgY29udHJvbCBjaGFuZ2luZyB0b28gZmFzdCB3aGVuIGZyYW1lIGJlaW5nIGxhdGUuXHJcbiAgICogQGtvIO2UhOugiOyehOqwhCDsi5zqsIQg7LCo7J207J2YIOy1nOuMgOqwki4gKOy0iCDri6jsnIQpXHJcbiAgICog7Y287Y+s66i87IqkIOuTseydmCDsnbTsnKDroZwg7ZSE66CI7J6EIOugjOuNlOungeydtCDriqbslrTsoYzsnYQg65WMLCDtmZTrqbTsnbQg6rCR7J6R7Iqk65+96rKMIOuwlOuAjOuKlCDqsoPsnYQg66eJ7JWE7KSN64uI64ukLlxyXG4gICAqIEBkZWZhdWx0IDEgLyAzMFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgbWF4RGVsdGFUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRvci5tYXhEZWx0YVRpbWU7XG4gIH1cbiAgc2V0IG1heERlbHRhVGltZSh2YWwpIHtcbiAgICB0aGlzLl9hbmltYXRvci5tYXhEZWx0YVRpbWUgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogRW5hYmxlIFdlYkdMIGRlYnVnZ2luZy4gU2V0dGluZyB0aGlzIHRvIGB0cnVlYCBjYW4gZGVjcmVhc2UgcGVyZm9ybWFuY2UuXHJcbiAgICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgb24gZGV2ZWxvcGluZyBWaWV3MzYwLlxyXG4gICAqIEBrbyBXZWJHTCDrlJTrsoTquYXsnYQg7Zmc7ISx7ZmU7ZWp64uI64ukLiDsnbQg6rCS7J2EIGB0cnVlYOuhnCDtlaAg6rK97JqwIOyEseuKpeydtCDtlZjrnb3tlaAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgKiDsnbQg7Ji17IWY7J2AIFZpZXczNjDsnYQg6rCc67Cc7ZWY6riwIOychO2VtCDrgrTrtoDsoIHsnLzroZwg7IKs7Jqp65Cp64uI64ukLlxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICovXG4gIGdldCBkZWJ1ZygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVidWc7XG4gIH1cbiAgc2V0IGRlYnVnKHZhbCkge1xuICAgIHRoaXMuX2RlYnVnID0gdmFsO1xuICB9XG4gIC8vIENhbWVyYSBvcHRpb25zXG4gIC8qKlxyXG4gICAqIEluaXRpYWwgeWF3ICh5LWF4aXMgcm90YXRpb24pIHZhbHVlIGZvciBjYW1lcmEuIChpbiBkZWdyZWVzLCDCsClcclxuICAgKiBBcyBWaWV3MzYwIHVzZXMgcmlnaHQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtIGludGVybmFsbHksIGNhbWVyYSB3aWxsIHJvdGF0ZSBjb3VudGVyLWNsb2Nrd2lzZSBieSB0aGlzIHZhbHVlLlxyXG4gICAqIEBrbyDsubTrqZTrnbzsnZgg7LSI6riwIHlhdyh57LaVIO2ajOyghCnqsJIgKOuPhCDri6jsnIQsIMKwKVxyXG4gICAqIFZpZXczNjDsnYAg7Jik66W47IaQIOyijO2RnOqzhOulvCDsgqzsmqntlZjquLAg65WM66y47JeQLCDsubTrqZTrnbzqsIAg7ZW064u5IOqwkuunjO2BvCDsi5zqs4Qg67CY64yA67Cp7Zal7Jy866GcIO2ajOyghO2VqeuLiOuLpC5cclxuICAgKiBAZGVmYXVsdCAwXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3MzYwKFwiI2VsX2lkXCIsIHtcclxuICAgKiAgIGluaXRpYWxZYXc6IDMwXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiB2aWV3ZXIub24oXCJyZWFkeVwiLCAoKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyh2aWV3ZXIuY2FtZXJhLnlhdyk7IC8vIDMwXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIGdldCBpbml0aWFsWWF3KCkge1xuICAgIHJldHVybiB0aGlzLl9jYW1lcmEuaW5pdGlhbFlhdztcbiAgfVxuICBzZXQgaW5pdGlhbFlhdyh2YWwpIHtcbiAgICB0aGlzLl9jYW1lcmEuaW5pdGlhbFlhdyA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsIHBpdGNoICh4LWF4aXMgcm90YXRpb24pIHZhbHVlIGZvciBjYW1lcmEuIChpbiBkZWdyZWVzLCDCsClcclxuICAgKiBBcyBWaWV3MzYwIHVzZXMgcmlnaHQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtIGludGVybmFsbHksIHBvc2l0aXZlIHZhbHVlIHdpbGwgbWFrZSBjYW1lcmEgdG8gbG9vayB1cHNpZGUsIHdoaWxlIG5lZ2F0aXZlIHZhbHVlIHdpbGwgbG9vayBkb3duLlxyXG4gICAqIEBrbyDsubTrqZTrnbzsnZgg7LSI6riwIHBpdGNoKHjstpUg7ZqM7KCEKeqwkiAo64+EIOuLqOychCwgwrApXHJcbiAgICogVmlldzM2MOydgCDsmKTrpbjshpAg7KKM7ZGc6rOE66W8IOyCrOyaqe2VmOq4sCDrlYzrrLjsl5AsIOyWkSgrKeydmCDqsJLsnYAg7Lm066mU65286rCAIOychOulvCDrs7Tqsowg7ZWY6rOgLCDsnYwoLSnsnZgg6rCS7J2AIOy5tOuplOudvOqwgCDslYTrnpjrpbwg67O06rKMIO2VqeuLiOuLpC5cclxuICAgKiBAZGVmYXVsdCAwXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3MzYwKFwiI2VsX2lkXCIsIHtcclxuICAgKiAgIGluaXRpYWxQaXRjaDogNjBcclxuICAgKiB9KTtcclxuICAgKlxyXG4gICAqIHZpZXdlci5vbihcInJlYWR5XCIsICgpID0+IHtcclxuICAgKiAgIGNvbnNvbGUubG9nKHZpZXdlci5jYW1lcmEucGl0Y2gpOyAvLyA2MFxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgaW5pdGlhbFBpdGNoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW1lcmEuaW5pdGlhbFBpdGNoO1xuICB9XG4gIHNldCBpbml0aWFsUGl0Y2godmFsKSB7XG4gICAgdGhpcy5fY2FtZXJhLmluaXRpYWxQaXRjaCA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsIHpvb20gdmFsdWUgZm9yIGNhbWVyYS5cclxuICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgdG8gYDJgIHdpbGwgZW5sYXJnZSBwYW5vcmFtYSAyMDAlIGJ5IHdpZHRoLlxyXG4gICAqIEBrbyDsubTrqZTrnbzsnZgg7LSI6riwIOykjCDqsJIuXHJcbiAgICog7J20IOqwkuydhCBgMmDroZwg7ISk7KCV7ZWgIOqyveyasCDtjIzrhbjrnbzrp4gg7J2066+47KeA66W8IOqwgOuhnCDquLDspIAgMjAwJeunjO2BvCDtmZXrjIDtlanri4jri6QuXHJcbiAgICogQGRlZmF1bHQgMVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlldzM2MChcIiNlbF9pZFwiLCB7XHJcbiAgICogICBpbml0aWFsWm9vbTogMlxyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICogdmlld2VyLm9uKFwicmVhZHlcIiwgKCkgPT4ge1xyXG4gICAqICAgY29uc29sZS5sb2codmlld2VyLmNhbWVyYS56b29tKTsgLy8gMlxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgaW5pdGlhbFpvb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbWVyYS5pbml0aWFsWm9vbTtcbiAgfVxuICBzZXQgaW5pdGlhbFpvb20odmFsKSB7XG4gICAgdGhpcy5fY2FtZXJhLmluaXRpYWxab29tID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc3RyaWN0IHlhdyh5LWF4aXMgcm90YXRpb24pIHJhbmdlLiAoaW4gZGVncmVlcywgwrApXHJcbiAgICogQGtvIHlhdyh57LaVIO2ajOyghCkg67KU7JyE66W8IOygnO2VnO2VqeuLiOuLpC4gKOuPhCDri6jsnIQsIMKwKVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlldzM2MChcIiNlbF9pZFwiLCB7XHJcbiAgICogICB5YXdSYW5nZTogWy0zMCwgMzBdXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiB2aWV3ZXIub24oXCJyZWFkeVwiLCAoKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyh2aWV3ZXIuY2FtZXJhLnlhdyk7IC8vIDBcclxuICAgKiAgIHZpZXdlci5jYW1lcmEubG9va0F0KHsgeWF3OiA2MCAgfSk7XHJcbiAgICogICBjb25zb2xlLmxvZyh2aWV3ZXIuY2FtZXJhLnlhdyk7IC8vIDMwXHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIGdldCB5YXdSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FtZXJhLnlhd1JhbmdlO1xuICB9XG4gIHNldCB5YXdSYW5nZSh2YWwpIHtcbiAgICB0aGlzLl9jYW1lcmEueWF3UmFuZ2UgPSB2YWw7XG4gICAgaWYgKHRoaXMuX3Byb2plY3Rpb24pIHRoaXMuX3Byb2plY3Rpb24udXBkYXRlQ2FtZXJhKHRoaXMuX2NhbWVyYSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzdHJpY3QgcGl0Y2goeC1heGlzIHJvdGF0aW9uKSByYW5nZS4gKGluIGRlZ3JlZXMsIMKwKVxyXG4gICAqIEBrbyBwaXRjaCh47LaVIO2ajOyghCkg67KU7JyE66W8IOygnO2VnO2VqeuLiOuLpC4gKOuPhCDri6jsnIQsIMKwKVxyXG4gICAqIEBkZWZhdWx0IG51bGxcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3Qgdmlld2VyID0gbmV3IFZpZXczNjAoXCIjZWxfaWRcIiwge1xyXG4gICAqICAgcGl0Y2hSYW5nZTogWy00NSwgNDVdXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiB2aWV3ZXIub24oXCJyZWFkeVwiLCAoKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyh2aWV3ZXIuY2FtZXJhLnBpdGNoKTsgLy8gMFxyXG4gICAqICAgdmlld2VyLmNhbWVyYS5sb29rQXQoeyBwaXRjaDogNjAgIH0pO1xyXG4gICAqICAgY29uc29sZS5sb2codmlld2VyLmNhbWVyYS5waXRjaCk7IC8vIDQ1XHJcbiAgICogfSk7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIGdldCBwaXRjaFJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW1lcmEucGl0Y2hSYW5nZTtcbiAgfVxuICBzZXQgcGl0Y2hSYW5nZSh2YWwpIHtcbiAgICB0aGlzLl9jYW1lcmEucGl0Y2hSYW5nZSA9IHZhbDtcbiAgICBpZiAodGhpcy5fcHJvamVjdGlvbikgdGhpcy5fcHJvamVjdGlvbi51cGRhdGVDYW1lcmEodGhpcy5fY2FtZXJhKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXN0cmljdCBjYW1lcmEgem9vbSByYW5nZS5cclxuICAgKiBJZiBgbnVsbGAsIGEgZGVmYXVsdCB6b29tIHJhbmdlIGZyb20gYDAuNmAgdG8gYDEwYCB3aWxsIGJlIHVzZWQuXHJcbiAgICogQGtvIOy5tOuplOudvCDspIwg67KU7JyE66W8IOygnO2VnO2VqeuLiOuLpC5cclxuICAgKiBgbnVsbGDsnbwg6rK97JqwIOq4sOuzuOqwkuycvOuhnCBgMC42YOyXkOyEnCBgMTBg7J2YIOuylOychOulvCDsgqzsmqntlanri4jri6QuXHJcbiAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlldzM2MChcIiNlbF9pZFwiLCB7XHJcbiAgICogICB6b29tUmFuZ2U6IFswLjUsIDRdXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiB2aWV3ZXIub24oXCJyZWFkeVwiLCAoKSA9PiB7XHJcbiAgICogICBjb25zb2xlLmxvZyh2aWV3ZXIuY2FtZXJhLnpvb20pOyAvLyAxXHJcbiAgICogICB2aWV3ZXIuY2FtZXJhLmxvb2tBdCh7IHpvb206IDYgIH0pO1xyXG4gICAqICAgY29uc29sZS5sb2codmlld2VyLmNhbWVyYS56b29tKTsgLy8gNFxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBnZXQgem9vbVJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW1lcmEuem9vbVJhbmdlO1xuICB9XG4gIHNldCB6b29tUmFuZ2UodmFsKSB7XG4gICAgdGhpcy5fY2FtZXJhLnpvb21SYW5nZSA9IHZhbDtcbiAgICBpZiAodGhpcy5fcHJvamVjdGlvbikgdGhpcy5fcHJvamVjdGlvbi51cGRhdGVDYW1lcmEodGhpcy5fY2FtZXJhKTtcbiAgfVxuICAvKipcclxuICAgKiBDYW1lcmEncyBob3Jpem9udGFsIEZPVihGaWVsZCBvZiBWaWV3KS4gKGluIGRlZ3JlZXMsIMKwKVxyXG4gICAqIEBrbyDsubTrqZTrnbzsnZgg7IiY7Y+JIEZPVihGaWVsZCBvZiBWaWV3KSDqsJIuICjrj4Qg64uo7JyELCDCsClcclxuICAgKiBAZGVmYXVsdCA5MFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiAvLyBJbml0IHdpdGggZm92OiAxMjBcclxuICAgKiBjb25zdCB2aWV3ZXIgPSBuZXcgVmlldzM2MChcIiNlbF9pZFwiLCB7IGZvdjogMTIwIH0pO1xyXG4gICAqXHJcbiAgICogLy8gQmFjayB0byA5MFxyXG4gICAqIHZpZXdlci5mb3YgPSA5MDtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgZ2V0IGZvdigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FtZXJhLmZvdjtcbiAgfVxuICBzZXQgZm92KHZhbCkge1xuICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcbiAgICBjb25zdCBjb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICBjYW1lcmEuZm92ID0gdmFsO1xuICAgIGNhbWVyYS51cGRhdGVNYXRyaXgoKTtcbiAgICBjb250cm9sLnN5bmMoKTtcbiAgfVxuICAvLyBDb250cm9sIG9wdGlvbnNcbiAgLyoqXHJcbiAgICogQSBjb250cm9sIGZvciBjYW1lcmEgcm90YXRpb24uXHJcbiAgICogWW91IGNhbiBhbHNvIGNoYW5nZSBvcHRpb25zIG9mIHtAbGluayBWaWV3MzYwT3B0aW9ucyNyb3RhdGV9IHdpdGggdGhpcy5cclxuICAgKiBAa28g7Lm066mU6528IO2ajOyghOydhCDri7Tri7ntlZjripQg7Luo7Yq466GkLlxyXG4gICAqIHtAbGluayBWaWV3MzYwT3B0aW9ucyNyb3RhdGV9IOyYteyFmCDrs4Dqsr3rj4Qg6rCA64ql7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sLnJvdGF0ZTtcbiAgfVxuICAvKipcclxuICAgKiBBIGNvbnRyb2wgZm9yIGNhbWVyYSB6b29tLlxyXG4gICAqIFlvdSBjYW4gYWxzbyBjaGFuZ2Ugb3B0aW9ucyBvZiB7QGxpbmsgVmlldzM2ME9wdGlvbnMjem9vbX0gd2l0aCB0aGlzLlxyXG4gICAqIEBrbyDsubTrqZTrnbwg7KSM7J2EIOuLtOuLue2VmOuKlCDsu6jtirjroaQuXHJcbiAgICoge0BsaW5rIFZpZXczNjBPcHRpb25zI3pvb219IOyYteyFmCDrs4Dqsr3rj4Qg6rCA64ql7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xuICBnZXQgem9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbC56b29tO1xuICB9XG4gIC8qKlxyXG4gICAqIEEgY29udHJvbCBmb3IgY2FtZXJhIHJvdGF0aW9uIHdpdGggZ3lyb3Njb3BlIGlucHV0LlxyXG4gICAqIFlvdSBjYW4gYWxzbyBjaGFuZ2Ugb3B0aW9ucyBvZiB7QGxpbmsgVmlldzM2ME9wdGlvbnMjZ3lyb30gd2l0aCB0aGlzLlxyXG4gICAqIEBrbyDsnpDsnbTroZzsiqTsvZTtlITrpbwg7Ya17ZWcIOy5tOuplOudvCDtmozsoITsnYQg64u064u57ZWY64qUIOy7qO2KuOuhpC5cclxuICAgKiB7QGxpbmsgVmlldzM2ME9wdGlvbnMjZ3lyb30g7Ji17IWYIOuzgOqyveuPhCDqsIDriqXtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXG4gIGdldCBneXJvKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sLmd5cm87XG4gIH1cbiAgLyoqXHJcbiAgICogQXBwbHkgQ1NTIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY3Vyc29yIGN1cnNvcn0gYnkgY3VycmVudCBzdGF0ZSBvZiBpbnB1dCB3aGVuIHVzaW5nIG1vdXNlLlxyXG4gICAqIElmIGB0cnVlYCwgdGhpcyB3aWxsIGFkZCBDU1Mgc3R5bGUgdG8gY2FudmFzIGVsZW1lbnQuIEl0J2xsIGFwcGx5IGBjdXJzb3I6IFwiZ3JhYlwiYCBieSBkZWZhdWx0IGFuZCBgY3Vyc29yOiBcImdyYWJiaW5nXCJgIHdoZW4gaG9sZGluZyB0aGUgbW91c2UgYnV0dG9uLlxyXG4gICAqIEBrbyDrp4jsmrDsiqQg7IKs7Jqp7IucIENTUyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2N1cnNvciBjdXJzb3J96rCS7J2EIOyekOuPmeycvOuhnCDrs4Dqsr3tlaDsp4Ag7Jes67aALlxyXG4gICAqIGB0cnVlYOydvCDqsr3smrAg6riw67O4IOyDge2DnOyXkOyEnCBgY3Vyc29yOiBcImdyYWJcImDsnYQsIOyeheugpSDrj4TspJHsl5AgYGN1cnNvcjogXCJncmFiYmluZ1wiYOydhCDsupTrsoTsiqTsl5Ag7KCB7Jqp7ZWp64uI64ukLlxyXG4gICAqIEBkZWZhdWx0IHRydWVcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IHVzZUdyYWJDdXJzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wudXNlR3JhYkN1cnNvcjtcbiAgfVxuICBzZXQgdXNlR3JhYkN1cnNvcih2YWwpIHtcbiAgICB0aGlzLl9jb250cm9sLnVzZUdyYWJDdXJzb3IgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogRGlzYWJsZSBjb250ZXh0IG1lbnUgd2hpY2ggcG9wcyB1cCBvbiBtb3VzZSByaWdodCBjbGljay5cclxuICAgKiBAa28g66eI7Jqw7IqkIOyasO2BtOumreyLnCDtkZzsi5zrkJjripQg7Luo7YWN7Iqk7Yq4IOuplOuJtOulvCDruYTtmZzshLHtmZTtlanri4jri6QuXHJcbiAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGRpc2FibGVDb250ZXh0TWVudSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbC5kaXNhYmxlQ29udGV4dE1lbnU7XG4gIH1cbiAgc2V0IGRpc2FibGVDb250ZXh0TWVudSh2YWwpIHtcbiAgICB0aGlzLl9jb250cm9sLmRpc2FibGVDb250ZXh0TWVudSA9IHZhbDtcbiAgfVxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIGVuYWJsZXMgc2Nyb2xsIG9uIG1vYmlsZSh0b3VjaCkgZGV2aWNlcyBvbiBjYW52YXMuXHJcbiAgICogOjo6Y2F1dGlvblxyXG4gICAqIFdoZW4gdGhpcyBvcHRpb24gaXMgZW5hYmxlZCwgdXNlcnMgbXVzdCBzd2lwZSBob3Jpem9udGFsbHkgZmlyc3QgdGhlbiB2ZXJ0aWNhbGx5IHRvIGNoYW5nZSB2aWV3IHVwIG9yIGRvd24uXHJcbiAgICogOjo6XHJcbiAgICogQGtvIGB0cnVlYOuhnCDshKTsoJXtlaAg6rK97JqwLCDrqqjrsJTsnbwo7YSw7LmYKSDtmZjqsr3snZgg7LqU67KE7IqkIOyYgeyXrSDrgrTsl5DshJwg7Iqk7YGs66Gk7J2EIOqwgOuKpe2VmOqyjCDtlanri4jri6QuXHJcbiAgICogOjo6Y2F1dGlvblxyXG4gICAqIOydtCDqsJLsnYQg7Zmc7ISx7ZmU7ZWgIOqyveyasCwg7IKs7Jqp7J6Q6rCAIOy5tOuplOudvCDrt7Drpbwg7JyEL+yVhOuemOuhnCDrsJTqvrjquLAg7JyE7ZW07ISc64qUIOuovOyggCDqsIDroZzroZwg7Iqk7JmA7J207ZSE7ZWcIOydtO2bhOyXkCDshLjroZzroZwg7Iqk7JmA7J207ZSE7ZW07JW866eMIO2VqeuLiOuLpC5cclxuICAgKiA6OjpcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICovXG4gIGdldCBzY3JvbGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sLnNjcm9sbGFibGU7XG4gIH1cbiAgc2V0IHNjcm9sbGFibGUodmFsKSB7XG4gICAgdGhpcy5fY29udHJvbC5zY3JvbGxhYmxlID0gdmFsO1xuICB9XG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgZW5hYmxlcyBzY3JvbGwgYnkgbW91c2Ugd2hlZWwgb24gY2FudmFzLlxyXG4gICAqIDo6OmNhdXRpb25cclxuICAgKiBXaGVuIHRoaXMgb3B0aW9uIGlzIGVuYWJsZWQsIHpvb20gYnkgbW91c2Ugd2hlZWwgd2lsbCBiZSBkaXNhYmxlZC5cclxuICAgKiA6OjpcclxuICAgKiBAa28gYHRydWVg66GcIOyEpOygle2VoCDqsr3smrAsIOy6lOuyhOyKpCDsmIHsl60g64K07JeQ7IScIOuniOyasOyKpCDtnKDsnYQg7J207Jqp7ZWcIO2OmOydtOyngCDsiqTtgazroaTsnbQg6rCA64ql7ZW07KeR64uI64ukLlxyXG4gICAqIDo6OmNhdXRpb25cclxuICAgKiDsnbQg6rCS7J2EIO2ZnOyEse2ZlO2VoCDqsr3smrAsIOuniOyasOyKpCDtnKDsnYQg7Ya17ZWcIOykjOydtCDrtojqsIDriqXtlZjqsowg65Cp64uI64ukLlxyXG4gICAqIDo6OlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICovXG4gIGdldCB3aGVlbFNjcm9sbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wud2hlZWxTY3JvbGxhYmxlO1xuICB9XG4gIHNldCB3aGVlbFNjcm9sbGFibGUodmFsKSB7XG4gICAgdGhpcy5fY29udHJvbC53aGVlbFNjcm9sbGFibGUgPSB2YWw7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBpbnN0YW5jZSBvZiBWaWV3MzYwXHJcbiAgICogQGtvIFZpZXczNjDsnZgg7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6RcclxuICAgKiBAcGFyYW0gcm9vdCAtIFJvb3QgZWxlbWVudChgLnZpZXczNjAtY29udGFpbmVyYCkgdG8gbW91bnQgVmlldzM2MFxyXG4gICAqIENhbiBiZSBlaXRoZXIgYSBDU1Mgc2VsZWN0b3Igb3IgSFRNTEVsZW1lbnQuXHJcbiAgICoge0BrbyBWaWV3MzYw7J2EIOuniOyatO2KuO2VoCDro6jtirgg7JeY66as66i87Yq4LCBDU1Mg7IWA66CJ7YSw64KYIEhUTUxFbGVtZW5066W8IOyngOyglSDqsIDriqXtlanri4jri6QufVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBhcHBseVxyXG4gICAqIHtAa28g7KCB7Jqp7ZWgIOyYteyFmOuTpH1cclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IFZpZXczNjAsIHsgRXF1aXJlY3RQcm9qZWN0aW9uIH0gZnJvbSBcIkBlZ2pzL3ZpZXczNjBcIjtcclxuICAgKlxyXG4gICAqIC8vIENyZWF0ZSBuZXcgVmlldzM2MCBpbnN0YW5jZVxyXG4gICAqIGNvbnN0IHZpZXdlciA9IG5ldyBWaWV3MzYwKFwiI2lkLW9mLWEtY29udGFpbmVyXCIsIHtcclxuICAgKiAgIHByb2plY3Rpb246IG5ldyBFcXVpcmVjdFByb2plY3Rpb24oe1xyXG4gICAqICAgICBzcmM6IFwiVVJMX1RPX1BBTk9SQU1BX0lNQUdFX09SX1ZJREVPXCIsXHJcbiAgICogICB9KVxyXG4gICAqIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290LCB7XG4gICAgcHJvamVjdGlvbiA9IG51bGwsXG4gICAgaW5pdGlhbFlhdyA9IDAsXG4gICAgaW5pdGlhbFBpdGNoID0gMCxcbiAgICBpbml0aWFsWm9vbSA9IDEsXG4gICAgeWF3UmFuZ2UgPSBudWxsLFxuICAgIHBpdGNoUmFuZ2UgPSBudWxsLFxuICAgIHpvb21SYW5nZSA9IG51bGwsXG4gICAgZm92ID0gOTAsXG4gICAgdXNlR3JhYkN1cnNvciA9IHRydWUsXG4gICAgZGlzYWJsZUNvbnRleHRNZW51ID0gZmFsc2UsXG4gICAgcm90YXRlID0gdHJ1ZSxcbiAgICB6b29tID0gdHJ1ZSxcbiAgICBneXJvID0gZmFsc2UsXG4gICAgc2Nyb2xsYWJsZSA9IHRydWUsXG4gICAgd2hlZWxTY3JvbGxhYmxlID0gZmFsc2UsXG4gICAgYXV0b3BsYXkgPSBmYWxzZSxcbiAgICBob3RzcG90ID0ge30sXG4gICAgYXV0b0luaXQgPSB0cnVlLFxuICAgIGF1dG9SZXNpemUgPSB0cnVlLFxuICAgIGNhbnZhc1NlbGVjdG9yID0gXCJjYW52YXNcIixcbiAgICB1c2VSZXNpemVPYnNlcnZlciA9IHRydWUsXG4gICAgb24gPSB7fSxcbiAgICBwbHVnaW5zID0gW10sXG4gICAgbWF4RGVsdGFUaW1lID0gMSAvIDMwLFxuICAgIHRhYkluZGV4ID0gMCxcbiAgICBkZWJ1ZyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgYSBzaW5nbGUgcGFub3JhbWEgaW1hZ2UvdmlkZW8gZnJhbWUuXHJcbiAgICAgKiBSZW5kZXJpbmcgaXMgcGVyZm9ybWVkIGF1dG9tYXRpY2FsbHkgb24gZGVtYW5kLCBzbyB5b3UgdXN1YWxseSBkb24ndCBoYXZlIHRvIGNhbGwgdGhpcy5cclxuICAgICAqIENhbGwgdGhpcyB3aGVuIGEgZnJhbWUgaXMgbm90IHJlbmV3ZWQgYWZ0ZXIgY2hhbmdpbmcgb3B0aW9ucy5cclxuICAgICAqIEBrbyDtjIzrhbjrnbzrp4gg7J2066+47KeAL+u5hOuUlOyYpOydmCDtlZwg7ZSE66CI7J6E7J2EIOugjOuNlOunge2VqeuLiOuLpC5cclxuICAgICAqIO2UhOugiOyehCDqsLHsi6DsnYAg67O07Ya1IO2VhOyalO2VnCDrlYzsl5Drp4wg7J6Q64+Z7KCB7Jy866GcIOydtOujqOyWtOyngOq4sCDrlYzrrLjsl5AsIOuztO2GteydgCDsnbQg66mU7IaM65Oc66W8IO2YuOy2nO2VoCDtlYTsmpTripQg7JeG7Iq164uI64ukLlxyXG4gICAgICog7Ji17IWYIOuzgOqyvSDsnbTtm4Tsl5Drj4Qg7ZSE66CI7J6EIOqwseyLoOydtCDsnbTro6jslrTsp4Dsp4Ag7JWK64qU64uk66m0LCDsnbQg66mU7IaM65Oc66W8IO2YuOy2nO2VtOyjvOyEuOyalC5cclxuICAgICAqIEBwYXJhbSBkZWx0YSBEZWx0YSB0aW1lIGluIG1pbGlzZWMuIHtAa28g7ZSE66CI7J6E6rCEIOyLnOqwhCDssKjsnbQsIOuwgOumrOy0iCDri6jsnIR9XHJcbiAgICAgKiBAc2luY2UgNC4wLjBcclxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyRnJhbWUgPSBkZWx0YSA9PiB7XG4gICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgY29uc3QgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgICBjb25zdCBob3RzcG90ID0gdGhpcy5faG90c3BvdDtcbiAgICAgIGNvbnN0IGF1dG9QbGF5ZXIgPSB0aGlzLl9hdXRvcGxheTtcbiAgICAgIGNvbnN0IG1lc2ggPSB0aGlzLl9tZXNoO1xuICAgICAgaWYgKCFtZXNoKSByZXR1cm47XG4gICAgICB0aGlzLl9lbWl0KEVWRU5UUy5CRUZPUkVfUkVOREVSKTtcbiAgICAgIGlmIChhdXRvUGxheWVyLnBsYXlpbmcpIHtcbiAgICAgICAgYXV0b1BsYXllci51cGRhdGUoZGVsdGEpO1xuICAgICAgICBjb250cm9sLnN5bmMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW1lcmEuYW5pbWF0aW9uKSB7XG4gICAgICAgIGNhbWVyYS5hbmltYXRpb24udXBkYXRlKGRlbHRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlKGRlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlcmVyLnJlbmRlcihtZXNoLCBjYW1lcmEpO1xuICAgICAgaG90c3BvdC5yZW5kZXIoY2FtZXJhKTtcbiAgICAgIGlmIChjYW1lcmEuY2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9lbWl0KEVWRU5UUy5WSUVXX0NIQU5HRSwge1xuICAgICAgICAgIHlhdzogY2FtZXJhLnlhdyxcbiAgICAgICAgICBwaXRjaDogY2FtZXJhLnBpdGNoLFxuICAgICAgICAgIHpvb206IGNhbWVyYS56b29tLFxuICAgICAgICAgIHF1YXRlcm5pb246IFtjYW1lcmEucXVhdGVybmlvblswXSwgY2FtZXJhLnF1YXRlcm5pb25bMV0sIGNhbWVyYS5xdWF0ZXJuaW9uWzJdLCBjYW1lcmEucXVhdGVybmlvblszXV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYW1lcmEub25GcmFtZVJlbmRlcigpO1xuICAgICAgdGhpcy5fZW1pdChFVkVOVFMuUkVOREVSKTtcbiAgICB9O1xuICAgIHRoaXMuX3JlbmRlckZyYW1lT25EZW1hbmQgPSBkZWx0YSA9PiB7XG4gICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgICBjb25zdCBjb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICAgIGNvbnN0IGF1dG9wbGF5ID0gdGhpcy5fYXV0b3BsYXk7XG4gICAgICBjb25zdCBtZXNoID0gdGhpcy5fbWVzaDtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBtZXNoID09PSBudWxsIHx8IG1lc2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc2guZ2V0VGV4dHVyZSgpO1xuICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCB8fCAhdGV4dHVyZSkgcmV0dXJuO1xuICAgICAgaWYgKCFjYW1lcmEuYW5pbWF0aW9uICYmICFjb250cm9sLmFuaW1hdGluZyAmJiAhYXV0b3BsYXkucGxheWluZyAmJiAhdGV4dHVyZS5pc1ZpZGVvKCkpIHJldHVybjtcbiAgICAgIHRoaXMucmVuZGVyRnJhbWUoZGVsdGEpO1xuICAgIH07XG4gICAgdGhpcy5fcmVuZGVyVlJGcmFtZSA9IChfZGVsdGEsIGZyYW1lKSA9PiB7XG4gICAgICBjb25zdCB2ciA9IHRoaXMuX3ZyO1xuICAgICAgY29uc3QgbWVzaCA9IHRoaXMuX21lc2g7XG4gICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgaWYgKCFtZXNoKSByZXR1cm47XG4gICAgICB0aGlzLl9lbWl0KEVWRU5UUy5CRUZPUkVfUkVOREVSKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlclZSKG1lc2gsIHZyLCBmcmFtZSk7XG4gICAgICB0aGlzLl9lbWl0KEVWRU5UUy5SRU5ERVIpO1xuICAgIH07XG4gICAgdGhpcy5fcm9vdEVsID0gZ2V0RWxlbWVudChyb290KTtcbiAgICB0aGlzLl9wbHVnaW5zID0gcGx1Z2lucztcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIC8vIE9wdGlvbnNcbiAgICB0aGlzLl9hdXRvSW5pdCA9IGF1dG9Jbml0O1xuICAgIHRoaXMuX2F1dG9SZXNpemUgPSBhdXRvUmVzaXplO1xuICAgIHRoaXMuX2NhbnZhc1NlbGVjdG9yID0gY2FudmFzU2VsZWN0b3I7XG4gICAgdGhpcy5fdXNlUmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcjtcbiAgICB0aGlzLl90YWJJbmRleCA9IHRhYkluZGV4O1xuICAgIHRoaXMuX2RlYnVnID0gZGVidWc7XG4gICAgLy8gQ29yZSBjb21wb25lbnRzXG4gICAgY29uc3QgY2FudmFzID0gZmluZENhbnZhcyh0aGlzLl9yb290RWwsIGNhbnZhc1NlbGVjdG9yKTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKGNhbnZhcywgZGVidWcpO1xuICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBDYW1lcmEoe1xuICAgICAgaW5pdGlhbFlhdyxcbiAgICAgIGluaXRpYWxQaXRjaCxcbiAgICAgIGluaXRpYWxab29tLFxuICAgICAgZm92LFxuICAgICAgeWF3UmFuZ2UsXG4gICAgICBwaXRjaFJhbmdlLFxuICAgICAgem9vbVJhbmdlXG4gICAgfSk7XG4gICAgdGhpcy5fY29udHJvbCA9IG5ldyBQYW5vQ29udHJvbChjYW52YXMsIHRoaXMuX2NhbWVyYSwge1xuICAgICAgdXNlR3JhYkN1cnNvcixcbiAgICAgIHNjcm9sbGFibGUsXG4gICAgICB3aGVlbFNjcm9sbGFibGUsXG4gICAgICBkaXNhYmxlQ29udGV4dE1lbnUsXG4gICAgICByb3RhdGUsXG4gICAgICB6b29tLFxuICAgICAgZ3lyb1xuICAgIH0pO1xuICAgIHRoaXMuX2FuaW1hdG9yID0gbmV3IEZyYW1lQW5pbWF0b3IobWF4RGVsdGFUaW1lKTtcbiAgICB0aGlzLl9hdXRvcGxheSA9IG5ldyBBdXRvcGxheSh0aGlzLCBjYW52YXMsIGF1dG9wbGF5KTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB0aGlzLl9hdXRvUmVzaXplciA9IG5ldyBBdXRvUmVzaXplcih1c2VSZXNpemVPYnNlcnZlciwgKCkgPT4gdGhpcy5yZXNpemUoKSk7XG4gICAgdGhpcy5fdnIgPSBuZXcgWFJNYW5hZ2VyKHRoaXMuX3JlbmRlcmVyLmN0eCk7XG4gICAgdGhpcy5faG90c3BvdCA9IG5ldyBIb3RzcG90UmVuZGVyZXIodGhpcy5fcm9vdEVsLCB0aGlzLl9yZW5kZXJlciwgaG90c3BvdCk7XG4gICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVycyhvbik7XG4gICAgaWYgKHByb2plY3Rpb24gJiYgYXV0b0luaXQpIHtcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBEZXN0cm95IGluc3RhbmNlIGFuZCByZWxlYXNlIGFsbCByZXNvdXJjZXMuXHJcbiAgICogQGtvIOyduOyKpO2EtOyKpOulvCDsoJzqsbDtlZjqs6Ag66qo65OgIOumrOyGjOyKpOulvCDtlbTsoJztlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY2FtZXJhLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9hbmltYXRvci5zdG9wKCk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2NvbnRyb2wuZGVzdHJveSgpO1xuICAgIHRoaXMuX2F1dG9SZXNpemVyLmRpc2FibGUoKTtcbiAgICBpZiAodGhpcy5fbWVzaCkge1xuICAgICAgdGhpcy5fbWVzaC5kZXN0cm95KHRoaXMuX3JlbmRlcmVyLmN0eCk7XG4gICAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uZGVzdHJveSh0aGlzKSk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGlubmVyIGNvbXBvbmVudHMgYW5kIGxvYWQgcHJvamVjdGlvbiBzcmMuXHJcbiAgICogQGtvIOuCtOu2gCDsu7Ttj6zrhIztirjrk6TsnYQg7LSI6riw7ZmU7ZWY6rOgIO2UhOuhnOygneyFmCDshozsiqTrpbwg66Gc65Oc7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBpbml0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3Byb2plY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFZpZXczNjBFcnJvcihFUlJPUi5NRVNTQUdFUy5QUk9WSURFX1BST0pFQ1RJT05fRklSU1QsIEVSUk9SLkNPREVTLlBST1ZJREVfUFJPSkVDVElPTl9GSVJTVCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgICAgY29uc3QgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yO1xuICAgICAgY29uc3QgaG90c3BvdCA9IHRoaXMuX2hvdHNwb3Q7XG4gICAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5fcHJvamVjdGlvbjtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHJlbmRlcmVyLmNhbnZhcztcbiAgICAgIHRoaXMuX2JpbmRDb21wb25lbnRFdmVudHMoKTtcbiAgICAgIHJlbmRlcmVyLmN0eC5pbml0KCk7XG4gICAgICB0aGlzLl9yZXNpemVDb21wb25lbnRzKCk7XG4gICAgICBjYW1lcmEudXBkYXRlTWF0cml4KCk7XG4gICAgICBpZiAodGhpcy5fYXV0b1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLl9hdXRvUmVzaXplci5lbmFibGUoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fYXV0b3BsYXkuZW5hYmxlQmxvY2tlZCkge1xuICAgICAgICB0aGlzLl9hdXRvcGxheS5lbmFibGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICBwbHVnaW4uaW5pdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHlpZWxkIHRoaXMuX2xvYWRUZXh0dXJlKHByb2plY3Rpb24pO1xuICAgICAgdGhpcy5fYXBwbHlQcm9qZWN0aW9uKHByb2plY3Rpb24sIHRleHR1cmUpO1xuICAgICAgaG90c3BvdC5yZWZyZXNoKCk7XG4gICAgICBhbmltYXRvci5zdGFydCh0aGlzLl9yZW5kZXJGcmFtZU9uRGVtYW5kKTtcbiAgICAgIHlpZWxkIGNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICBpZiAodGhpcy5fdGFiSW5kZXggIT0gbnVsbCAmJiAhY2FudmFzLmhhc0F0dHJpYnV0ZShcInRhYkluZGV4XCIpKSB7XG4gICAgICAgIGNhbnZhcy50YWJJbmRleCA9IHRoaXMuX3RhYkluZGV4O1xuICAgICAgfVxuICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJGcmFtZSgwKTtcbiAgICAgIHRoaXMuX2VtaXQoRVZFTlRTLlJFQURZKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBMb2FkIG5ldyBwYW5vcmFtYSBpbWFnZS92aWRlbyBhbmQgZGlzcGxheSBpdC5cclxuICAgKiBUaGlzIHdpbGwge0BsaW5rIFZpZXczNjAjaW5pdCBpbml0KCl9IFZpZXczNjAgaWYgaXQncyBub3QgaW5pdGlhbGl6ZWQgeWV0LlxyXG4gICAqIEBrbyDsg4jroZzsmrQg7YyM64W4652866eIIOydtOuvuOyngCDtmLnsnYAg67mE65SU7Jik66W8IOuhnOuTnO2VmOqzoCDtkZzsi5ztlanri4jri6QuXHJcbiAgICog66eM7JW9IFZpZXczNjDsnbQg7JWE7KeBIOy0iOq4sO2ZlOuQmOyngCDslYrslZjri6TrqbQsIHtAbGluayBWaWV3MzYwI2luaXQgaW5pdCgpfeydhCDtmLjstpztlanri4jri6QuXHJcbiAgICogQHBhcmFtIHByb2plY3Rpb24gLSBQcm9qZWN0aW9uICYgdmlkZW8gb3B0aW9ucyBmb3IgbmV3IHNvdXJjZS4ge0BrbyDsg4jroZzsmrQg7YyM64W4652866eIIOydtOuvuOyngC/ruYTrlJTsmKTsl5Ag7KCB7Jqp7ZWgIOyYteyFmOuTpH1cclxuICAgKiBAcmV0dXJucyBgUHJvbWlzZTx0cnVlPmAgaWYgbG9hZCB3YXMgc3VjY2Vzc2Z1bC4ge0BrbyDtlITroZzsoJ3shZgg66Gc65Oc7JeQIOyEseqzte2WiOydhCDqsr3smrAgYFByb21pc2U8dHJ1ZT5g66W8IOuwmO2ZmO2VqeuLiOuLpC4gfVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiAvLyBDaGFuZ2UgdG8gdmlkZW9cclxuICAgKiB2aWV3ZXIubG9hZCh7XHJcbiAgICogICBzcmM6IFwiVVJMX1RPX05FV19WSURFT1wiLFxyXG4gICAqICAgdmlkZW86IHRydWVcclxuICAgKiB9KTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgbG9hZChwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghcHJvamVjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB5aWVsZCB0aGlzLl9sb2FkVGV4dHVyZShwcm9qZWN0aW9uKTtcbiAgICAgICAgdGhpcy5fYXBwbHlQcm9qZWN0aW9uKHByb2plY3Rpb24sIHRleHR1cmUpO1xuICAgICAgICB0aGlzLnJlbmRlckZyYW1lKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2hvdWxkIHVwZGF0ZSBpbnRlcm5hbCBvcHRpb25zIGJlZm9yZSBpbml0XG4gICAgICAgIHRoaXMuX3Byb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlZnJlc2ggY29tcG9uZW50J3Mgc2l6ZSBieSBjdXJyZW50XHJcbiAgICogQGtvIFZpZXczNjDsnbQg64K067aA7KCB7Jy866GcIOy6kOyLnO2VmOqzoCDsnojripQg7JeY66as66i87Yq4IO2BrOq4sOulvCDtmITsnqwg7YGs6riw66GcIOqwseyLoO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgcmVzaXplKCkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICB0aGlzLl9yZXNpemVDb21wb25lbnRzKCk7XG4gICAgLy8gVG8gcHJldmVudCBmbGlja2VyaW5nLCByZW5kZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgcmVzaXppbmcgY29tcG9uZW50c1xuICAgIHRoaXMucmVuZGVyRnJhbWUoMCk7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgdGhpcy5fZW1pdChFVkVOVFMuUkVTSVpFLCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZCBuZXcgcGx1Z2luc1xyXG4gICAqIEBrbyDsg4jroZzsmrQg7ZSM65+s6re47J247J2EIOy2lOqwgO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gcGx1Z2lucyBQbHVnaW5zIHRvIGFkZCB7QGtvIOy2lOqwgO2VoCDtlIzrn6zqt7jsnbjrk6R9XHJcbiAgICogQHNlZSBWaWV3MzYwT3B0aW9ucyNwbHVnaW5zXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIC8vIEFkZCBhIHNpbmdsZSBwbHVnaW5cclxuICAgKiB2aWV3ZXIuYWRkUGx1Z2lucyhuZXcgQ29udHJvbEJhcigpKTtcclxuICAgKlxyXG4gICAqIC8vIEFkZCBtdWx0aXBsZSBwbHVnaW5zXHJcbiAgICogdmlld2VyLmFkZFBsdWdpbnMobmV3IENvbnRyb2xCYXIoKSwgbmV3IExvYWRpbmdTcGlubmVyKCkpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBhZGRQbHVnaW5zKC4uLnBsdWdpbnMpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICBwbHVnaW4uaW5pdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9wbHVnaW5zLnB1c2goLi4ucGx1Z2lucyk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlIHBsdWdpbnMuXHJcbiAgICogQGtvIO2UjOufrOq3uOyduOydhCDsoJzqsbDtlanri4jri6QuXHJcbiAgICogQHBhcmFtIHBsdWdpbnMgUGx1Z2lucyB0byByZW1vdmUge0BrbyDsoJzqsbDtlaAg7ZSM65+s6re47J2465OkfVxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiAvLyBSZW1vdmUgYSBzaW5nbGUgcGx1Z2luXHJcbiAgICogdmlld2VyLnJlbW92ZVBsdWdpbnMocGx1Z2luMSk7XHJcbiAgICpcclxuICAgKiAvLyBSZW1vdmUgbXVsdGlwbGUgcGx1Z2luc1xyXG4gICAqIHZpZXdlci5yZW1vdmVQbHVnaW5zKHBsdWdpbjIsIHBsdWdpbjMpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICByZW1vdmVQbHVnaW5zKC4uLnBsdWdpbnMpIHtcbiAgICBwbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgIGNvbnN0IHBsdWdpbklkeCA9IHRoaXMuX3BsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xuICAgICAgaWYgKHBsdWdpbklkeCA8IDApIHJldHVybjtcbiAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgdGhpcy5fcGx1Z2lucy5zcGxpY2UocGx1Z2luSWR4LCAxKTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdChldmVudE5hbWUsIC4uLnBhcmFtcykge1xuICAgIGNvbnN0IGV2dFBhcmFtcyA9IHBhcmFtcyA/IHBhcmFtc1swXSA6IHt9O1xuICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHlwZTogZXZlbnROYW1lLFxuICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgfSwgZXZ0UGFyYW1zKSk7XG4gIH1cbiAgX2FwcGx5UHJvamVjdGlvbihwcm9qZWN0aW9uLCB0ZXh0dXJlKSB7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMuX21lc2g7XG4gICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNvbnRleHRcbiAgICBpZiAobWVzaCkge1xuICAgICAgbWVzaC5kZXN0cm95KHJlbmRlcmVyLmN0eCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld01lc2ggPSBwcm9qZWN0aW9uLmNyZWF0ZU1lc2gocmVuZGVyZXIuY3R4LCB0ZXh0dXJlKTtcbiAgICBwcm9qZWN0aW9uLnVwZGF0ZUNhbWVyYShjYW1lcmEpO1xuICAgIHByb2plY3Rpb24udXBkYXRlQ29udHJvbChjb250cm9sKTtcbiAgICB0aGlzLl9tZXNoID0gbmV3TWVzaDtcbiAgICB0aGlzLl9lbWl0KEVWRU5UUy5QUk9KRUNUSU9OX0NIQU5HRSwge1xuICAgICAgcHJvamVjdGlvblxuICAgIH0pO1xuICB9XG4gIF9sb2FkVGV4dHVyZShwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzcmMsXG4gICAgICAgIHZpZGVvXG4gICAgICB9ID0gcHJvamVjdGlvbjtcbiAgICAgIHRoaXMuX2VtaXQoRVZFTlRTLkxPQURfU1RBUlQsIHtcbiAgICAgICAgc3JjLFxuICAgICAgICB2aWRlb1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0dXJlID0geWllbGQgY29udGVudExvYWRlci5sb2FkKHNyYywgdmlkZW8pO1xuICAgICAgdGhpcy5fZW1pdChFVkVOVFMuTE9BRCwge1xuICAgICAgICBzcmMsXG4gICAgICAgIHZpZGVvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICB9XG4gIF9yZXNpemVDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIGNvbnN0IGNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgIHJlbmRlcmVyLnJlc2l6ZSgpO1xuICAgIGNhbWVyYS5yZXNpemUocmVuZGVyZXIud2lkdGgsIHJlbmRlcmVyLmhlaWdodCk7XG4gICAgY29udHJvbC5yZXNpemUocmVuZGVyZXIud2lkdGgsIHJlbmRlcmVyLmhlaWdodCk7XG4gIH1cbiAgX2FkZEV2ZW50SGFuZGxlcnMoZXZlbnRzKSB7XG4gICAgLy8gQmluZCBvcHRpb24gXCJvblwiXG4gICAgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGV2dE5hbWUgPT4ge1xuICAgICAgdGhpcy5vbihldnROYW1lLCBldmVudHNbZXZ0TmFtZV0pO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIC8vIEJpbmQgaW50ZXJuYWwgY29tcG9uZW50IGV2ZW50c1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290RWw7XG4gICAgY29uc3QgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvcjtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGNvbnN0IHZyID0gdGhpcy5fdnI7XG4gICAgY29uc3QgY29udHJvbEV2ZW50c1RvUHJvcGFnYXRlID0gW0NPTlRST0xfRVZFTlRTLlNUQVRJQ19DTElDSywgQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIENPTlRST0xfRVZFTlRTLklOUFVUX0VORF07XG4gICAgY29udHJvbEV2ZW50c1RvUHJvcGFnYXRlLmZvckVhY2goZXZ0TmFtZSA9PiB7XG4gICAgICBjb250cm9sLnJvdGF0ZS5vbihldnROYW1lLCBldnQgPT4ge1xuICAgICAgICB0aGlzLl9lbWl0KGV2dE5hbWUsIGV2dCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnRyb2wuem9vbS5vbihldnROYW1lLCBldnQgPT4ge1xuICAgICAgICB0aGlzLl9lbWl0KGV2dE5hbWUsIGV2dCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2ci5vbihFVkVOVFMuVlJfU1RBUlQsIGV2dCA9PiB7XG4gICAgICByb290LmNsYXNzTGlzdC5hZGQoREVGQVVMVF9DTEFTUy5JTl9WUik7XG4gICAgICBhbmltYXRvci5jaGFuZ2VDb250ZXh0KGV2dC5zZXNzaW9uKTtcbiAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMuX3JlbmRlclZSRnJhbWUpO1xuICAgICAgdGhpcy5fZW1pdChFVkVOVFMuVlJfU1RBUlQpO1xuICAgIH0pO1xuICAgIHZyLm9uKEVWRU5UUy5WUl9FTkQsICgpID0+IHtcbiAgICAgIHJvb3QuY2xhc3NMaXN0LnJlbW92ZShERUZBVUxUX0NMQVNTLklOX1ZSKTtcbiAgICAgIHJlbmRlcmVyLmN0eC51c2VEZWZhdWx0RnJhbWVCdWZmZXIoKTtcbiAgICAgIGFuaW1hdG9yLmNoYW5nZUNvbnRleHQod2luZG93KTtcbiAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMuX3JlbmRlckZyYW1lT25EZW1hbmQpO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIHRoaXMuX2VtaXQoRVZFTlRTLlZSX0VORCk7XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBDdXJyZW50IHZlcnNpb24gc3RyaW5nIG9mIHRoZSBWaWV3MzYwXHJcbiAqIEBrbyBWaWV3MzYw7J2YIO2YhOyerCDrsoTsoLwg66y47J6Q7Je0XHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKiBAcmVhZG9ubHlcclxuICogQGV4YW1wbGVcclxuICogYGBgdHNcclxuICogLy8gSWYgdGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIHRoZSBWaWV3MzYwIGlzIHY0LjAuMCwgVmlldzM2MC5WRVJTSU9OIGlzIGVxdWFsIHRvIFwiNC4wLjBcIlxyXG4gKiBjb25zb2xlLmxvZyhWaWV3MzYwLlZFUlNJT04pIC8vIDQuMC4wXHJcbiAqIGBgYFxyXG4gKi9cblZpZXczNjAuVkVSU0lPTiA9IFwiNC4wLjAtYmV0YS43XCI7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciAzRCBvYmplY3RzXHJcbiAqIEBrbyAzRCDsmKTruIzsoJ3tirjsnZgg67Kg7J207IqkIO2BtOuemOyKpFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGludGVybmFsXHJcbiAqL1xuY2xhc3MgT2JqZWN0M0QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlLlxyXG4gICAqIEBrbyDsg4jroZzsmrQg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHF1YXQuY3JlYXRlKCk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKTtcbiAgICB0aGlzLnNjYWxlID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBsb2NhbCBtYXRyaXggb2YgdGhlIG9iamVjdC5cclxuICAgKiBAa28g7Jik67iM7KCd7Yq47J2YIGxvY2FsIG1hdHJpeOulvCDqsLHsi6Dtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIHVwZGF0ZU1hdHJpeCgpIHtcbiAgICBtYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUodGhpcy5tYXRyaXgsIHRoaXMucm90YXRpb24sIHRoaXMucG9zaXRpb24sIHRoaXMuc2NhbGUpO1xuICB9XG4gIHVwZGF0ZShjdHgpIHtcbiAgICB0aGlzLnRyaWdnZXIoT0JKRUNUXzNEX0VWRU5UUy5VUERBVEUsIGN0eCk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEEgcGx1Z2luIHRoYXQgZGlzcGxheXMgbG9hZGluZyBzcGlubmVyIHdoaWxlIGxvYWRpbmcgdGhlIHByb2plY3Rpb24uXHJcbiAqIEBrbyDtlITroZzsoJ3shZgg66Gc65Sp7KSR7JeQIOuhnOuUqSDsiqTtlLzrhIjrpbwg67O07Jes7KO864qUIO2UjOufrOq3uOyduFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IFBsdWdpblxyXG4gKi9cbmNsYXNzIExvYWRpbmdTcGlubmVyIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIExvYWRpbmdTcGlubmVyLiB7QGtvIExvYWRpbmdTcGlubmVy7J2YIOyDiCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLn1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHtAa28g7Ji17IWY65OkfVxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2xhc3NOYW1lID0ge31cbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5fc3RhcnRMb2FkaW5nID0gKHtcbiAgICAgIHRhcmdldDogdmlld2VyXG4gICAgfSkgPT4ge1xuICAgICAgdmlld2VyLnJvb3RFbC5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgaWYgKHZpZXdlci5pbml0aWFsaXplZCkge1xuICAgICAgICB2aWV3ZXIub25jZShFVkVOVFMuTE9BRCwgdGhpcy5fZGV0YWNoRWxlbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld2VyLm9uY2UoRVZFTlRTLlJFQURZLCB0aGlzLl9kZXRhY2hFbGVtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9kZXRhY2hFbGVtZW50cyA9ICh7XG4gICAgICB0YXJnZXQ6IHZpZXdlclxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgICBpZiAoY29udGFpbmVyLnBhcmVudEVsZW1lbnQgPT09IHZpZXdlci5yb290RWwpIHtcbiAgICAgICAgdmlld2VyLnJvb3RFbC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcbiAgfVxuICBpbml0KHZpZXdlcikge1xuICAgIHZpZXdlci5vbihFVkVOVFMuTE9BRF9TVEFSVCwgdGhpcy5fc3RhcnRMb2FkaW5nKTtcbiAgfVxuICBkZXN0cm95KHZpZXdlcikge1xuICAgIHZpZXdlci5vZmYoRVZFTlRTLkxPQURfU1RBUlQsIHRoaXMuX3N0YXJ0TG9hZGluZyk7XG4gICAgdGhpcy5fZGV0YWNoRWxlbWVudHMoe1xuICAgICAgdGFyZ2V0OiB2aWV3ZXJcbiAgICB9KTtcbiAgfVxuICBfY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNsYXNzTmFtZSksIExvYWRpbmdTcGlubmVyLkRFRkFVTFRfQ0xBU1MpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLkNPTlRBSU5FUik7XG4gICAgY29uc3QgcmluZyA9IGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLlJJTkcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyaW5nKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG59XG4vKipcclxuICogRGVmYXVsdCBjbGFzcyBuYW1lcyB0aGF0IExvYWRpbmdTcGlubmVyIHVzZXNcclxuICogQGtvIExvYWRpbmdTcGlubmVy6rCAIOyCrOyaqe2VmOuKlCDrlJTtj7Ttirgg7YG0656Y7IqkIOydtOumhFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5Mb2FkaW5nU3Bpbm5lci5ERUZBVUxUX0NMQVNTID0ge1xuICAvKipcclxuICAgKiBBIGNsYXNzIG5hbWUgZm9yIHRoZSBjb250YWluZXIgZWxlbWVudFxyXG4gICAqIEBrbyDsu6jthYzsnbTrhIgg7JeY66as66i87Yq47J2YIO2BtOuemOyKpCDsnbTrpoRcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgQ09OVEFJTkVSOiBcInZpZXczNjAtc3Bpbm5lclwiLFxuICAvKipcclxuICAgKiBBIGNsYXNzIG5hbWUgZm9yIHRoZSBzcGlubmluZyByaW5nIGVsZW1lbnRcclxuICAgKiBAa28g64+M7JWE6rCA64qUIOungSDsl5jrpqzrqLztirjsnZgg7YG0656Y7IqkIOydtOumhFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBSSU5HOiBcInZpZXczNjAtc3Bpbm5lci1yaW5nXCJcbn07XG5cbi8qKlxyXG4gKiBJbnRlcmZhY2Ugb2YgdGhlIENvbnRyb2xCYXIgaXRlbXNcclxuICogQGtvIOy7qO2KuOuhpOuwlCDslYTsnbTthZzsnZgg7J247YSw7Y6Y7J207IqkXHJcbiAqIEBjYXRlZ29yeSBQbHVnaW5cclxuICogQGdyb3VwIENvbnRyb2xCYXJcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgQ29udHJvbEJhckl0ZW0ge1xuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlIG9mIHRoZSBDb250cm9sQmFySXRlbVxyXG4gICAqIEBrbyBDb250cm9sQmFySXRlbeydmCDsg4jroZzsmrQg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHtAa28g7Ji17IWY65OkfVxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgdGhpcy5vcmRlciA9IG9wdGlvbnMub3JkZXI7XG4gIH1cbn1cblxuY29uc3QgQ09OVFJPTF9CQVJfREVGQVVMVF9DTEFTUyA9IHtcbiAgQ09OVFJPTFNfUk9PVDogXCJ2aWV3MzYwLWNvbnRyb2xzXCIsXG4gIENPTlRST0xTX0JHOiBcInZpZXczNjAtY29udHJvbHMtYmFja2dyb3VuZFwiLFxuICBDT05UUk9MU19NQUlOOiBcInZpZXczNjAtY29udHJvbHMtbWFpblwiLFxuICBDT05UUk9MU19UT1A6IFwidmlldzM2MC1jb250cm9scy10b3BcIixcbiAgQ09OVFJPTFNfQk9UVE9NOiBcInZpZXczNjAtY29udHJvbHMtYm90dG9tXCIsXG4gIENPTlRST0xTX01JRDogXCJ2aWV3MzYwLWNvbnRyb2xzLW1pZFwiLFxuICBDT05UUk9MU19MRUZUOiBcInZpZXczNjAtY29udHJvbHMtbGVmdFwiLFxuICBDT05UUk9MU19SSUdIVDogXCJ2aWV3MzYwLWNvbnRyb2xzLXJpZ2h0XCIsXG4gIENPTlRST0xTX0ZMT0FUX0xFRlQ6IFwidmlldzM2MC1jb250cm9scy1mbG9hdC1sZWZ0XCIsXG4gIENPTlRST0xTX0ZMT0FUX1JJR0hUOiBcInZpZXczNjAtY29udHJvbHMtZmxvYXQtcmlnaHRcIixcbiAgQ09OVFJPTFNfQlVUVE9OOiBcInZpZXczNjAtY29udHJvbHMtYnV0dG9uXCIsXG4gIFBST0dSRVNTX1JPT1Q6IFwidmlldzM2MC1jb250cm9scy1wcm9ncmVzc1wiLFxuICBWT0xVTUVfUk9PVDogXCJ2aWV3MzYwLWNvbnRyb2xzLXZvbHVtZVwiLFxuICBSQU5HRV9ST09UOiBcInZpZXczNjAtcmFuZ2VcIixcbiAgUkFOR0VfVFJBQ0s6IFwidmlldzM2MC1yYW5nZS10cmFja1wiLFxuICBSQU5HRV9USFVNQjogXCJ2aWV3MzYwLXJhbmdlLXRodW1iXCIsXG4gIFJBTkdFX0ZJTExFUjogXCJ2aWV3MzYwLXJhbmdlLWZpbGxlclwiLFxuICBQTEFZX0JVVFRPTjogXCJ2aWV3MzYwLWNvbnRyb2xzLXBsYXlcIixcbiAgUEFVU0VfQlVUVE9OOiBcInZpZXczNjAtY29udHJvbHMtcGF1c2VcIixcbiAgVU5NVVRFRF9CVVRUT046IFwidmlldzM2MC1jb250cm9scy11bm11dGVkXCIsXG4gIE1VVEVEX0JVVFRPTjogXCJ2aWV3MzYwLWNvbnRyb2xzLW11dGVkXCIsXG4gIEZVTExTQ1JFRU5fQlVUVE9OOiBcInZpZXczNjAtY29udHJvbHMtZnVsbHNjcmVlblwiLFxuICBGVUxMU0NSRUVOX0VYSVRfQlVUVE9OOiBcInZpZXczNjAtY29udHJvbHMtZnVsbHNjcmVlbi1leGl0XCIsXG4gIFZSX0JVVFRPTjogXCJ2aWV3MzYwLWNvbnRyb2xzLXZyXCIsXG4gIEdZUk9fRU5BQkxFRDogXCJ2aWV3MzYwLWNvbnRyb2xzLWd5cm8tZW5hYmxlZFwiLFxuICBHWVJPX0RJU0FCTEVEOiBcInZpZXczNjAtY29udHJvbHMtZ3lyby1kaXNhYmxlZFwiLFxuICBWSURFT19USU1FX0RJU1BMQVk6IFwidmlldzM2MC1jb250cm9scy10aW1lXCIsXG4gIFBJRVZJRVdfUk9PVDogXCJ2aWV3MzYwLWNvbnRyb2xzLXBpZVwiLFxuICBGSVhFRDogXCJ2aWV3MzYwLWNvbnRyb2xzLWZpeGVkXCIsXG4gIFVOQVZBSUxBQkxFOiBcInZpZXczNjAtY29udHJvbHMtdW5hdmFpbGFibGVcIixcbiAgSElEREVOOiBcInZpZXczNjAtY29udHJvbHMtaGlkZGVuXCJcbn07XG5jb25zdCBDT05UUk9MX0JBUl9JVEVNX1BPU0lUSU9OID0ge1xuICAvKipcclxuICAgKiBQbGFjZSBjb250cm9sIGJhciBpdGVtIGZsb2F0aW5nIGF0IHRvcC1sZWZ0IGNvcm5lclxyXG4gICAqIEBrbyDslYTsnbTthZzsnYQg7Jm87Kq9IOychCDqtazshJ3sl5Ag7ZGc7Iuc7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBUT1BfTEVGVDogXCJ0b3AtbGVmdFwiLFxuICAvKipcclxuICAgKiBQbGFjZSBjb250cm9sIGJhciBpdGVtIGZsb2F0aW5nIGF0IHRvcC1yaWdodCBjb3JuZXJcclxuICAgKiBAa28g7JWE7J207YWc7J2EIOyYpOuluOyqvSDsnIQg6rWs7ISd7JeQIO2RnOyLnO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgVE9QX1JJR0hUOiBcInRvcC1yaWdodFwiLFxuICAvKipcclxuICAgKiBQbGFjZSBjb250cm9sIGJhciBpdGVtIGF0IHVwcGVyIGJsb2NrIGluc2lkZSB0aGUgYm90dG9tIGNvbnRyb2wgYmFyLlxyXG4gICAqIEBrbyDslYTsnbTthZzsnYQg7ZWY64uo7JeQIO2RnOyLnOuQmOuKlCDsu6jtirjroaTrsJQg64K07JeQ7IScIOychOyqvSDruJTrn63sl5Ag7ZGc7Iuc7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBNQUlOX1RPUDogXCJtYWluLXRvcFwiLFxuICAvKipcclxuICAgKiBQbGFjZSBjb250cm9sIGJhciBpdGVtIGF0IGxvd2VyIGJsb2NrIGluc2lkZSB0aGUgYm90dG9tIGNvbnRyb2wgYmFyLlxyXG4gICAqIEBrbyDslYTsnbTthZzsnYQg7ZWY64uo7JeQIO2RnOyLnOuQmOuKlCDsu6jtirjroaTrsJQg64K07JeQ7IScIO2VmOuLqCDruJTrn63sl5Ag7ZGc7Iuc7ZWp64uI64ukLlxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBNQUlOX0JPVFRPTTogXCJtYWluLWJvdHRvbVwiLFxuICAvKipcclxuICAgKiBQbGFjZSBjb250cm9sIGJhciBpdGVtIGF0IGNlbnRlci1sZWZ0IGJsb2NrIGluc2lkZSB0aGUgYm90dG9tIGNvbnRyb2wgYmFyLlxyXG4gICAqIEBrbyDslYTsnbTthZzsnYQg7ZWY64uo7JeQIO2RnOyLnOuQmOuKlCDsu6jtirjroaTrsJQg64K07JeQ7IScIOykkeqwhCDsmbzsqr0g67iU65+t7JeQIO2RnOyLnO2VqeuLiOuLpC5cclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgTUFJTl9MRUZUOiBcIm1haW4tbGVmdFwiLFxuICAvKipcclxuICAgKiBQbGFjZSBjb250cm9sIGJhciBpdGVtIGF0IGNlbnRlci1yaWdodCBibG9jayBpbnNpZGUgdGhlIGJvdHRvbSBjb250cm9sIGJhci5cclxuICAgKiBAa28g7JWE7J207YWc7J2EIO2VmOuLqOyXkCDtkZzsi5zrkJjripQg7Luo7Yq466Gk67CUIOuCtOyXkOyEnCDspJHqsIQg7Jik66W47Kq9IOu4lOufreyXkCDtkZzsi5ztlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIE1BSU5fUklHSFQ6IFwibWFpbi1yaWdodFwiXG59O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG5jbGFzcyBSYW5nZUNvbnRyb2wgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcclxuICAgKlxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX29uSG9sZCA9ICh7XG4gICAgICBzcmNFdmVudCxcbiAgICAgIGlzVG91Y2hcbiAgICB9KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBiYm94ID0gdGhpcy5fYmJveDtcbiAgICAgIGlmICghYmJveCkgcmV0dXJuO1xuICAgICAgY29uc3QgeCA9IGlzVG91Y2ggPyBzcmNFdmVudC50b3VjaGVzWzBdLnBhZ2VYIDogc3JjRXZlbnQucGFnZVg7XG4gICAgICBjb25zdCBlbFggPSBiYm94LnggKyAoKF9hID0gd2luZG93LnNjcm9sbFgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5wYWdlWE9mZnNldCk7XG4gICAgICBjb25zdCBjbGFtZXBkWCA9IGNsYW1wKHgsIGVsWCwgZWxYICsgYmJveC53aWR0aCk7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IChjbGFtZXBkWCAtIGVsWCkgLyBiYm94LndpZHRoO1xuICAgICAgdGhpcy5fbW90aW9uLnJlc2V0KGNsYW1lcGRYKTtcbiAgICAgIHRoaXMudGh1bWJFbC5jbGFzc0xpc3QuYWRkKHRoaXMuX2ZpeGVkQ2xhc3MpO1xuICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLklOUFVUX1NUQVJULCBwcm9ncmVzcyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkNoYW5nZSA9ICh7XG4gICAgICBkZWx0YVxuICAgIH0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IG1vdGlvbiA9IHRoaXMuX21vdGlvbjtcbiAgICAgIGNvbnN0IGJib3ggPSB0aGlzLl9iYm94O1xuICAgICAgaWYgKCFiYm94KSByZXR1cm47XG4gICAgICBtb3Rpb24uc2V0TmV3RW5kQnlEZWx0YShkZWx0YS54KTtcbiAgICAgIG1vdGlvbi51cGRhdGUoMSk7XG4gICAgICBjb25zdCBlbFggPSBiYm94LnggKyAoKF9hID0gd2luZG93LnNjcm9sbFgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5wYWdlWE9mZnNldCk7XG4gICAgICBjb25zdCBjbGFtcGVkWCA9IGNsYW1wKG1vdGlvbi52YWwsIGVsWCwgZWxYICsgYmJveC53aWR0aCk7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IChjbGFtcGVkWCAtIGVsWCkgLyBiYm94LndpZHRoO1xuICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLkNIQU5HRSwgcHJvZ3Jlc3MpO1xuICAgIH07XG4gICAgdGhpcy5fb25SZWxlYXNlID0gKCkgPT4ge1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMuX2Jib3g7XG4gICAgICBpZiAoIWJib3gpIHJldHVybjtcbiAgICAgIHRoaXMudGh1bWJFbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2ZpeGVkQ2xhc3MpO1xuICAgICAgdGhpcy50cmlnZ2VyKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCk7XG4gICAgfTtcbiAgICBjb25zdCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChFTF9ESVYpO1xuICAgIGNvbnN0IHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChFTF9ESVYpO1xuICAgIGNvbnN0IHRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChFTF9ESVYpO1xuICAgIGNvbnN0IGZpbGxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoRUxfRElWKTtcbiAgICByb290LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRyYWNrLmFwcGVuZENoaWxkKGZpbGxlcik7XG4gICAgdHJhY2suYXBwZW5kQ2hpbGQodGh1bWIpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQodHJhY2spO1xuICAgIHRoaXMucm9vdEVsID0gcm9vdDtcbiAgICB0aGlzLnRyYWNrRWwgPSB0cmFjaztcbiAgICB0aGlzLnRodW1iRWwgPSB0aHVtYjtcbiAgICB0aGlzLmZpbGxlckVsID0gZmlsbGVyO1xuICAgIHRoaXMuX21vdXNlSW5wdXQgPSBuZXcgTW91c2VJbnB1dCgpO1xuICAgIHRoaXMuX3RvdWNoSW5wdXQgPSBuZXcgVG91Y2hJbnB1dCgpO1xuICAgIHRoaXMuX21vdGlvbiA9IG5ldyBNb3Rpb24oe1xuICAgICAgZHVyYXRpb246IDEsXG4gICAgICByYW5nZTogSU5GSU5JVEVfUkFOR0UsXG4gICAgICBlYXNpbmc6IHggPT4geFxuICAgIH0pO1xuICAgIHRoaXMuX2Jib3ggPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICB0aGlzLl9maXhlZENsYXNzID0gQ09OVFJPTF9CQVJfREVGQVVMVF9DTEFTUy5GSVhFRDtcbiAgfVxuICBpbml0KGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IG1vdXNlSW5wdXQgPSB0aGlzLl9tb3VzZUlucHV0O1xuICAgIGNvbnN0IHRvdWNoSW5wdXQgPSB0aGlzLl90b3VjaElucHV0O1xuICAgIHRoaXMucm9vdEVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLlJBTkdFX1JPT1QpO1xuICAgIHRoaXMudHJhY2tFbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5SQU5HRV9UUkFDSyk7XG4gICAgdGhpcy50aHVtYkVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLlJBTkdFX1RIVU1CKTtcbiAgICB0aGlzLmZpbGxlckVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLlJBTkdFX0ZJTExFUik7XG4gICAgdGhpcy5fZml4ZWRDbGFzcyA9IGNsYXNzTmFtZS5GSVhFRDtcbiAgICBtb3VzZUlucHV0Lm9uKENPTlRST0xfRVZFTlRTLklOUFVUX1NUQVJULCB0aGlzLl9vbkhvbGQpO1xuICAgIHRvdWNoSW5wdXQub24oQ09OVFJPTF9FVkVOVFMuSU5QVVRfU1RBUlQsIHRoaXMuX29uSG9sZCk7XG4gICAgbW91c2VJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdG91Y2hJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgbW91c2VJbnB1dC5vbihDT05UUk9MX0VWRU5UUy5DSEFOR0UsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB0b3VjaElucHV0Lm9uKENPTlRST0xfRVZFTlRTLkNIQU5HRSwgdGhpcy5fb25DaGFuZ2UpO1xuICAgIG1vdXNlSW5wdXQuZW5hYmxlKHRoaXMucm9vdEVsKTtcbiAgICB0b3VjaElucHV0LmVuYWJsZSh0aGlzLnJvb3RFbCk7XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IG1vdXNlSW5wdXQgPSB0aGlzLl9tb3VzZUlucHV0O1xuICAgIGNvbnN0IHRvdWNoSW5wdXQgPSB0aGlzLl90b3VjaElucHV0O1xuICAgIHRoaXMucm9vdEVsLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgdGhpcy50cmFja0VsLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgdGhpcy50aHVtYkVsLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgdGhpcy5maWxsZXJFbC5jbGFzc05hbWUgPSBcIlwiO1xuICAgIG1vdXNlSW5wdXQub2ZmKCk7XG4gICAgdG91Y2hJbnB1dC5vZmYoKTtcbiAgICBtb3VzZUlucHV0LmRpc2FibGUoKTtcbiAgICB0b3VjaElucHV0LmRpc2FibGUoKTtcbiAgfVxuICByZXNpemUoKSB7XG4gICAgdGhpcy5fYmJveCA9IHRoaXMudHJhY2tFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICB1cGRhdGVTdHlsZShwcm9ncmVzcykge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fYmJveC53aWR0aDtcbiAgICBjb25zdCBjbGFtcGVkUHJvZ3Jlc3MgPSBjbGFtcChwcm9ncmVzcywgMCwgMSk7XG4gICAgdGhpcy5maWxsZXJFbC5zdHlsZS53aWR0aCA9IGAke2NsYW1wZWRQcm9ncmVzcyAqIDEwMH0lYDtcbiAgICB0aGlzLnRodW1iRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtjbGFtcGVkUHJvZ3Jlc3MgKiB3aWR0aH1weClgO1xuICB9XG59XG5cbi8qKlxyXG4gKiBTaG93IHZpZGVvIHByb2dyZXNzIGJhci5cclxuICogQGtvIOu5hOuUlOyYpOydmCDtlITroZzqt7jroIjsiqQg67CU66W8IO2RnOyLnO2VqeuLiOuLpC5cclxuICogQGNhdGVnb3J5IFBsdWdpblxyXG4gKiBAZ3JvdXAgQ29udHJvbEJhclxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBQcm9ncmVzc0JhciBleHRlbmRzIENvbnRyb2xCYXJJdGVtIHtcbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlQ29udHJvbC5yb290RWw7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqIEBrbyDsg4jroZzsmrQg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMge0BrbyDsmLXshZjrk6R9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb3NpdGlvbiA9IENPTlRST0xfQkFSX0lURU1fUE9TSVRJT04uTUFJTl9UT1AsXG4gICAgb3JkZXIgPSA5OTk5XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb3JkZXJcbiAgICB9KTtcbiAgICB0aGlzLl9vblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3JhbmdlQ29udHJvbC5yZXNpemUoKTtcbiAgICB9O1xuICAgIHRoaXMuX29uVGltZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW87XG4gICAgICBpZiAoIXZpZGVvKSByZXR1cm47XG4gICAgICB0aGlzLl9jdXJyZW50VGltZSA9IHZpZGVvLnNvdXJjZS5jdXJyZW50VGltZTtcbiAgICAgIHRoaXMuX3JhbmdlQ29udHJvbC51cGRhdGVTdHlsZSh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuX2R1cmF0aW9uKTtcbiAgICB9O1xuICAgIHRoaXMuX29uRHVyYXRpb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgaWYgKCF2aWRlbykgcmV0dXJuO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSB2aWRlby5zb3VyY2UuZHVyYXRpb247XG4gICAgICB0aGlzLl9yYW5nZUNvbnRyb2wudXBkYXRlU3R5bGUodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLl9kdXJhdGlvbik7XG4gICAgfTtcbiAgICB0aGlzLl9vbkhvbGQgPSBwcm9ncmVzcyA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgY29uc3QgY29udHJvbEJhciA9IHRoaXMuX2NvbnRyb2xCYXI7XG4gICAgICBpZiAoIXZpZGVvIHx8ICFjb250cm9sQmFyKSByZXR1cm47XG4gICAgICBjb25zdCBwYXVzZWQgPSB2aWRlby5pc1BhdXNlZCgpO1xuICAgICAgdmlkZW8uc291cmNlLnBhdXNlKCk7XG4gICAgICBjb25zdCB0aW1lID0gdmlkZW8uc291cmNlLmR1cmF0aW9uICogcHJvZ3Jlc3M7XG4gICAgICB2aWRlby5zb3VyY2UuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgdmlkZW8uc291cmNlLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFZJREVPX1RJTUVfQ0hBTkdFX0VWRU5ULCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIHRpbWVcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgY29udHJvbEJhci5yb290RWwuY2xhc3NMaXN0LmFkZChjb250cm9sQmFyLmNsYXNzTmFtZS5GSVhFRCk7XG4gICAgICB0aGlzLl93YXNQYXVzZWQgPSAhdGhpcy5fcGxheVByb21pc2UgJiYgcGF1c2VkO1xuICAgIH07XG4gICAgdGhpcy5fb25Db250cm9sID0gcHJvZ3Jlc3MgPT4ge1xuICAgICAgY29uc3QgdmlkZW8gPSB0aGlzLl92aWRlbztcbiAgICAgIGlmICghdmlkZW8pIHJldHVybjtcbiAgICAgIGNvbnN0IHRpbWUgPSB2aWRlby5zb3VyY2UuZHVyYXRpb24gKiBwcm9ncmVzcztcbiAgICAgIHZpZGVvLnNvdXJjZS5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgICB2aWRlby5zb3VyY2UuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoVklERU9fVElNRV9DSEFOR0VfRVZFTlQsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdGltZVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfTtcbiAgICB0aGlzLl9vblJlbGVhc2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgY29uc3QgY29udHJvbEJhciA9IHRoaXMuX2NvbnRyb2xCYXI7XG4gICAgICBpZiAodmlkZW8gJiYgY29udHJvbEJhcikge1xuICAgICAgICBpZiAoIXRoaXMuX3dhc1BhdXNlZCAmJiAhdGhpcy5fcGxheVByb21pc2UpIHtcbiAgICAgICAgICB0aGlzLl9wbGF5UHJvbWlzZSA9IHZpZGVvLnNvdXJjZS5wbGF5KCkuY2F0Y2goKCkgPT4gdm9pZCAwKTtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgY2hhaW5lZFxuICAgICAgICAgIHRoaXMuX3BsYXlQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGxheVByb21pc2UgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xCYXIucm9vdEVsLmNsYXNzTGlzdC5yZW1vdmUoY29udHJvbEJhci5jbGFzc05hbWUuRklYRUQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl93YXNQYXVzZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgdGhpcy5fY29udHJvbEJhciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VDb250cm9sID0gbmV3IFJhbmdlQ29udHJvbCgpO1xuICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgICB0aGlzLl93YXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuX3BsYXlQcm9taXNlID0gbnVsbDtcbiAgfVxuICBpbml0KHZpZXdlciwgY29udHJvbEJhcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB2aWRlbyA9IChfYSA9IHZpZXdlci5tZXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VGV4dHVyZSgpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3QgcmFuZ2VDb250cm9sID0gdGhpcy5fcmFuZ2VDb250cm9sO1xuICAgIGNvbnN0IHVuYXZhaWxhYmxlQ2xhc3MgPSBjb250cm9sQmFyLmNsYXNzTmFtZS5VTkFWQUlMQUJMRTtcbiAgICBpZiAoIXZpZGVvIHx8ICF2aWRlby5pc1ZpZGVvKCkpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCh1bmF2YWlsYWJsZUNsYXNzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHVuYXZhaWxhYmxlQ2xhc3MpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjb250cm9sQmFyLmNsYXNzTmFtZS5QUk9HUkVTU19ST09UKTtcbiAgICB2aWV3ZXIub24oRVZFTlRTLlJFU0laRSwgdGhpcy5fb25SZXNpemUpO1xuICAgIHZpZGVvLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlZJREVPX1RJTUVfVVBEQVRFLCB0aGlzLl9vblRpbWVVcGRhdGUpO1xuICAgIHZpZGVvLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlZJREVPX0RVUkFUSU9OX0NIQU5HRSwgdGhpcy5fb25EdXJhdGlvbkNoYW5nZSk7XG4gICAgdmlkZW8uc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoVklERU9fVElNRV9DSEFOR0VfRVZFTlQsIHRoaXMuX29uVGltZVVwZGF0ZSk7XG4gICAgcmFuZ2VDb250cm9sLmluaXQoY29udHJvbEJhci5jbGFzc05hbWUpO1xuICAgIHJhbmdlQ29udHJvbC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgdGhpcy5fb25Ib2xkKTtcbiAgICByYW5nZUNvbnRyb2wub24oQ09OVFJPTF9FVkVOVFMuQ0hBTkdFLCB0aGlzLl9vbkNvbnRyb2wpO1xuICAgIHJhbmdlQ29udHJvbC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9FTkQsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5fdmlkZW8gPSB2aWRlbztcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IHZpZGVvLnNvdXJjZS5jdXJyZW50VGltZTtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHZpZGVvLnNvdXJjZS5kdXJhdGlvbjtcbiAgICB0aGlzLl9jb250cm9sQmFyID0gY29udHJvbEJhcjtcbiAgICByYW5nZUNvbnRyb2wudXBkYXRlU3R5bGUodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLl9kdXJhdGlvbik7XG4gIH1cbiAgZGVzdHJveSh2aWV3ZXIpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgIHZpZXdlci5vZmYoRVZFTlRTLlJFU0laRSwgdGhpcy5fb25SZXNpemUpO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fVElNRV9VUERBVEUsIHRoaXMuX29uVGltZVVwZGF0ZSk7XG4gICAgICB2aWRlby5zb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5WSURFT19EVVJBVElPTl9DSEFOR0UsIHRoaXMuX29uRHVyYXRpb25DaGFuZ2UpO1xuICAgICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVklERU9fVElNRV9DSEFOR0VfRVZFTlQsIHRoaXMuX29uVGltZVVwZGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuX3JhbmdlQ29udHJvbC5kZXN0cm95KCk7XG4gICAgdGhpcy5fdmlkZW8gPSBudWxsO1xuICAgIHRoaXMuX3BsYXlQcm9taXNlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcclxuICogU2hvdyB2aWRlbyBwbGF5IC8gcGF1c2UgYnV0dG9uLlxyXG4gKiBAa28g67mE65SU7JikIOyerOyDnSAvIOydvOyLnOygleyngCDrsoTtirzsnYQg7ZGc7Iuc7ZWp64uI64ukLlxyXG4gKiBAY2F0ZWdvcnkgUGx1Z2luXHJcbiAqIEBncm91cCBDb250cm9sQmFyXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cbmNsYXNzIFBsYXlCdXR0b24gZXh0ZW5kcyBDb250cm9sQmFySXRlbSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKiBAa28g7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHtAa28g7Ji17IWY65OkfVxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcG9zaXRpb24gPSBDT05UUk9MX0JBUl9JVEVNX1BPU0lUSU9OLk1BSU5fTEVGVCxcbiAgICBvcmRlciA9IDk5OTlcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9zaXRpb24sXG4gICAgICBvcmRlclxuICAgIH0pO1xuICAgIHRoaXMuX29uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgaWYgKCF2aWRlbykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICB2aWRlby5zb3VyY2UucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlkZW8uc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vblBsYXkgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRyb2xCYXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLl9jb250cm9sQmFyLmNsYXNzTmFtZTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuUEFVU0VfQlVUVE9OKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUuUExBWV9CVVRUT04pO1xuICAgICAgZWxlbWVudC50aXRsZSA9IFwiUGF1c2UgVmlkZW9cIjtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5fb25QYXVzZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29udHJvbEJhcikgcmV0dXJuO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuX2NvbnRyb2xCYXIuY2xhc3NOYW1lO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5QTEFZX0JVVFRPTik7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLlBBVVNFX0JVVFRPTik7XG4gICAgICBlbGVtZW50LnRpdGxlID0gXCJQbGF5IFZpZGVvXCI7XG4gICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChFTF9CVVRUT04pO1xuICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbnRyb2xCYXIgPSBudWxsO1xuICB9XG4gIGluaXQodmlld2VyLCBjb250cm9sQmFyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3QgdmlkZW8gPSAoX2EgPSB2aWV3ZXIubWVzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRleHR1cmUoKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBjb250cm9sQmFyLmNsYXNzTmFtZTtcbiAgICBjb25zdCB1bmF2YWlsYWJsZUNsYXNzID0gY2xhc3NOYW1lLlVOQVZBSUxBQkxFO1xuICAgIGlmICghdmlkZW8gfHwgIXZpZGVvLmlzVmlkZW8oKSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKHVuYXZhaWxhYmxlQ2xhc3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLkNPTlRST0xTX0JVVFRPTik7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHVuYXZhaWxhYmxlQ2xhc3MpO1xuICAgIGNvbnN0IHBhdXNlZCA9IHZpZGVvLmlzUGF1c2VkKCk7XG4gICAgdGhpcy5fdmlkZW8gPSB2aWRlbztcbiAgICB0aGlzLl9wYXVzZWQgPSBwYXVzZWQ7XG4gICAgdGhpcy5fY29udHJvbEJhciA9IGNvbnRyb2xCYXI7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgdGhpcy5fb25QYXVzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vblBsYXkoKTtcbiAgICB9XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLkNMSUNLLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB2aWRlby5zb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5WSURFT19QTEFZLCB0aGlzLl9vblBsYXkpO1xuICAgIHZpZGVvLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlZJREVPX1BBVVNFLCB0aGlzLl9vblBhdXNlKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW87XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoIXZpZGVvKSByZXR1cm47XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBcIlwiO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5DTElDSywgdGhpcy5fb25DbGljayk7XG4gICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fUExBWSwgdGhpcy5fb25QbGF5KTtcbiAgICB2aWRlby5zb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5WSURFT19QQVVTRSwgdGhpcy5fb25QYXVzZSk7XG4gICAgdGhpcy5fdmlkZW8gPSBudWxsO1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fY29udHJvbEJhciA9IG51bGw7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFNob3cgdmlkZW8gdm9sdW1lIGNvbnRyb2wuXHJcbiAqIEBrbyDruYTrlJTsmKQg67O866WoIOyhsOygiCDrsoTtirzsnYQg7ZGc7Iuc7ZWp64uI64ukLlxyXG4gKiBAY2F0ZWdvcnkgUGx1Z2luXHJcbiAqIEBncm91cCBDb250cm9sQmFyXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cbmNsYXNzIFZvbHVtZUNvbnRyb2wgZXh0ZW5kcyBDb250cm9sQmFySXRlbSB7XG4gIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yb290RWw7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqIEBrbyDsg4jroZzsmrQg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMge0BrbyDsmLXshZjrk6R9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb3NpdGlvbiA9IENPTlRST0xfQkFSX0lURU1fUE9TSVRJT04uTUFJTl9SSUdIVCxcbiAgICBvcmRlciA9IDk5OTlcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9zaXRpb24sXG4gICAgICBvcmRlclxuICAgIH0pO1xuICAgIHRoaXMuX29uUmVzaXplID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcmFuZ2VDb250cm9sLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5fdXBkYXRlRGlzcGxheSgpO1xuICAgIH07XG4gICAgdGhpcy5fb25DbGljayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW87XG4gICAgICBpZiAoIXZpZGVvIHx8IHRoaXMuX3Jvb3RFbC5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgdmlkZW8uc291cmNlLm11dGVkID0gIXZpZGVvLnNvdXJjZS5tdXRlZDtcbiAgICB9O1xuICAgIHRoaXMuX29uVm9sdW1lQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy5fYnV0dG9uRWw7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgY29uc3QgY29udHJvbEJhciA9IHRoaXMuX2NvbnRyb2xCYXI7XG4gICAgICBpZiAoIXZpZGVvIHx8ICFjb250cm9sQmFyKSByZXR1cm47XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBjb250cm9sQmFyLmNsYXNzTmFtZTtcbiAgICAgIGlmICh2aWRlby5zb3VyY2UubXV0ZWQgfHwgdmlkZW8uc291cmNlLnZvbHVtZSA9PT0gMCkge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuTVVURURfQlVUVE9OKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLlVOTVVURURfQlVUVE9OKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5VTk1VVEVEX0JVVFRPTik7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZS5NVVRFRF9CVVRUT04pO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlRGlzcGxheSgpO1xuICAgIH07XG4gICAgdGhpcy5fb25Ib2xkID0gcHJvZ3Jlc3MgPT4ge1xuICAgICAgY29uc3QgdmlkZW8gPSB0aGlzLl92aWRlbztcbiAgICAgIGNvbnN0IGNvbnRyb2xCYXIgPSB0aGlzLl9jb250cm9sQmFyO1xuICAgICAgaWYgKCF2aWRlbyB8fCAhY29udHJvbEJhcikgcmV0dXJuO1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gY29udHJvbEJhci5jbGFzc05hbWU7XG4gICAgICB2aWRlby5zb3VyY2Uudm9sdW1lID0gcHJvZ3Jlc3M7XG4gICAgICB0aGlzLl9yb290RWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuRklYRUQpO1xuICAgICAgY29udHJvbEJhci5jb250YWluZXJFbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5GSVhFRCk7XG4gICAgICB0aGlzLl91cGRhdGVEaXNwbGF5KCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHByb2dyZXNzID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW87XG4gICAgICBpZiAoIXZpZGVvKSByZXR1cm47XG4gICAgICB2aWRlby5zb3VyY2Uudm9sdW1lID0gcHJvZ3Jlc3M7XG4gICAgICBpZiAocHJvZ3Jlc3MgPiAwKSB7XG4gICAgICAgIHZpZGVvLnNvdXJjZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlkZW8uc291cmNlLm11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZURpc3BsYXkoKTtcbiAgICB9O1xuICAgIHRoaXMuX29uUmVsZWFzZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRyb2xCYXIgPSB0aGlzLl9jb250cm9sQmFyO1xuICAgICAgaWYgKCFjb250cm9sQmFyKSByZXR1cm47XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBjb250cm9sQmFyLmNsYXNzTmFtZTtcbiAgICAgIHRoaXMuX3Jvb3RFbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZS5GSVhFRCk7XG4gICAgICBjb250cm9sQmFyLmNvbnRhaW5lckVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLkZJWEVEKTtcbiAgICB9O1xuICAgIHRoaXMuX3VwZGF0ZURpc3BsYXkgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3RFbDtcbiAgICAgIGlmICghdmlkZW8pIHJldHVybjtcbiAgICAgIGlmICghdmlkZW8uaGFzQXVkaW8oKSkge1xuICAgICAgICByb290LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcm9vdC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgdm9sdW1lID0gdmlkZW8uc291cmNlLm11dGVkID8gMCA6IHZpZGVvLnNvdXJjZS52b2x1bWU7XG4gICAgICB0aGlzLl9yYW5nZUNvbnRyb2wudXBkYXRlU3R5bGUodm9sdW1lKTtcbiAgICB9O1xuICAgIHRoaXMuX2NvbnRyb2xCYXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlQ29udHJvbCA9IG5ldyBSYW5nZUNvbnRyb2woKTtcbiAgICB0aGlzLl9jcmVhdGVFbGVtZW50cygpO1xuICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgfVxuICBpbml0KHZpZXdlciwgY29udHJvbEJhcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB2aWRlbyA9IChfYSA9IHZpZXdlci5tZXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VGV4dHVyZSgpO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290RWw7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5fYnV0dG9uRWw7XG4gICAgY29uc3QgcmFuZ2VDb250cm9sID0gdGhpcy5fcmFuZ2VDb250cm9sO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNvbnRyb2xCYXIuY2xhc3NOYW1lO1xuICAgIGNvbnN0IHVuYXZhaWxhYmxlQ2xhc3MgPSBjbGFzc05hbWUuVU5BVkFJTEFCTEU7XG4gICAgaWYgKCF2aWRlbyB8fCAhdmlkZW8uaXNWaWRlbygpKSB7XG4gICAgICByb290LmNsYXNzTGlzdC5hZGQodW5hdmFpbGFibGVDbGFzcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvb3QuY2xhc3NMaXN0LnJlbW92ZSh1bmF2YWlsYWJsZUNsYXNzKTtcbiAgICByb290LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLkNPTlRST0xTX0JVVFRPTik7XG4gICAgcm9vdC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5WT0xVTUVfUk9PVCk7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLkNPTlRST0xTX0JVVFRPTik7XG4gICAgaWYgKHZpZGVvLnNvdXJjZS5tdXRlZCkge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLk1VVEVEX0JVVFRPTik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5VTk1VVEVEX0JVVFRPTik7XG4gICAgfVxuICAgIHZpZXdlci5vbihFVkVOVFMuUkVTSVpFLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuQ0xJQ0ssIHRoaXMuX29uQ2xpY2spO1xuICAgIHZpZGVvLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlZJREVPX1ZPTFVNRV9DSEFOR0UsIHRoaXMuX29uVm9sdW1lQ2hhbmdlKTtcbiAgICB2aWRlby5zb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5WSURFT19MT0FERURfREFUQSwgdGhpcy5fdXBkYXRlRGlzcGxheSk7XG4gICAgdmlkZW8uc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fQ0FOX1BMQVlUSFJPVUdILCB0aGlzLl91cGRhdGVEaXNwbGF5KTtcbiAgICByYW5nZUNvbnRyb2wuaW5pdChjbGFzc05hbWUpO1xuICAgIHJhbmdlQ29udHJvbC5vbihDT05UUk9MX0VWRU5UUy5JTlBVVF9TVEFSVCwgdGhpcy5fb25Ib2xkKTtcbiAgICByYW5nZUNvbnRyb2wub24oQ09OVFJPTF9FVkVOVFMuQ0hBTkdFLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgcmFuZ2VDb250cm9sLm9uKENPTlRST0xfRVZFTlRTLklOUFVUX0VORCwgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLl9jb250cm9sQmFyID0gY29udHJvbEJhcjtcbiAgICB0aGlzLl92aWRlbyA9IHZpZGVvO1xuICAgIHRoaXMuX3VwZGF0ZURpc3BsYXkoKTtcbiAgfVxuICBkZXN0cm95KHZpZXdlcikge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW87XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5fYnV0dG9uRWw7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3RFbDtcbiAgICByb290LmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgdmlld2VyLm9mZihFVkVOVFMuUkVTSVpFLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuQ0xJQ0ssIHRoaXMuX29uQ2xpY2spO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fVk9MVU1FX0NIQU5HRSwgdGhpcy5fb25Wb2x1bWVDaGFuZ2UpO1xuICAgICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fTE9BREVEX0RBVEEsIHRoaXMuX3VwZGF0ZURpc3BsYXkpO1xuICAgICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fQ0FOX1BMQVlUSFJPVUdILCB0aGlzLl91cGRhdGVEaXNwbGF5KTtcbiAgICB9XG4gICAgdGhpcy5fY29udHJvbEJhciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VDb250cm9sLmRlc3Ryb3koKTtcbiAgICB0aGlzLl92aWRlbyA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEVMX0JVVFRPTik7XG4gICAgY29uc3QgYnV0dG9uRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEVMX0RJVik7XG4gICAgcm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZUNvbnRyb2wucm9vdEVsKTtcbiAgICByb290LmFwcGVuZENoaWxkKGJ1dHRvbkVsKTtcbiAgICByb290LnRpdGxlID0gXCJUb2dnbGUgTXV0ZVwiO1xuICAgIHRoaXMuX3Jvb3RFbCA9IHJvb3Q7XG4gICAgdGhpcy5fYnV0dG9uRWwgPSBidXR0b25FbDtcbiAgfVxufVxuXG4vKipcclxuICogU2hvdyBmdWxsc2NyZWVuIGVudGVyIC8gZXhpdCBidXR0b24uXHJcbiAqIEBrbyDtkoDsiqTtgazrprAg7KeE7J6FIC8g7ZW07KCcIOuyhO2KvOydhCDtkZzsi5ztlanri4jri6QuXHJcbiAqIEBjYXRlZ29yeSBQbHVnaW5cclxuICogQGdyb3VwIENvbnRyb2xCYXJcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgRnVsbHNjcmVlbkJ1dHRvbiBleHRlbmRzIENvbnRyb2xCYXJJdGVtIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqIEBrbyDsg4jroZzsmrQg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMge0BrbyDsmLXshZjrk6R9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb3NpdGlvbiA9IENPTlRST0xfQkFSX0lURU1fUE9TSVRJT04uTUFJTl9SSUdIVCxcbiAgICBvcmRlciA9IDk5OTlcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9zaXRpb24sXG4gICAgICBvcmRlclxuICAgIH0pO1xuICAgIHRoaXMuX29uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXRFbDtcbiAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG4gICAgICBpZiAoaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgICAgdGhpcy5fZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RGdWxsc2NyZWVuKHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgY29uc3QgY29udHJvbEJhciA9IHRoaXMuX2NvbnRyb2xCYXI7XG4gICAgICBpZiAoIWNvbnRyb2xCYXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNvbnRyb2xCYXIuY2xhc3NOYW1lO1xuICAgICAgaWYgKGlzRnVsbHNjcmVlbigpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuRlVMTFNDUkVFTl9FWElUX0JVVFRPTik7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUuRlVMTFNDUkVFTl9CVVRUT04pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5GVUxMU0NSRUVOX0JVVFRPTik7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUuRlVMTFNDUkVFTl9FWElUX0JVVFRPTik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEVMX0JVVFRPTik7XG4gICAgdGhpcy5lbGVtZW50LnRpdGxlID0gXCJUb2dnbGUgRnVsbHNjcmVlblwiO1xuICAgIHRoaXMuX2NvbnRyb2xCYXIgPSBudWxsO1xuICAgIHRoaXMuX3RhcmdldEVsID0gbnVsbDtcbiAgfVxuICBpbml0KHZpZXdlciwgY29udHJvbEJhcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gY29udHJvbEJhci5jbGFzc05hbWU7XG4gICAgaWYgKCF0aGlzLl9mdWxsc2NyZWVuQXZhaWxhYmxlKCkpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuVU5BVkFJTEFCTEUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLkNPTlRST0xTX0JVVFRPTik7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZS5VTkFWQUlMQUJMRSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLkNMSUNLLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9hZGRGdWxsc2NyZWVuSGFuZGxlcnMoKTtcbiAgICBpZiAoaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuRlVMTFNDUkVFTl9FWElUX0JVVFRPTik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuRlVMTFNDUkVFTl9CVVRUT04pO1xuICAgIH1cbiAgICB0aGlzLl9jb250cm9sQmFyID0gY29udHJvbEJhcjtcbiAgICB0aGlzLl90YXJnZXRFbCA9IHZpZXdlci5yb290RWw7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJcIjtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuQ0xJQ0ssIHRoaXMuX29uQ2xpY2spO1xuICAgIHRoaXMuX3JlbW92ZUZ1bGxzY3JlZW5IYW5kbGVycygpO1xuICAgIHRoaXMuX2NvbnRyb2xCYXIgPSBudWxsO1xuICAgIHRoaXMuX3RhcmdldEVsID0gbnVsbDtcbiAgfVxuICBfZnVsbHNjcmVlbkF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gRlVMTFNDUkVFTl9SRVFVRVNULnNvbWUoa2V5ID0+ICEhZG9jdW1lbnRba2V5XSk7XG4gIH1cbiAgX3JlcXVlc3RGdWxsc2NyZWVuKGVsKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgRlVMTFNDUkVFTl9SRVFVRVNUKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gZWxba2V5XTtcbiAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgIHJlcXVlc3QuY2FsbChlbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2V4aXRGdWxsc2NyZWVuKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIEZVTExTQ1JFRU5fRVhJVCkge1xuICAgICAgY29uc3QgZXhpdCA9IGRvY3VtZW50W2tleV07XG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBleGl0LmNhbGwoZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9hZGRGdWxsc2NyZWVuSGFuZGxlcnMoKSB7XG4gICAgRlVMTFNDUkVFTl9DSEFOR0UuZm9yRWFjaChldnROYW1lID0+IHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICB9KTtcbiAgfVxuICBfcmVtb3ZlRnVsbHNjcmVlbkhhbmRsZXJzKCkge1xuICAgIEZVTExTQ1JFRU5fQ0hBTkdFLmZvckVhY2goZXZ0TmFtZSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFNob3cgdmlkZW8gY3VycmVudCAvIHRvdGFsIHRpbWUuXHJcbiAqIEBrbyDruYTrlJTsmKTsnZgg7ZiE7J6sIC8g7LSdIOyerOyDneyLnOqwhOydhCDtkZzsi5ztlanri4jri6QuXHJcbiAqIEBjYXRlZ29yeSBQbHVnaW5cclxuICogQGdyb3VwIENvbnRyb2xCYXJcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgVmlkZW9UaW1lIGV4dGVuZHMgQ29udHJvbEJhckl0ZW0ge1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICogQGtvIOyDiOuhnOyatCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvc2l0aW9uID0gQ09OVFJPTF9CQVJfSVRFTV9QT1NJVElPTi5NQUlOX0xFRlQsXG4gICAgb3JkZXIgPSA5OTk5XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb3JkZXJcbiAgICB9KTtcbiAgICB0aGlzLl9vblRpbWVVcGRhdGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IHRoaXMuX3ZpZGVvO1xuICAgICAgaWYgKCF2aWRlbykgcmV0dXJuO1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSB2aWRlby5zb3VyY2UuY3VycmVudFRpbWU7XG4gICAgICB0aGlzLl91cGRhdGVEaXNwbGF5KCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkR1cmF0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgY29uc3QgdmlkZW8gPSB0aGlzLl92aWRlbztcbiAgICAgIGlmICghdmlkZW8pIHJldHVybjtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gdmlkZW8uc291cmNlLmR1cmF0aW9uO1xuICAgICAgdGhpcy5fdXBkYXRlRGlzcGxheSgpO1xuICAgIH07XG4gICAgdGhpcy5fb25DdXN0b21UaW1lQ2hhbmdlID0gZXZ0ID0+IHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gZXZ0LmRldGFpbC50aW1lO1xuICAgICAgdGhpcy5fdXBkYXRlRGlzcGxheSgpO1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChFTF9ESVYpO1xuICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG4gIGluaXQodmlld2VyLCBjb250cm9sQmFyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHZpZGVvID0gKF9hID0gdmlld2VyLm1lc2gpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUZXh0dXJlKCk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBjb250cm9sQmFyLmNsYXNzTmFtZTtcbiAgICBpZiAoIXZpZGVvIHx8ICF2aWRlby5pc1ZpZGVvKCkpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuVU5BVkFJTEFCTEUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLlZJREVPX1RJTUVfRElTUExBWSk7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZS5VTkFWQUlMQUJMRSk7XG4gICAgdmlkZW8uc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fVElNRV9VUERBVEUsIHRoaXMuX29uVGltZVVwZGF0ZSk7XG4gICAgdmlkZW8uc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fRFVSQVRJT05fQ0hBTkdFLCB0aGlzLl9vbkR1cmF0aW9uQ2hhbmdlKTtcbiAgICB2aWRlby5zb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihWSURFT19USU1FX0NIQU5HRV9FVkVOVCwgdGhpcy5fb25DdXN0b21UaW1lQ2hhbmdlKTtcbiAgICB0aGlzLl92aWRlbyA9IHZpZGVvO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdmlkZW8uc291cmNlLmN1cnJlbnRUaW1lO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdmlkZW8uc291cmNlLmR1cmF0aW9uO1xuICAgIHRoaXMuX3VwZGF0ZURpc3BsYXkoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5fdmlkZW87XG4gICAgaWYgKCF2aWRlbykgcmV0dXJuO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcIlwiO1xuICAgIHZpZGVvLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLlZJREVPX1RJTUVfVVBEQVRFLCB0aGlzLl9vblRpbWVVcGRhdGUpO1xuICAgIHZpZGVvLnNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLlZJREVPX0RVUkFUSU9OX0NIQU5HRSwgdGhpcy5fb25EdXJhdGlvbkNoYW5nZSk7XG4gICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVklERU9fVElNRV9DSEFOR0VfRVZFTlQsIHRoaXMuX29uQ3VzdG9tVGltZUNoYW5nZSk7XG4gICAgdGhpcy5fdmlkZW8gPSBudWxsO1xuICB9XG4gIF91cGRhdGVEaXNwbGF5KCkge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9jdXJyZW50VGltZTtcbiAgICBjb25zdCB0aW1lTWludXRlID0gTWF0aC5mbG9vcih0aW1lIC8gNjApO1xuICAgIGNvbnN0IHRpbWVTZWNvbmRzID0gTWF0aC5mbG9vcih0aW1lIC0gdGltZU1pbnV0ZSAqIDYwKTtcbiAgICBjb25zdCB0aW1lU2Vjb25kc0Zvcm1hdHRlZCA9IHRpbWVTZWNvbmRzIDwgMTAgPyBgMCR7dGltZVNlY29uZHN9YCA6IHRpbWVTZWNvbmRzO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgZHVyYXRpb25NaW51dGUgPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gNjApO1xuICAgIGNvbnN0IGR1cmF0aW9uU2Vjb25kcyA9IE1hdGguZmxvb3IoZHVyYXRpb24gLSBkdXJhdGlvbk1pbnV0ZSAqIDYwKTtcbiAgICBjb25zdCBkdXJhdGlvblNlY29uZHNGb3JtYXR0ZWQgPSBkdXJhdGlvblNlY29uZHMgPCAxMCA/IGAwJHtkdXJhdGlvblNlY29uZHN9YCA6IGR1cmF0aW9uU2Vjb25kcztcbiAgICB0aGlzLmVsZW1lbnQuaW5uZXJUZXh0ID0gYCR7dGltZU1pbnV0ZX06JHt0aW1lU2Vjb25kc0Zvcm1hdHRlZH0gLyAke2R1cmF0aW9uTWludXRlfToke2R1cmF0aW9uU2Vjb25kc0Zvcm1hdHRlZH1gO1xuICB9XG59XG5cbi8qKlxyXG4gKiBTaG93IGNhbWVyYSBkaXJlY3Rpb24vZm92IGluZGljYXRvci5cclxuICogQGtvIOy5tOuplOudvOqwgCDtlqXtlZjripQg67Cp7ZalIOuwjyBGT1brpbwg7ZGc7Iuc7ZWp64uI64ukLlxyXG4gKiBAY2F0ZWdvcnkgUGx1Z2luXHJcbiAqIEBncm91cCBDb250cm9sQmFyXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cbmNsYXNzIFBpZVZpZXcgZXh0ZW5kcyBDb250cm9sQmFySXRlbSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKiBAa28g7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHtAa28g7Ji17IWY65OkfVxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcmVzZXRDYW1lcmEgPSB0cnVlLFxuICAgIHBvc2l0aW9uID0gQ09OVFJPTF9CQVJfSVRFTV9QT1NJVElPTi5UT1BfUklHSFQsXG4gICAgb3JkZXIgPSA5OTk5XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb3JkZXJcbiAgICB9KTtcbiAgICB0aGlzLl9vbkNsaWNrID0gKCkgPT4ge1xuICAgICAgY29uc3Qgdmlld2VyID0gdGhpcy5fdmlld2VyO1xuICAgICAgY29uc3QgcmVzZXRDYW1lcmEgPSB0aGlzLnJlc2V0Q2FtZXJhO1xuICAgICAgaWYgKCF2aWV3ZXIgfHwgIXJlc2V0Q2FtZXJhKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIHlhdyA9IHZpZXdlci5pbml0aWFsWWF3LFxuICAgICAgICBwaXRjaCA9IHZpZXdlci5pbml0aWFsUGl0Y2gsXG4gICAgICAgIHpvb20gPSB2aWV3ZXIuaW5pdGlhbFpvb20sXG4gICAgICAgIGR1cmF0aW9uID0gNTAwXG4gICAgICB9ID0gZ2V0T2JqZWN0T3B0aW9uKHJlc2V0Q2FtZXJhKTtcbiAgICAgIHZpZXdlci5jYW1lcmEuYW5pbWF0ZVRvKHtcbiAgICAgICAgeWF3LFxuICAgICAgICBwaXRjaCxcbiAgICAgICAgem9vbSxcbiAgICAgICAgZHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5fdXBkYXRlUGllID0gKHtcbiAgICAgIHRhcmdldDogdmlld2VyXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcGllUGF0aCA9IHRoaXMuX3BpZVBhdGhFbDtcbiAgICAgIGNvbnN0IHJhbmdlQ2lyY2xlID0gdGhpcy5fcmFuZ2VDaXJjbGVFbDtcbiAgICAgIGNvbnN0IGNhbWVyYSA9IHZpZXdlci5jYW1lcmE7XG4gICAgICBjb25zdCBmb3YgPSBjYW1lcmEuZ2V0SG9yaXpvbnRhbEZvdigpO1xuICAgICAgY29uc3QgeWF3UmFuZ2UgPSBjYW1lcmEuZ2V0WWF3UmFuZ2UoY2FtZXJhLnpvb20pO1xuICAgICAgY29uc3QgaGFsZkZvdiA9IGZvdiAqIDAuNTtcbiAgICAgIGNvbnN0IHBpZVJhZGl1cyA9IDI0ICogTWF0aC5QSTtcbiAgICAgIGNvbnN0IHBpZURlZyA9IHBpZVJhZGl1cyAqIGZvdiAvIDM2MDtcbiAgICAgIGNvbnN0IHBpZU9mZnNldCA9IHBpZVJhZGl1cyAqIChjYW1lcmEueWF3ICsgaGFsZkZvdiArIDkwKSAvIDM2MDtcbiAgICAgIHBpZVBhdGguc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBgJHtwaWVEZWd9ICR7cGllUmFkaXVzIC0gcGllRGVnfWApO1xuICAgICAgcGllUGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaG9mZnNldFwiLCBgJHtwaWVPZmZzZXR9YCk7XG4gICAgICBpZiAoaXNGaW5pdGUoeWF3UmFuZ2UubWluKSAmJiBpc0Zpbml0ZSh5YXdSYW5nZS5tYXgpKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IDQ1ICogTWF0aC5QSTsgLy8gMiAqIFBJICogclxuICAgICAgICBjb25zdCBtaW4gPSAoY2lyY3VsYXRlKHlhd1JhbmdlLm1pbiwgLTE4MCwgMTgwKSAtIGhhbGZGb3YpIC8gMzYwO1xuICAgICAgICBjb25zdCBtYXggPSAoY2lyY3VsYXRlKHlhd1JhbmdlLm1heCwgLTE4MCwgMTgwKSArIGhhbGZGb3YpIC8gMzYwO1xuICAgICAgICBjb25zdCByYW5nZURpZmYgPSByYWRpdXMgKiBNYXRoLmFicyhtYXggLSBtaW4pO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAtcmFkaXVzICogKG1pbiAtIDAuMjUpO1xuICAgICAgICByYW5nZUNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGAke3JhbmdlRGlmZn0gJHtyYWRpdXMgLSByYW5nZURpZmZ9YCk7XG4gICAgICAgIHJhbmdlQ2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNob2Zmc2V0XCIsIGAke29mZnNldH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlQ2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCJcIik7XG4gICAgICAgIHJhbmdlQ2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNob2Zmc2V0XCIsIFwiXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChFTF9ESVYpO1xuICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IFwiUmVzZXQgdmlld1wiO1xuICAgIHRoaXMucmVzZXRDYW1lcmEgPSByZXNldENhbWVyYTtcbiAgICB0aGlzLl9jcmVhdGVQaWVFbGVtZW50cygpO1xuICAgIHRoaXMuX3ZpZXdlciA9IG51bGw7XG4gIH1cbiAgaW5pdCh2aWV3ZXIsIGNvbnRyb2xCYXIpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmICghdmlld2VyLmluaXRpYWxpemVkKSB7XG4gICAgICB2aWV3ZXIub25jZShFVkVOVFMuUkVBRFksIHRoaXMuX3VwZGF0ZVBpZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBpZSh7XG4gICAgICAgIHRhcmdldDogdmlld2VyXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgcm9vdENsYXNzID0gY29udHJvbEJhci5jbGFzc05hbWUuUElFVklFV19ST09UO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChyb290Q2xhc3MpO1xuICAgIGlmICh0aGlzLnJlc2V0Q2FtZXJhKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuQ0xJQ0ssIHRoaXMuX29uQ2xpY2spO1xuICAgIH1cbiAgICB2aWV3ZXIub24oRVZFTlRTLlZJRVdfQ0hBTkdFLCB0aGlzLl91cGRhdGVQaWUpO1xuICAgIHRoaXMuX3ZpZXdlciA9IHZpZXdlcjtcbiAgfVxuICBkZXN0cm95KHZpZXdlcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLkNMSUNLLCB0aGlzLl9vbkNsaWNrKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgdmlld2VyLm9mZihFVkVOVFMuUkVBRFksIHRoaXMuX3VwZGF0ZVBpZSk7XG4gICAgdmlld2VyLm9mZihFVkVOVFMuVklFV19DSEFOR0UsIHRoaXMuX3VwZGF0ZVBpZSk7XG4gICAgdGhpcy5fdmlld2VyID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlUGllRWxlbWVudHMoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuZWxlbWVudDtcbiAgICBjb25zdCBwaWVTVkcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgXCJzdmdcIik7XG4gICAgcGllU1ZHLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgNDggNDhcIik7XG4gICAgcGllU1ZHLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICBwaWVTVkcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcbiAgICBjb25zdCBwaWVQYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OQU1FU1BBQ0UsIFwiY2lyY2xlXCIpO1xuICAgIHBpZVBhdGguc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpO1xuICAgIHBpZVBhdGguc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHBpZVBhdGguc2V0QXR0cmlidXRlKFwiY3hcIiwgXCIyNFwiKTtcbiAgICBwaWVQYXRoLnNldEF0dHJpYnV0ZShcImN5XCIsIFwiMjRcIik7XG4gICAgcGllUGF0aC5zZXRBdHRyaWJ1dGUoXCJyXCIsIFwiMTJcIik7XG4gICAgcGllUGF0aC5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIyNFwiKTtcbiAgICBwaWVTVkcuYXBwZW5kQ2hpbGQocGllUGF0aCk7XG4gICAgY29uc3QgcmFuZ2VDaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgXCJjaXJjbGVcIik7XG4gICAgcmFuZ2VDaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpO1xuICAgIHJhbmdlQ2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICByYW5nZUNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCBcIjI0XCIpO1xuICAgIHJhbmdlQ2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIFwiMjRcIik7XG4gICAgcmFuZ2VDaXJjbGUuc2V0QXR0cmlidXRlKFwiclwiLCBcIjIyLjVcIik7XG4gICAgcmFuZ2VDaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiM1wiKTtcbiAgICBwaWVTVkcuYXBwZW5kQ2hpbGQocmFuZ2VDaXJjbGUpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQocGllU1ZHKTtcbiAgICB0aGlzLl9waWVQYXRoRWwgPSBwaWVQYXRoO1xuICAgIHRoaXMuX3JhbmdlQ2lyY2xlRWwgPSByYW5nZUNpcmNsZTtcbiAgfVxufVxuXG4vKipcclxuICogU2hvdyBWUiBlbnRlciBidXR0b24uXHJcbiAqIEBrbyBWUiDsp4TsnoUg67KE7Yq87J2EIO2RnOyLnO2VqeuLiOuLpC5cclxuICogQGNhdGVnb3J5IFBsdWdpblxyXG4gKiBAZ3JvdXAgQ29udHJvbEJhclxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBWUkJ1dHRvbiBleHRlbmRzIENvbnRyb2xCYXJJdGVtIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqIEBrbyDsg4jroZzsmrQg7J247Iqk7YS07Iqk66W8IOyDneyEse2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMge0BrbyDsmLXshZjrk6R9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwb3NpdGlvbiA9IENPTlRST0xfQkFSX0lURU1fUE9TSVRJT04uTUFJTl9SSUdIVCxcbiAgICBvcmRlciA9IDk5OTlcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9zaXRpb24sXG4gICAgICBvcmRlclxuICAgIH0pO1xuICAgIHRoaXMuX29uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCB2aWV3ZXIgPSB0aGlzLl92aWV3ZXI7XG4gICAgICBpZiAoIXZpZXdlcikgcmV0dXJuO1xuICAgICAgdmlld2VyLnZyLmVudGVyKCk7XG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KEVMX0JVVFRPTik7XG4gICAgdGhpcy5lbGVtZW50LnRpdGxlID0gXCJFbnRlciBWUlwiO1xuICAgIHRoaXMuX3ZpZXdlciA9IG51bGw7XG4gIH1cbiAgaW5pdCh2aWV3ZXIsIGNvbnRyb2xCYXIpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNvbnRyb2xCYXIuY2xhc3NOYW1lO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuVU5BVkFJTEFCTEUpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuVlJfQlVUVE9OKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lLkNPTlRST0xTX0JVVFRPTik7XG4gICAgdmlld2VyLnZyLmlzQXZhaWxhYmxlKCkudGhlbihhdmFpbGFibGUgPT4ge1xuICAgICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLlVOQVZBSUxBQkxFKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuQ0xJQ0ssIHRoaXMuX29uQ2xpY2spO1xuICAgIHRoaXMuX3ZpZXdlciA9IHZpZXdlcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBcIlwiO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5DTElDSywgdGhpcy5fb25DbGljayk7XG4gICAgdGhpcy5fdmlld2VyID0gbnVsbDtcbiAgfVxufVxuXG4vKipcclxuICogU2hvdyBneXJvc2NvcGUgY29udHJvbCBlbmFibGUgLyBkaXNhYmxlIGJ1dHRvblxyXG4gKiBAa28g7J6Q7J2066Gc7Iqk7L2U7ZSEIOy7qO2KuOuhpCDtmZzshLHtmZQgLyDruYTtmZzshLHtmZQg67KE7Yq87J2EIO2RnOyLnO2VqeuLiOuLpC5cclxuICogQGNhdGVnb3J5IFBsdWdpblxyXG4gKiBAZ3JvdXAgQ29udHJvbEJhclxyXG4gKiBAc2luY2UgNC4wLjBcclxuICovXG5jbGFzcyBHeXJvQnV0dG9uIGV4dGVuZHMgQ29udHJvbEJhckl0ZW0ge1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICogQGtvIOyDiOuhnOyatCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvc2l0aW9uID0gQ09OVFJPTF9CQVJfSVRFTV9QT1NJVElPTi5NQUlOX1JJR0hULFxuICAgIG9yZGVyID0gOTk5OVxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBwb3NpdGlvbixcbiAgICAgIG9yZGVyXG4gICAgfSk7XG4gICAgdGhpcy5fb25DbGljayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHZpZXdlciA9IHRoaXMuX3ZpZXdlcjtcbiAgICAgIGNvbnN0IGNvbnRyb2xCYXIgPSB0aGlzLl9jb250cm9sQmFyO1xuICAgICAgaWYgKCF2aWV3ZXIgfHwgIWNvbnRyb2xCYXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGd5cm9Db250cm9sID0gdmlld2VyLmNvbnRyb2wuZ3lybztcbiAgICAgIGlmIChneXJvQ29udHJvbC5lbmFibGVkKSB7XG4gICAgICAgIGd5cm9Db250cm9sLmRpc2FibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEd5cm9Db250cm9sLnJlcXVlc3RTZW5zb3JQZXJtaXNzaW9uKCkudGhlbihhdmFpbGFibGUgPT4ge1xuICAgICAgICAgIGlmIChhdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGd5cm9Db250cm9sLmVuYWJsZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChjb250cm9sQmFyLmNsYXNzTmFtZS5VTkFWQUlMQUJMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3VwZGF0ZVN0eWxlID0gKCkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIGNvbnN0IHZpZXdlciA9IHRoaXMuX3ZpZXdlcjtcbiAgICAgIGNvbnN0IGNvbnRyb2xCYXIgPSB0aGlzLl9jb250cm9sQmFyO1xuICAgICAgaWYgKCF2aWV3ZXIgfHwgIWNvbnRyb2xCYXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGd5cm9Db250cm9sID0gdmlld2VyLmNvbnRyb2wuZ3lybztcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNvbnRyb2xCYXIuY2xhc3NOYW1lO1xuICAgICAgaWYgKGd5cm9Db250cm9sLmVuYWJsZWQpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5HWVJPX0VOQUJMRUQpO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lLkdZUk9fRElTQUJMRUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5HWVJPX0RJU0FCTEVEKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZS5HWVJPX0VOQUJMRUQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChFTF9ESVYpO1xuICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IFwiVG9nZ2xlIGd5cm9zY29wZSBjb250cm9sXCI7XG4gIH1cbiAgaW5pdCh2aWV3ZXIsIGNvbnRyb2xCYXIpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNvbnRyb2xCYXIuY2xhc3NOYW1lO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5DTElDSywgdGhpcy5fb25DbGljayk7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5DT05UUk9MU19CVVRUT04pO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuVU5BVkFJTEFCTEUpO1xuICAgIGNvbnN0IGVuYWJsZUJ1dHRvbiA9ICgpID0+IHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUuVU5BVkFJTEFCTEUpO1xuICAgICAgdmlld2VyLmNvbnRyb2wuZ3lyby5vbihDT05UUk9MX0VWRU5UUy5FTkFCTEUsIHRoaXMuX3VwZGF0ZVN0eWxlKTtcbiAgICAgIHZpZXdlci5jb250cm9sLmd5cm8ub24oQ09OVFJPTF9FVkVOVFMuRElTQUJMRSwgdGhpcy5fdXBkYXRlU3R5bGUpO1xuICAgIH07XG4gICAgaWYgKHNlbnNvckNhbkJlRW5hYmxlZElPUygpKSB7XG4gICAgICBlbmFibGVCdXR0b24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgR3lyb0NvbnRyb2wuaXNBdmFpbGFibGUoKS50aGVuKGF2YWlsYWJsZSA9PiB7XG4gICAgICAgIGlmICghYXZhaWxhYmxlKSByZXR1cm47XG4gICAgICAgIGVuYWJsZUJ1dHRvbigpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2NvbnRyb2xCYXIgPSBjb250cm9sQmFyO1xuICAgIHRoaXMuX3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLl91cGRhdGVTdHlsZSgpO1xuICB9XG4gIGRlc3Ryb3kodmlld2VyKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICB2aWV3ZXIuY29udHJvbC5neXJvLm9mZihDT05UUk9MX0VWRU5UUy5FTkFCTEUsIHRoaXMuX3VwZGF0ZVN0eWxlKTtcbiAgICB2aWV3ZXIuY29udHJvbC5neXJvLm9mZihDT05UUk9MX0VWRU5UUy5ESVNBQkxFLCB0aGlzLl91cGRhdGVTdHlsZSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLkNMSUNLLCB0aGlzLl9vbkNsaWNrKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgdGhpcy5fY29udHJvbEJhciA9IG51bGw7XG4gICAgdGhpcy5fdmlld2VyID0gbnVsbDtcbiAgfVxufVxuXG5jbGFzcyBBdXRvSGlkZSB7XG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RhcmdldEVsO1xuICB9XG4gIGdldCBoaWRkZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xCYXIuY29udGFpbmVyRWwuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX2hpZGRlbkNsYXNzKTtcbiAgfVxuICBnZXQgX2hpZGRlbkNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sQmFyLmNsYXNzTmFtZS5ISURERU47XG4gIH1cbiAgZ2V0IF9maXhlZENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sQmFyLmNsYXNzTmFtZS5GSVhFRDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250cm9sQmFyLCB7XG4gICAgaW5pdGlhbERlbGF5ID0gMzAwMCxcbiAgICBkZWxheSA9IDAsXG4gICAgaWRsZURlbGF5OiBhY3RpdmF0aW9uRGVsYXkgPSAzMDAwXG4gIH0pIHtcbiAgICB0aGlzLl9vbk1vdXNlRW50ZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc0N1cnNvckluc2lkZSA9IHRydWU7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzQ3Vyc29ySW5zaWRlID0gZmFsc2U7XG4gICAgICB0aGlzLl9oaWRlQWZ0ZXJEZWxheSgpO1xuICAgIH07XG4gICAgdGhpcy5fb25Nb3VzZU1vdmUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzRnVsbHNjcmVlbikgcmV0dXJuO1xuICAgICAgdGhpcy5zaG93VGVtcG9yYWxpeSgpO1xuICAgIH07XG4gICAgdGhpcy5fb25Ib2xkID0gZXZ0ID0+IHtcbiAgICAgIHRoaXMuX2lzR3JhYmJpbmcgPSB0cnVlO1xuICAgICAgaWYgKGV2dC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgIHRoaXMuX2lzQ3Vyc29ySW5zaWRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX1VQLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfTtcbiAgICB0aGlzLl9vblJlbGVhc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc0dyYWJiaW5nID0gZmFsc2U7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5NT1VTRV9VUCwgdGhpcy5fb25SZWxlYXNlKTtcbiAgICAgIHRoaXMuX2hpZGVBZnRlckRlbGF5KCk7XG4gICAgfTtcbiAgICB0aGlzLl9vblZpZGVvUGxheSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl90YXJnZXRFbDtcbiAgICAgIGlmICghcm9vdCkgcmV0dXJuO1xuICAgICAgdGhpcy5fY29udHJvbEJhci5jb250YWluZXJFbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2ZpeGVkQ2xhc3MpO1xuICAgIH07XG4gICAgdGhpcy5fb25WaWRlb1BhdXNlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3RhcmdldEVsO1xuICAgICAgaWYgKCFyb290KSByZXR1cm47XG4gICAgICB0aGlzLl9jb250cm9sQmFyLmNvbnRhaW5lckVsLmNsYXNzTGlzdC5hZGQodGhpcy5fZml4ZWRDbGFzcyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkZ1bGxzY3JlZW5DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc0Z1bGxzY3JlZW4gPSBpc0Z1bGxzY3JlZW4oKTtcbiAgICAgIGlmICh0aGlzLl9pc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgdGhpcy5faGlkZUFmdGVyRGVsYXkoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2NvbnRyb2xCYXIgPSBjb250cm9sQmFyO1xuICAgIHRoaXMuX2luaXRpYWxEZWxheSA9IGluaXRpYWxEZWxheTtcbiAgICB0aGlzLl9kZWxheSA9IGRlbGF5O1xuICAgIHRoaXMuX2lkbGVEZWxheSA9IGFjdGl2YXRpb25EZWxheTtcbiAgICB0aGlzLl90aW1lciA9IC0xO1xuICAgIHRoaXMuX2lzQ3Vyc29ySW5zaWRlID0gZmFsc2U7XG4gICAgdGhpcy5faXNHcmFiYmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2lzRnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgICB0aGlzLl90YXJnZXRFbCA9IG51bGw7XG4gIH1cbiAgZW5hYmxlKHZpZXdlcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5fdGFyZ2V0RWwpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSh2aWV3ZXIpO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsRGVsYXkgPSB0aGlzLl9pbml0aWFsRGVsYXk7XG4gICAgY29uc3Qgcm9vdCA9IHZpZXdlci5yb290RWw7XG4gICAgdGhpcy5fdGFyZ2V0RWwgPSB2aWV3ZXIucm9vdEVsO1xuICAgIHRoaXMuX3RpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgaW5pdGlhbERlbGF5KTtcbiAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuTU9VU0VfRE9XTiwgdGhpcy5fb25Ib2xkKTtcbiAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuTU9VU0VfRU5URVIsIHRoaXMuX29uTW91c2VFbnRlcik7XG4gICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX01PVkUsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuTU9VU0VfTEVBVkUsIHRoaXMuX29uTW91c2VMZWF2ZSk7XG4gICAgdGhpcy5fYWRkRnVsbHNjcmVlbkhhbmRsZXJzKCk7XG4gICAgY29uc3QgdmlkZW8gPSAoX2EgPSB2aWV3ZXIubWVzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRleHR1cmUoKTtcbiAgICBpZiAoIXZpZGVvIHx8ICF2aWRlby5pc1ZpZGVvKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZpZGVvLmlzUGF1c2VkKCkpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2xCYXIuY29udGFpbmVyRWwuY2xhc3NMaXN0LmFkZCh0aGlzLl9maXhlZENsYXNzKTtcbiAgICB9XG4gICAgdmlkZW8uc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fUExBWSwgdGhpcy5fb25WaWRlb1BsYXkpO1xuICAgIHZpZGVvLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKEVWRU5UUyQxLlZJREVPX1BBVVNFLCB0aGlzLl9vblZpZGVvUGF1c2UpO1xuICAgIHRoaXMuX3ZpZGVvID0gdmlkZW87XG4gIH1cbiAgZGlzYWJsZSh2aWV3ZXIpIHtcbiAgICBpZiAoIXRoaXMuX3RhcmdldEVsKSByZXR1cm47XG4gICAgY29uc3QgY29udHJvbEJhciA9IHRoaXMuX2NvbnRyb2xCYXI7XG4gICAgY29uc3Qgcm9vdCA9IHZpZXdlci5yb290RWw7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLl92aWRlbztcbiAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuTU9VU0VfRE9XTiwgdGhpcy5fb25Ib2xkKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5NT1VTRV9VUCwgdGhpcy5fb25SZWxlYXNlKTtcbiAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuTU9VU0VfRU5URVIsIHRoaXMuX29uTW91c2VFbnRlcik7XG4gICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKEVWRU5UUyQxLk1PVVNFX01PVkUsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuTU9VU0VfTEVBVkUsIHRoaXMuX29uTW91c2VMZWF2ZSk7XG4gICAgdGhpcy5fcmVtb3ZlRnVsbHNjcmVlbkhhbmRsZXJzKCk7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgY29udHJvbEJhci5jb250YWluZXJFbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2ZpeGVkQ2xhc3MpO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fUExBWSwgdGhpcy5fb25WaWRlb1BsYXkpO1xuICAgICAgdmlkZW8uc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuVklERU9fUEFVU0UsIHRoaXMuX29uVmlkZW9QYXVzZSk7XG4gICAgfVxuICAgIHRoaXMuX2lzQ3Vyc29ySW5zaWRlID0gZmFsc2U7XG4gICAgdGhpcy5faXNHcmFiYmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3ZpZGVvID0gbnVsbDtcbiAgICB0aGlzLl90YXJnZXRFbCA9IG51bGw7XG4gIH1cbiAgc2hvdygpIHtcbiAgICB0aGlzLl9jbGVhckhpZGVUaW1lcigpO1xuICAgIHRoaXMuX2NvbnRyb2xCYXIuY29udGFpbmVyRWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9oaWRkZW5DbGFzcyk7XG4gIH1cbiAgc2hvd1RlbXBvcmFsaXkoKSB7XG4gICAgdGhpcy5zaG93KCk7XG4gICAgdGhpcy5faGlkZUFmdGVyRGVsYXkodGhpcy5faWRsZURlbGF5KTtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuX2NsZWFySGlkZVRpbWVyKCk7XG4gICAgdGhpcy5fY29udHJvbEJhci5jb250YWluZXJFbC5jbGFzc0xpc3QuYWRkKHRoaXMuX2hpZGRlbkNsYXNzKTtcbiAgfVxuICBfY2xlYXJIaWRlVGltZXIoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gLTE7XG4gICAgfVxuICB9XG4gIF9oaWRlQWZ0ZXJEZWxheShkZWxheSA9IHRoaXMuX2RlbGF5KSB7XG4gICAgaWYgKHRoaXMuX2lzR3JhYmJpbmcgfHwgIXRoaXMuX2lzRnVsbHNjcmVlbiAmJiB0aGlzLl9pc0N1cnNvckluc2lkZSkgcmV0dXJuO1xuICAgIHRoaXMuX2NsZWFySGlkZVRpbWVyKCk7XG4gICAgaWYgKGRlbGF5IDw9IDApIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfVxuICB9XG4gIF9hZGRGdWxsc2NyZWVuSGFuZGxlcnMoKSB7XG4gICAgRlVMTFNDUkVFTl9DSEFOR0UuZm9yRWFjaChldnROYW1lID0+IHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICB9KTtcbiAgfVxuICBfcmVtb3ZlRnVsbHNjcmVlbkhhbmRsZXJzKCkge1xuICAgIEZVTExTQ1JFRU5fQ0hBTkdFLmZvckVhY2goZXZ0TmFtZSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXMuX29uRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgVmlkZW9Db250cm9sIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fb25LZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgdmlkZW8gPSB0aGlzLl92aWRlbztcbiAgICAgIGlmICghdmlkZW8pIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHZpZGVvRWwgPSB2aWRlby5zb3VyY2U7XG4gICAgICBjb25zdCBrZXlQcmVzc2VkID0gZXZlbnQua2V5Q29kZSAhPSBudWxsID8gRElSRUNUSU9OX0tFWV9DT0RFW2V2ZW50LmtleUNvZGVdIDogRElSRUNUSU9OX0tFWV9OQU1FW2V2ZW50LmtleV07XG4gICAgICBzd2l0Y2ggKGtleVByZXNzZWQpIHtcbiAgICAgICAgY2FzZSBcIkxFRlRcIjpcbiAgICAgICAgY2FzZSBcIlJJR0hUXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZVZpZGVvVGltZSh2aWRlb0VsLCBrZXlQcmVzc2VkID09PSBcIlJJR0hUXCIpO1xuICAgICAgICBjYXNlIFwiVVBcIjpcbiAgICAgICAgY2FzZSBcIkRPV05cIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlVmlkZW9Wb2x1bWUodmlkZW9FbCwga2V5UHJlc3NlZCA9PT0gXCJVUFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNlUHJlc3NlZCA9IGV2ZW50LmtleUNvZGUgPT09IFNQQUNFX0tFWV9DT0RFIHx8IGV2ZW50LmtleSA9PT0gU1BBQ0VfS0VZX05BTUU7XG4gICAgICBpZiAoc3BhY2VQcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVZpZGVvKHZpZGVvKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGVuYWJsZShyb290LCB2aWRlbykge1xuICAgIHRoaXMuX3ZpZGVvID0gdmlkZW87XG4gICAgLy8gY2FwdHVyZSBpcyBuZWVkZWQgZm9yIHJlc29sdmluZyBjb25mbGljdCB3aXRoIGtleWJvYXJkIGNvbnRyb2xcbiAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTJDEuS0VZX0RPV04sIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gIH1cbiAgZGlzYWJsZShyb290KSB7XG4gICAgdGhpcy5fdmlkZW8gPSBudWxsO1xuICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMkMS5LRVlfRE9XTiwgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgfVxuICBfY2hhbmdlVmlkZW9UaW1lKHZpZGVvLCBmb3J3YXJkKSB7XG4gICAgY29uc3QgZGVsdGEgPSBmb3J3YXJkID8gNSA6IC01O1xuICAgIHZpZGVvLmN1cnJlbnRUaW1lICs9IGRlbHRhO1xuICAgIHZpZGVvLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFZJREVPX1RJTUVfQ0hBTkdFX0VWRU5ULCB7XG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgdGltZTogdmlkZW8uY3VycmVudFRpbWVcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgX2NoYW5nZVZpZGVvVm9sdW1lKHZpZGVvLCBpbmNyZWFzZSkge1xuICAgIGNvbnN0IGRlbHRhID0gaW5jcmVhc2UgPyAwLjEgOiAtMC4xO1xuICAgIGlmICh2aWRlby5tdXRlZCkge1xuICAgICAgdmlkZW8udm9sdW1lID0gY2xhbXAoZGVsdGEsIDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby52b2x1bWUgPSBjbGFtcCh2aWRlby52b2x1bWUgKyBkZWx0YSwgMCwgMSk7XG4gICAgfVxuICAgIGlmICh2aWRlby52b2x1bWUgPiAwKSB7XG4gICAgICB2aWRlby5tdXRlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby5tdXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIF90b2dnbGVWaWRlbyh2aWRlbykge1xuICAgIGlmICh2aWRlby5pc1BhdXNlZCgpKSB7XG4gICAgICB2aWRlby5zb3VyY2UucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby5zb3VyY2UucGF1c2UoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXHJcbiAqIEEgcGx1Z2luIHRoYXQgZGlzcGxheXMgZXh0cmEgYnV0dG9ucyAmIGNvbnRyb2xzIHRoYXQgY29udHJvbHMge0BsaW5rIFZpZXczNjB9LlxyXG4gKiBAa28ge0BsaW5rIFZpZXczNjB97JeQIOu2gOqwgOyggeyduCDrsoTtirzqs7wg7Luo7Yq466Gk7J2EIOy2lOqwgO2VtOyjvOuKlCDtlIzrn6zqt7jsnbguXHJcbiAqIEBjYXRlZ29yeSBQbHVnaW5cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqL1xuY2xhc3MgQ29udHJvbEJhciB7XG4gIC8qKlxyXG4gICAqIFJvb3QgZWxlbWVudCBvZiB0aGUgY29udHJvbCBiYXJcclxuICAgKiBAa28g7Luo7Yq466Gk67CU7J2YIOujqO2KuCDsl5jrpqzrqLztirhcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IHJvb3RFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdEVsO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnRhaW5lciBlbGVtZW50IG9mIHRoZSBjb250cm9sIGJhclxyXG4gICAqIEBrbyDsu6jtirjroaTrsJTsnZgg7Luo7YWM7J2064SIIOyXmOumrOuovO2KuFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgY29udGFpbmVyRWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lckVsO1xuICB9XG4gIC8qKlxyXG4gICAqIEJhY2tncm91bmQgZWxlbWVudCBvZiB0aGUgY29udHJvbCBiYXJcclxuICAgKiBAa28g7Luo7Yq466Gk67CU7J2YIOuwsOqyvSDsl5jrpqzrqLztirhcclxuICAgKiBAc2luY2UgNC4wLjBcclxuICAgKi9cbiAgZ2V0IGJhY2tncm91bmRFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmdFbDtcbiAgfVxuICAvKipcclxuICAgKiBDb250cm9sIGJhcidzIGRlZmF1bHQgaXRlbXMgY3JlYXRlZCBieSB7QGxpbmsgQ29udHJvbEJhck9wdGlvbnN9XHJcbiAgICogQGtvIOyjvOyWtOynhCB7QGxpbmsgQ29udHJvbEJhck9wdGlvbnN97JeQIOydmO2VtCDsg53shLHrkJwg65SU7Y+07Yq4IOyVhOydtO2FnOuTpFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICB9XG4gIC8qKlxyXG4gICAqIEN1c3RvbSBjb250cm9sIGJhciBpdGVtc1xyXG4gICAqIEBrbyDsu6TsiqTthYAg7Luo7Yq466Gk67CUIOyVhOydtO2FnOuTpOydhCDstpTqsIDtlanri4jri6QuXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIGdldCBjdXN0b21JdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VzdG9tSXRlbXM7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBpbnN0YW5jZSBvZiBDb250cm9sQmFyLlxyXG4gICAqIEBrbyBDb250cm9sQmFy7J2YIOyDiCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGF1dG9IaWRlLFxuICAgIHNob3dCYWNrZ3JvdW5kLFxuICAgIGNsaWNrVG9QbGF5ID0gdHJ1ZSxcbiAgICBrZXlib2FyZENvbnRyb2xzID0gdHJ1ZSxcbiAgICBwcm9ncmVzc0JhciA9IHRydWUsXG4gICAgcGxheUJ1dHRvbiA9IHRydWUsXG4gICAgdm9sdW1lQnV0dG9uID0gdHJ1ZSxcbiAgICBmdWxsc2NyZWVuQnV0dG9uID0gdHJ1ZSxcbiAgICB2aWRlb1RpbWUgPSB0cnVlLFxuICAgIHBpZVZpZXcgPSB0cnVlLFxuICAgIHZyQnV0dG9uID0gdHJ1ZSxcbiAgICBneXJvQnV0dG9uID0gdHJ1ZSxcbiAgICBjbGFzc05hbWUgPSB7fSxcbiAgICBjdXN0b21JdGVtcyA9IFtdXG4gIH0gPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLl9vblN0YXRpY0NsaWNrID0gKHtcbiAgICAgIHRhcmdldDogdmlld2VyLFxuICAgICAgaXNUb3VjaFxuICAgIH0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGF1dG9IaWRlciA9IHRoaXMuX2F1dG9IaWRlcjtcbiAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgIGlmICghYXV0b0hpZGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGF1dG9IaWRlci5oaWRkZW4pIHtcbiAgICAgICAgICBhdXRvSGlkZXIuc2hvd1RlbXBvcmFsaXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdXRvSGlkZXIuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuY2xpY2tUb1BsYXkpIHJldHVybjtcbiAgICAgICAgY29uc3QgdmlkZW8gPSAoX2EgPSB2aWV3ZXIubWVzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRleHR1cmUoKTtcbiAgICAgICAgaWYgKCF2aWRlbyB8fCAhdmlkZW8uaXNWaWRlbygpKSByZXR1cm47XG4gICAgICAgIGlmICh2aWRlby5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgdmlkZW8uc291cmNlLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWRlby5zb3VyY2UucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25OZXdTcmNMb2FkID0gKHtcbiAgICAgIHRhcmdldDogdmlld2VyXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgICAgIHRoaXMuX3VwZGF0ZUJhY2tncm91bmQodmlld2VyKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUF1dG9IaWRlKHZpZXdlcik7XG4gICAgICB0aGlzLl91cGRhdGVLZXlib2FyZEhhbmRsZXIodmlld2VyKTtcbiAgICAgIE9iamVjdC5rZXlzKGl0ZW1zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaXRlbXNba2V5XTtcbiAgICAgICAgY2F0ZWdvcnkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLmRlc3Ryb3kodmlld2VyLCB0aGlzKTtcbiAgICAgICAgICBpdGVtLmluaXQodmlld2VyLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuYXV0b0hpZGUgPSBhdXRvSGlkZTtcbiAgICB0aGlzLnNob3dCYWNrZ3JvdW5kID0gc2hvd0JhY2tncm91bmQ7XG4gICAgdGhpcy5jbGlja1RvUGxheSA9IGNsaWNrVG9QbGF5O1xuICAgIHRoaXMua2V5Ym9hcmRDb250cm9scyA9IGtleWJvYXJkQ29udHJvbHM7XG4gICAgdGhpcy5wcm9ncmVzc0JhciA9IHByb2dyZXNzQmFyO1xuICAgIHRoaXMucGxheUJ1dHRvbiA9IHBsYXlCdXR0b247XG4gICAgdGhpcy52b2x1bWVCdXR0b24gPSB2b2x1bWVCdXR0b247XG4gICAgdGhpcy5mdWxsc2NyZWVuQnV0dG9uID0gZnVsbHNjcmVlbkJ1dHRvbjtcbiAgICB0aGlzLnZpZGVvVGltZSA9IHZpZGVvVGltZTtcbiAgICB0aGlzLnBpZVZpZXcgPSBwaWVWaWV3O1xuICAgIHRoaXMudnJCdXR0b24gPSB2ckJ1dHRvbjtcbiAgICB0aGlzLmd5cm9CdXR0b24gPSBneXJvQnV0dG9uO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBDb250cm9sQmFyLkRFRkFVTFRfQ0xBU1MpLCBjbGFzc05hbWUpO1xuICAgIGNvbnN0IHJvb3RDbGFzcyA9IChfYSA9IGNsYXNzTmFtZS5DT05UUk9MU19ST09UKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDb250cm9sQmFyLkRFRkFVTFRfQ0xBU1MuQ09OVFJPTFNfUk9PVDtcbiAgICB0aGlzLl9yb290RWwgPSBjcmVhdGVFbGVtZW50KHJvb3RDbGFzcyk7XG4gICAgdGhpcy5fY3JlYXRlUG9zaXRpb25XcmFwcGVycygpO1xuICAgIHRoaXMuX2l0ZW1zID0gT2JqZWN0LmtleXMoQ29udHJvbEJhci5QT1NJVElPTikucmVkdWNlKChpdGVtcywga2V5KSA9PiB7XG4gICAgICBpdGVtc1tDb250cm9sQmFyLlBPU0lUSU9OW2tleV1dID0gW107XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSwge30pO1xuICAgIHRoaXMuX2N1c3RvbUl0ZW1zID0gY3VzdG9tSXRlbXM7XG4gICAgdGhpcy5fYXV0b0hpZGVyID0gbmV3IEF1dG9IaWRlKHRoaXMsIGdldE9iamVjdE9wdGlvbihhdXRvSGlkZSkpO1xuICAgIHRoaXMuX3ZpZGVvQ29udHJvbCA9IG5ldyBWaWRlb0NvbnRyb2woKTtcbiAgICBjdXN0b21JdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgdGhpcy5faXRlbXNbaXRlbS5wb3NpdGlvbl0ucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgfVxuICBpbml0KHZpZXdlcikge1xuICAgIGNvbnN0IHBhbm9Sb290ID0gdmlld2VyLnJvb3RFbDtcbiAgICBjb25zdCBjb250cm9sc1Jvb3QgPSB0aGlzLl9yb290RWw7XG4gICAgY29uc3QgZGVmYXVsdEl0ZW1zID0gdGhpcy5fY3JlYXRlRGVmYXVsdEl0ZW1zKCk7XG4gICAgdGhpcy5fdXBkYXRlQmFja2dyb3VuZCh2aWV3ZXIpO1xuICAgIHRoaXMuX3VwZGF0ZUF1dG9IaWRlKHZpZXdlcik7XG4gICAgdGhpcy5fdXBkYXRlS2V5Ym9hcmRIYW5kbGVyKHZpZXdlcik7XG4gICAgcGFub1Jvb3QuYXBwZW5kQ2hpbGQoY29udHJvbHNSb290KTtcbiAgICB0aGlzLl9hZGRJdGVtKHZpZXdlciwgZGVmYXVsdEl0ZW1zKTtcbiAgICB0aGlzLl9hZGRJdGVtKHZpZXdlciwgdGhpcy5fY3VzdG9tSXRlbXMpO1xuICAgIHZpZXdlci5vbihFVkVOVFMuUFJPSkVDVElPTl9DSEFOR0UsIHRoaXMuX29uTmV3U3JjTG9hZCk7XG4gICAgdmlld2VyLm9uKEVWRU5UUy5TVEFUSUNfQ0xJQ0ssIHRoaXMuX29uU3RhdGljQ2xpY2spO1xuICB9XG4gIGRlc3Ryb3kodmlld2VyKSB7XG4gICAgLy8gUmVtb3ZlIGNvbnRyb2xzIHJvb3QgZnJvbSBwYW5vIHJvb3RcbiAgICBjb25zdCBwYW5vUm9vdCA9IHZpZXdlci5yb290RWw7XG4gICAgY29uc3QgY29udHJvbHNSb290ID0gdGhpcy5fcm9vdEVsO1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXM7XG4gICAgaWYgKGNvbnRyb2xzUm9vdC5wYXJlbnRFbGVtZW50ID09PSBwYW5vUm9vdCkge1xuICAgICAgcGFub1Jvb3QucmVtb3ZlQ2hpbGQoY29udHJvbHNSb290KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoaXRlbXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaXRlbXNba2V5XTtcbiAgICAgIGNhdGVnb3J5LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0uZGVzdHJveSh2aWV3ZXIsIHRoaXMpO1xuICAgICAgfSk7XG4gICAgICBpdGVtc1trZXldID0gW107XG4gICAgfSk7XG4gICAgdGhpcy5fY2xlYXJJdGVtRWxlbWVudHMoKTtcbiAgICB0aGlzLl9hdXRvSGlkZXIuZGlzYWJsZSh2aWV3ZXIpO1xuICAgIHRoaXMuX3ZpZGVvQ29udHJvbC5kaXNhYmxlKHBhbm9Sb290KTtcbiAgICB2aWV3ZXIub2ZmKEVWRU5UUy5QUk9KRUNUSU9OX0NIQU5HRSwgdGhpcy5fb25OZXdTcmNMb2FkKTtcbiAgICB2aWV3ZXIub2ZmKEVWRU5UUy5TVEFUSUNfQ0xJQ0ssIHRoaXMuX29uU3RhdGljQ2xpY2spO1xuICB9XG4gIF9hZGRJdGVtKHZpZXdlciwgaXRlbXMpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gdGhpcy5faXRlbXNbaXRlbS5wb3NpdGlvbl07XG4gICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5fd3JhcHBlckVsW2l0ZW0ucG9zaXRpb25dO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdJbmRleCA9IGZpbmRJbmRleChjYXRlZ29yeSwgc2libGluZyA9PiBzaWJsaW5nLm9yZGVyID4gaXRlbS5vcmRlcik7XG4gICAgICBpZiAobmV4dFNpYmxpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gY2F0ZWdvcnlbbmV4dFNpYmxpbmdJbmRleF0uZWxlbWVudDtcbiAgICAgICAgY2F0ZWdvcnkuc3BsaWNlKG5leHRTaWJsaW5nSW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICB3cmFwcGVyLmluc2VydEJlZm9yZShpdGVtLmVsZW1lbnQsIG5leHRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhdGVnb3J5LnB1c2goaXRlbSk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGl0ZW0uaW5pdCh2aWV3ZXIsIHRoaXMpO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlUG9zaXRpb25XcmFwcGVycygpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIENvbnRyb2xCYXIuREVGQVVMVF9DTEFTUyksIHRoaXMuY2xhc3NOYW1lKTtcbiAgICBjb25zdCByb290RWwgPSB0aGlzLl9yb290RWw7XG4gICAgLy8gQkcgJiBGTE9BVElORyBDT05UUk9MU1xuICAgIGNvbnN0IGJhY2tncm91bmRFbCA9IGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLkNPTlRST0xTX0JHKTtcbiAgICBjb25zdCBmbG9hdExlZnRFbCA9IGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLkNPTlRST0xTX0ZMT0FUX0xFRlQpO1xuICAgIGNvbnN0IGZsb2F0UmlnaHRFbCA9IGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLkNPTlRST0xTX0ZMT0FUX1JJR0hUKTtcbiAgICByb290RWwuYXBwZW5kQ2hpbGQoZmxvYXRMZWZ0RWwpO1xuICAgIHJvb3RFbC5hcHBlbmRDaGlsZChmbG9hdFJpZ2h0RWwpO1xuICAgIC8vIEJPVFRPTSBDT05UUk9MU1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLkNPTlRST0xTX01BSU4pO1xuICAgIGNvbnN0IHRvcFdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZS5DT05UUk9MU19UT1ApO1xuICAgIGNvbnN0IGJvdHRvbVdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZS5DT05UUk9MU19CT1RUT00pO1xuICAgIGNvbnN0IG1pZFdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZS5DT05UUk9MU19NSUQpO1xuICAgIGNvbnN0IGxlZnRDb250cm9sc1dyYXBwZXIgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZS5DT05UUk9MU19MRUZUKTtcbiAgICBjb25zdCByaWdodENvbnRyb2xzV3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLkNPTlRST0xTX1JJR0hUKTtcbiAgICBtaWRXcmFwcGVyLmFwcGVuZENoaWxkKGxlZnRDb250cm9sc1dyYXBwZXIpO1xuICAgIG1pZFdyYXBwZXIuYXBwZW5kQ2hpbGQocmlnaHRDb250cm9sc1dyYXBwZXIpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChiYWNrZ3JvdW5kRWwpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b3BXcmFwcGVyKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWlkV3JhcHBlcik7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJvdHRvbVdyYXBwZXIpO1xuICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIHRoaXMuX2JnRWwgPSBiYWNrZ3JvdW5kRWw7XG4gICAgdGhpcy5fY29udGFpbmVyRWwgPSBjb250YWluZXI7XG4gICAgdGhpcy5fd3JhcHBlckVsID0ge1xuICAgICAgW0NvbnRyb2xCYXIuUE9TSVRJT04uTUFJTl9UT1BdOiB0b3BXcmFwcGVyLFxuICAgICAgW0NvbnRyb2xCYXIuUE9TSVRJT04uTUFJTl9MRUZUXTogbGVmdENvbnRyb2xzV3JhcHBlcixcbiAgICAgIFtDb250cm9sQmFyLlBPU0lUSU9OLk1BSU5fUklHSFRdOiByaWdodENvbnRyb2xzV3JhcHBlcixcbiAgICAgIFtDb250cm9sQmFyLlBPU0lUSU9OLk1BSU5fQk9UVE9NXTogYm90dG9tV3JhcHBlcixcbiAgICAgIFtDb250cm9sQmFyLlBPU0lUSU9OLlRPUF9MRUZUXTogZmxvYXRMZWZ0RWwsXG4gICAgICBbQ29udHJvbEJhci5QT1NJVElPTi5UT1BfUklHSFRdOiBmbG9hdFJpZ2h0RWxcbiAgICB9O1xuICB9XG4gIF9jbGVhckl0ZW1FbGVtZW50cygpIHtcbiAgICBjb25zdCB3cmFwcGVycyA9IE9iamVjdC5rZXlzKENvbnRyb2xCYXIuUE9TSVRJT04pLm1hcChrZXkgPT4gQ29udHJvbEJhci5QT1NJVElPTltrZXldKS5tYXAocG9zID0+IHRoaXMuX3dyYXBwZXJFbFtwb3NdKTtcbiAgICAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGluc2lkZSB3cmFwcGVyc1xuICAgIHdyYXBwZXJzLmZvckVhY2god3JhcHBlciA9PiB7XG4gICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlQXV0b0hpZGUodmlld2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF1dG9IaWRlID0gdGhpcy5hdXRvSGlkZTtcbiAgICBjb25zdCBhdXRvSGlkZXIgPSB0aGlzLl9hdXRvSGlkZXI7XG4gICAgaWYgKGF1dG9IaWRlICE9IG51bGwpIHtcbiAgICAgIGlmIChhdXRvSGlkZSkge1xuICAgICAgICBhdXRvSGlkZXIuZW5hYmxlKHZpZXdlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRvSGlkZXIuZGlzYWJsZSh2aWV3ZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IGNob29zZSB3aGV0aGVyIHRvIHNob3cgYmFja2dyb3VuZCBieSBjb250ZW50IHR5cGVcbiAgICAgIGNvbnN0IHRleHR1cmUgPSAoX2EgPSB2aWV3ZXIubWVzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRleHR1cmUoKTtcbiAgICAgIGlmICh0ZXh0dXJlICYmIHRleHR1cmUuaXNWaWRlbygpKSB7XG4gICAgICAgIC8vIEVuYWJsZSBhdXRvIGhpZGUgd2hlbiBjb250ZW50IHR5cGUgaXMgdmlkZW9cbiAgICAgICAgYXV0b0hpZGVyLmVuYWJsZSh2aWV3ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXV0b0hpZGVyLmRpc2FibGUodmlld2VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUJhY2tncm91bmQodmlld2VyKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBiYWNrZ3JvdW5kID0gdGhpcy5fYmdFbDtcbiAgICBjb25zdCBzaG93QmFja2dyb3VuZCA9IHRoaXMuc2hvd0JhY2tncm91bmQ7XG4gICAgY29uc3QgaGlkZGVuQ2xhc3MgPSAoX2EgPSB0aGlzLmNsYXNzTmFtZS5ISURERU4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENvbnRyb2xCYXIuREVGQVVMVF9DTEFTUy5ISURERU47XG4gICAgaWYgKHNob3dCYWNrZ3JvdW5kICE9IG51bGwpIHtcbiAgICAgIGlmIChzaG93QmFja2dyb3VuZCkge1xuICAgICAgICBiYWNrZ3JvdW5kLmNsYXNzTGlzdC5yZW1vdmUoaGlkZGVuQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFja2dyb3VuZC5jbGFzc0xpc3QuYWRkKGhpZGRlbkNsYXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXV0b21hdGljYWxseSBjaG9vc2Ugd2hldGhlciB0byBzaG93IGJhY2tncm91bmQgYnkgY29udGVudCB0eXBlXG4gICAgICBjb25zdCB0ZXh0dXJlID0gKF9iID0gdmlld2VyLm1lc2gpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRUZXh0dXJlKCk7XG4gICAgICBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzVmlkZW8oKSkge1xuICAgICAgICAvLyBTaG93IGJnIHdoZW4gY29udGVudCB0eXBlIGlzIHZpZGVvXG4gICAgICAgIGJhY2tncm91bmQuY2xhc3NMaXN0LnJlbW92ZShoaWRkZW5DbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWNrZ3JvdW5kLmNsYXNzTGlzdC5hZGQoaGlkZGVuQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfdXBkYXRlS2V5Ym9hcmRIYW5kbGVyKHZpZXdlcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwYW5vUm9vdCA9IHZpZXdlci5yb290RWw7XG4gICAgY29uc3QgdmlkZW9Db250cm9sID0gdGhpcy5fdmlkZW9Db250cm9sO1xuICAgIGNvbnN0IHRleHR1cmUgPSAoX2EgPSB2aWV3ZXIubWVzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRleHR1cmUoKTtcbiAgICBpZiAodGhpcy5rZXlib2FyZENvbnRyb2xzICYmIHRleHR1cmUgJiYgdGV4dHVyZS5pc1ZpZGVvKCkpIHtcbiAgICAgIHZpZGVvQ29udHJvbC5lbmFibGUocGFub1Jvb3QsIHRleHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0NvbnRyb2wuZGlzYWJsZShwYW5vUm9vdCk7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVEZWZhdWx0SXRlbXMoKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBpZiAodGhpcy5wcm9ncmVzc0Jhcikge1xuICAgICAgaXRlbXMucHVzaChuZXcgUHJvZ3Jlc3NCYXIoZ2V0T2JqZWN0T3B0aW9uKHRoaXMucHJvZ3Jlc3NCYXIpKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBsYXlCdXR0b24pIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IFBsYXlCdXR0b24oZ2V0T2JqZWN0T3B0aW9uKHRoaXMucGxheUJ1dHRvbikpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudm9sdW1lQnV0dG9uKSB7XG4gICAgICBpdGVtcy5wdXNoKG5ldyBWb2x1bWVDb250cm9sKGdldE9iamVjdE9wdGlvbih0aGlzLnZvbHVtZUJ1dHRvbikpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3lyb0J1dHRvbikge1xuICAgICAgaXRlbXMucHVzaChuZXcgR3lyb0J1dHRvbihnZXRPYmplY3RPcHRpb24odGhpcy5neXJvQnV0dG9uKSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy52ckJ1dHRvbikge1xuICAgICAgaXRlbXMucHVzaChuZXcgVlJCdXR0b24oZ2V0T2JqZWN0T3B0aW9uKHRoaXMudnJCdXR0b24pKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZ1bGxzY3JlZW5CdXR0b24pIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IEZ1bGxzY3JlZW5CdXR0b24oZ2V0T2JqZWN0T3B0aW9uKHRoaXMuZnVsbHNjcmVlbkJ1dHRvbikpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmlkZW9UaW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKG5ldyBWaWRlb1RpbWUoZ2V0T2JqZWN0T3B0aW9uKHRoaXMudmlkZW9UaW1lKSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5waWVWaWV3KSB7XG4gICAgICBpdGVtcy5wdXNoKG5ldyBQaWVWaWV3KGdldE9iamVjdE9wdGlvbih0aGlzLnBpZVZpZXcpKSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxufVxuLyoqXHJcbiAqIERlZmF1bHQgY2xhc3MgbmFtZXMgdGhhdCBDb250cm9sQmFyIHVzZXNcclxuICogQGtvIENvbnRyb2xCYXLqsIAg7IKs7Jqp7ZWY64qUIOuUlO2PtO2KuCDtgbTrnpjsiqQg7J2066aE65OkXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cbkNvbnRyb2xCYXIuREVGQVVMVF9DTEFTUyA9IENPTlRST0xfQkFSX0RFRkFVTFRfQ0xBU1M7XG4vKipcclxuICogQ29uc3RhbnRzIGZvciB7QGxpbmsgQ29udHJvbEJhckl0ZW1PcHRpb25zI3Bvc2l0aW9ufVxyXG4gKiBAa28ge0BsaW5rIENvbnRyb2xCYXJJdGVtT3B0aW9ucyNwb3NpdGlvbn3sl5Ag7IKs7JqpIOqwgOuKpe2VnCDqsJLrk6RcclxuICovXG5Db250cm9sQmFyLlBPU0lUSU9OID0gQ09OVFJPTF9CQVJfSVRFTV9QT1NJVElPTjtcblxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHByb2plY3Rpb25zLlxyXG4gKiBAa28g7ZSE66Gc7KCd7IWYIOuyoOydtOyKpCDtgbTrnpjsiqQuXHJcbiAqIEBjYXRlZ29yeSBQcm9qZWN0aW9uXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cbmNsYXNzIFByb2plY3Rpb24ge1xuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlXHJcbiAgICogQGtvIOyDiOuhnOyatCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHNyYyxcbiAgICB2aWRlbyA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB0aGlzLnZpZGVvID0gdmlkZW87XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIGNhbWVyYSB0byBtYXRjaCBwcm9qZWN0aW9uJ3Mgc2V0dGluZ3MuXHJcbiAgICogQGtvIO2YhOyerCDtlITroZzsoJ3shZjsnZgg7IS47YyF7Jy866GcIOy5tOuplOudvOulvCDsl4XrjbDsnbTtirjtlanri4jri6QuXHJcbiAgICogQHBhcmFtIGNhbWVyYSAtIEluc3RhbmNlIG9mIHRoZSBjYW1lcmEgdG8gdXBkYXRlIHtAa28g7JeF642w7J207Yq47ZWgIOy5tOuplOudvOydmCDsnbjsiqTthLTsiqR9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIHVwZGF0ZUNhbWVyYShjYW1lcmEpIHtcbiAgICAvLyBVc2UgZGVmYXVsdCBtb2RlICYgbm8gdmlldyByZXN0cmljdGlvblxuICAgIGNhbWVyYS5yZXNldFJhbmdlKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIGNvbnRyb2wgdG8gbWF0Y2ggcHJvamVjdGlvbidzIHNldHRpbmdzLlxyXG4gICAqIEBrbyDtmITsnqwg7ZSE66Gc7KCd7IWY7J2YIOyEuO2MheycvOuhnCDsu6jtirjroaTsnYQg7JeF642w7J207Yq47ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBjb250cm9sIC0gSW5zdGFuY2Ugb2YgdGhlIGNvbnRyb2wgdG8gdXBkYXRlIHtAa28g7JeF642w7J207Yq47ZWgIOy7qO2KuOuhpOydmCDsnbjsiqTthLTsiqR9XHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIHVwZGF0ZUNvbnRyb2woY29udHJvbCkge1xuICAgIGNvbnRyb2wuaWdub3JlWm9vbVNjYWxlID0gZmFsc2U7XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuY2xhc3MgVW5pZm9ybSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgZGVzdHJveShnbCkge1xuICAgIC8vIERPX05PVEhJTkdcbiAgfVxufVxuXG5jbGFzcyBVbmlmb3JtVGV4dHVyZUN1YmUgZXh0ZW5kcyBVbmlmb3JtIHtcbiAgY29uc3RydWN0b3IoY3R4LCB0ZXh0dXJlLCBjdWJlbWFwT3JkZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgdGhpcy5fd2ViZ2xUZXh0dXJlID0gY3R4LmNyZWF0ZVdlYkdMQ3ViZVRleHR1cmUodGV4dHVyZSwgdGV4dHVyZS53aWR0aCk7XG4gICAgdGhpcy5fY3ViZW1hcE9yZGVyID0gY3ViZW1hcE9yZGVyO1xuICB9XG4gIGRlc3Ryb3koZ2wpIHtcbiAgICB0aGlzLnRleHR1cmUuZGVzdHJveSgpO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy5fd2ViZ2xUZXh0dXJlKTtcbiAgfVxuICB1cGRhdGUoZ2wsIGxvY2F0aW9uLCBpc1dlYkdMMikge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSk7XG4gICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCAwKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0aGlzLl93ZWJnbFRleHR1cmUpO1xuICAgIGNvbnN0IHNvdXJjZXMgPSByZW9yZGVyQ3ViZSh0ZXh0dXJlLnNvdXJjZXMsIHRoaXMuX2N1YmVtYXBPcmRlcik7XG4gICAgc291cmNlcy5mb3JFYWNoKChzcmMsIGlkeCkgPT4ge1xuICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaWR4LCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBzcmMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpZHgsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHNyYyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCF0ZXh0dXJlLmlzVmlkZW8oKSkge1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vKiogQGhpZGRlbiAqL1xuY2xhc3MgQ3ViZVRleHR1cmVQYWludGVyIHtcbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cbiAgY29uc3RydWN0b3IodGV4dHVyZSwgY3ViZW1hcE9yZGVyKSB7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLl9yZW5kZXJpbmdPcmRlciA9IHJlb3JkZXJDdWJlKHJhbmdlKDYpLCBjdWJlbWFwT3JkZXIpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5fY2FsY1JlbmRlcmluZ1NpemUoKTtcbiAgICBjYW52YXMud2lkdGggPSB0aGlzLl9zaXplO1xuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9zaXplO1xuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLl9jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgIC8vIHJlbGVhc2UgbWVtb3JpZXNcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHRoaXMuX2NhbnZhcyA9IG51bGw7XG4gIH1cbiAgZHJhdyhnbCwgaXNXZWJHTDIpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgIGxldCBzdXJmYWNlSWR4ID0gMDtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLl9yb3c7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLl9jb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICAgIGNvbnN0IHggPSBzaXplICogY29sdW1uO1xuICAgICAgICBjb25zdCB5ID0gc2l6ZSAqIHJvdztcbiAgICAgICAgY29uc3QgcmVuZGVyaW5nRmFjZSA9IHRoaXMuX3JlbmRlcmluZ09yZGVyW3N1cmZhY2VJZHhdO1xuICAgICAgICB0aGlzLl9jdHguZHJhd0ltYWdlKHRleHR1cmUuc291cmNlLCB4LCB5LCBzaXplLCBzaXplLCAwLCAwLCBzaXplLCBzaXplKTtcbiAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyByZW5kZXJpbmdGYWNlLCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLl9jYW52YXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyaW5nRmFjZSwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5fY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBzdXJmYWNlSWR4Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jYWxjUmVuZGVyaW5nU2l6ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLnRleHR1cmU7XG4gICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgaWYgKGFzcGVjdCA9PT0gMSAvIDYpIHtcbiAgICAgIHRoaXMuX3NpemUgPSB3aWR0aDtcbiAgICAgIHRoaXMuX3JvdyA9IDY7XG4gICAgICB0aGlzLl9jb2x1bW4gPSAxO1xuICAgIH0gZWxzZSBpZiAoYXNwZWN0ID09PSA2KSB7XG4gICAgICB0aGlzLl9zaXplID0gaGVpZ2h0O1xuICAgICAgdGhpcy5fcm93ID0gMTtcbiAgICAgIHRoaXMuX2NvbHVtbiA9IDY7XG4gICAgfSBlbHNlIGlmIChhc3BlY3QgPT09IDIgLyAzKSB7XG4gICAgICB0aGlzLl9zaXplID0gd2lkdGggKiAwLjU7XG4gICAgICB0aGlzLl9yb3cgPSAzO1xuICAgICAgdGhpcy5fY29sdW1uID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2l6ZSA9IHdpZHRoIC8gMztcbiAgICAgIHRoaXMuX3JvdyA9IDI7XG4gICAgICB0aGlzLl9jb2x1bW4gPSAzO1xuICAgIH1cbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG5jbGFzcyBVbmlmb3JtQ2FudmFzQ3ViZSBleHRlbmRzIFVuaWZvcm0ge1xuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFpbnRlci50ZXh0dXJlO1xuICB9XG4gIGNvbnN0cnVjdG9yKGN0eCwgdGV4dHVyZSwgY3ViZW1hcE9yZGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9wYWludGVyID0gbmV3IEN1YmVUZXh0dXJlUGFpbnRlcih0ZXh0dXJlLCBjdWJlbWFwT3JkZXIpO1xuICAgIHRoaXMuX3dlYmdsVGV4dHVyZSA9IGN0eC5jcmVhdGVXZWJHTEN1YmVUZXh0dXJlKHRleHR1cmUsIHRoaXMuX3BhaW50ZXIuc2l6ZSk7XG4gIH1cbiAgZGVzdHJveShnbCkge1xuICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy5fd2ViZ2xUZXh0dXJlKTtcbiAgICB0aGlzLl9wYWludGVyLmRlc3Ryb3koKTtcbiAgfVxuICB1cGRhdGUoZ2wsIGxvY2F0aW9uLCBpc1dlYkdMMikge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgMCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy5fd2ViZ2xUZXh0dXJlKTtcbiAgICB0aGlzLl9wYWludGVyLmRyYXcoZ2wsIGlzV2ViR0wyKTtcbiAgICBpZiAoIXRleHR1cmUuaXNWaWRlbygpKSB7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xuY2xhc3MgVHJpYW5nbGVNZXNoIGV4dGVuZHMgT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3Rvcih2YW8sIHByb2dyYW0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFvID0gdmFvO1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gIH1cbiAgZGVzdHJveShjdHgpIHtcbiAgICBjdHgucmVsZWFzZVZBTyh0aGlzLnZhbyk7XG4gICAgY3R4LnJlbGVhc2VTaGFkZXJSZXNvdXJjZXModGhpcy5wcm9ncmFtKTtcbiAgfVxuICBnZXRUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyYW0udW5pZm9ybXMudVRleHR1cmUudGV4dHVyZTtcbiAgfVxufVxuXG5jbGFzcyBTaGFkZXJQcm9ncmFtIHtcbiAgY29uc3RydWN0b3IoY3R4LCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCB1bmlmb3Jtcykge1xuICAgIHRoaXMucHJvZ3JhbSA9IGN0eC5jcmVhdGVQcm9ncmFtKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB1bmlmb3JtcztcbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSBjdHguZ2V0VW5pZm9ybUxvY2F0aW9ucyh0aGlzLnByb2dyYW0sIHVuaWZvcm1zKTtcbiAgfVxufVxuXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cbmNsYXNzIFZlcnRleERhdGEge1xuICAvKiogKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgaXRlbVNpemUpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcbiAgICB0aGlzLmNvdW50ID0gZGF0YS5sZW5ndGggLyBpdGVtU2l6ZTtcbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cbmNsYXNzIEdlb21ldHJ5IHtcbiAgLyoqICovXG4gIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBpbmRpY2llcywgdXZzKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBWZXJ0ZXhEYXRhKG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpLCAzKTtcbiAgICB0aGlzLmluZGljaWVzID0gbmV3IFZlcnRleERhdGEobmV3IFVpbnQxNkFycmF5KGluZGljaWVzKSwgMSk7XG4gICAgdGhpcy51dnMgPSBuZXcgVmVydGV4RGF0YShuZXcgRmxvYXQzMkFycmF5KHV2cyksIDIpO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xuY2xhc3MgQ3ViZUdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3JkZXIsXG4gICAgcm90YXRlVVZcbiAgfSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW1xuICAgIC8vIGJhY2tcbiAgICAxLCAtMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAvLyBmcm9udFxuICAgIC0xLCAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSxcbiAgICAvLyB1cFxuICAgIC0xLCAxLCAtMSwgMSwgMSwgLTEsIDEsIDEsIDEsIC0xLCAxLCAxLFxuICAgIC8vIGRvd25cbiAgICAtMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgLy8gcmlnaHRcbiAgICAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAxLCAxLCAxLCAxLCAtMSxcbiAgICAvLyBsZWZ0XG4gICAgLTEsIC0xLCAxLCAtMSwgLTEsIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxXTtcbiAgICBjb25zdCBpbmRpY2llcyA9IFswLCAxLCAyLCAwLCAyLCAzLCA0LCA1LCA2LCA0LCA2LCA3LCA4LCA5LCAxMCwgOCwgMTAsIDExLCAxMiwgMTMsIDE0LCAxMiwgMTQsIDE1LCAxNiwgMTcsIDE4LCAxNiwgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMCwgMjIsIDIzXTtcbiAgICBjb25zdCBvbmVUaGlyZCA9IDEgLyAzO1xuICAgIGNvbnN0IGNvb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IHIgPSAxOyByID49IDA7IHItLSkge1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCAzOyBjKyspIHtcbiAgICAgICAgY29uc3QgY29vcmQgPSBbYyAqIG9uZVRoaXJkLCByICogMC41LCAoYyArIDEpICogb25lVGhpcmQsIHIgKiAwLjUsIChjICsgMSkgKiBvbmVUaGlyZCwgKHIgKyAxKSAqIDAuNSwgYyAqIG9uZVRoaXJkLCAociArIDEpICogMC41XTtcbiAgICAgICAgY29vcmRzLnB1c2goY29vcmQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm90YXRlVVYpIHtcbiAgICAgIHJvdGF0ZVVWLmZvckVhY2goKGRlZ3JlZSwgaWR4KSA9PiB7XG4gICAgICAgIGlmIChkZWdyZWUgPT09IFJPVEFURS5aRVJPKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGNvb3JkID0gY29vcmRzW2lkeF07XG4gICAgICAgIGxldCBuZXdPcmRlcjtcbiAgICAgICAgaWYgKGRlZ3JlZSA9PT0gUk9UQVRFLkNXXzkwKSB7XG4gICAgICAgICAgbmV3T3JkZXIgPSBbMSwgMiwgMywgMF07XG4gICAgICAgIH0gZWxzZSBpZiAoZGVncmVlID09PSBST1RBVEUuQ0NXXzkwKSB7XG4gICAgICAgICAgbmV3T3JkZXIgPSBbMywgMCwgMSwgMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3T3JkZXIgPSBbMiwgMywgMCwgMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q29vcmRzID0gQXJyYXkoY29vcmQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgdXZJZHggPSAwOyB1dklkeCA8IGNvb3JkLmxlbmd0aCAvIDI7IHV2SWR4KyspIHtcbiAgICAgICAgICBuZXdDb29yZHNbdXZJZHggKiAyICsgMF0gPSBjb29yZFtuZXdPcmRlclt1dklkeF0gKiAyICsgMF07XG4gICAgICAgICAgbmV3Q29vcmRzW3V2SWR4ICogMiArIDFdID0gY29vcmRbbmV3T3JkZXJbdXZJZHhdICogMiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvb3Jkc1tpZHhdID0gbmV3Q29vcmRzO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHV2cyA9IHJlb3JkZXJDdWJlKGNvb3Jkcywgb3JkZXIsIFwiQkZVRFJMXCIpLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYy5jb25jYXQodmFsKSwgW10pO1xuICAgIHN1cGVyKHZlcnRpY2VzLCBpbmRpY2llcywgdXZzKTtcbiAgfVxufVxuXG52YXIgdnMkMyA9IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjthdHRyaWJ1dGUgdmVjMiB1djt1bmlmb3JtIG1hdDQgdU1WTWF0cml4O3VuaWZvcm0gbWF0NCB1UE1hdHJpeDt2YXJ5aW5nIGhpZ2hwIHZlYzMgdlBvczt2b2lkIG1haW4oKXt2UG9zPXBvc2l0aW9uO2dsX1Bvc2l0aW9uPXVQTWF0cml4KnVNVk1hdHJpeCp2ZWM0KHBvc2l0aW9uLDEuMCk7fVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbnZhciBmcyQzID0gXCIjZGVmaW5lIEdMU0xJRlkgMVxcbnVuaWZvcm0gc2FtcGxlckN1YmUgdVRleHR1cmU7dmFyeWluZyBoaWdocCB2ZWMzIHZQb3M7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmVDdWJlKHVUZXh0dXJlLHZlYzModlBvcy54LHZQb3MueSwtdlBvcy56KSk7fVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBQcm9qZWN0aW9uIGJhc2VkIG9uIGN1YmVtYXAgaW1hZ2VzLCBhY2NlcHRzIGJvdGggbXVsdGlwbGUgb3Igc2luZ2xlIGltYWdlcy5cclxuICogQGtvIO2BkOu4jOuntSDsnbTrr7jsp4Ag6riw67CY7J2YIO2UhOuhnOygneyFmCwg64uo7J28IO2YueydgCDsl6zrn6wg7J6l7J2YIOydtOuvuOyngOulvCDrqqjrkZAg7IKs7JqpIOqwgOuKpe2VqeuLiOuLpC5cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBQcm9qZWN0aW9uXHJcbiAqL1xuY2xhc3MgQ3ViZW1hcFByb2plY3Rpb24gZXh0ZW5kcyBQcm9qZWN0aW9uIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIG5ldyBpbnN0YW5jZS5cclxuICAgKiBAa28g7IOIIOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB7QGtvIE9wdGlvbnN9XHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBjdWJlbWFwT3JkZXIgPSBcIlJMVURGQlwiLFxuICAgICAgY3ViZW1hcEZsaXBYID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLl9jdWJlbWFwT3JkZXIgPSBjdWJlbWFwT3JkZXI7XG4gICAgdGhpcy5fY3ViZW1hcEZsaXBYID0gY3ViZW1hcEZsaXBYO1xuICB9XG4gIGNyZWF0ZU1lc2goY3R4LCB0ZXh0dXJlKSB7XG4gICAgY29uc3QgY3ViZW1hcE9yZGVyID0gdGhpcy5fY3ViZW1hcE9yZGVyO1xuICAgIGNvbnN0IGN1YmVtYXBGbGlwWCA9IHRoaXMuX2N1YmVtYXBGbGlwWDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHVUZXh0dXJlOiB0ZXh0dXJlLmlzQ3ViZSgpID8gbmV3IFVuaWZvcm1UZXh0dXJlQ3ViZShjdHgsIHRleHR1cmUsIGN1YmVtYXBPcmRlcikgOiBuZXcgVW5pZm9ybUNhbnZhc0N1YmUoY3R4LCB0ZXh0dXJlLCBjdWJlbWFwT3JkZXIpXG4gICAgfTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBDdWJlR2VvbWV0cnkoe1xuICAgICAgb3JkZXI6IGN1YmVtYXBPcmRlclxuICAgIH0pO1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShjdHgsIHZzJDMsIGZzJDMsIHVuaWZvcm1zKTtcbiAgICBjb25zdCB2YW8gPSBjdHguY3JlYXRlVkFPKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IFRyaWFuZ2xlTWVzaCh2YW8sIHByb2dyYW0pO1xuICAgIGlmIChjdWJlbWFwRmxpcFgpIHtcbiAgICAgIG1lc2guc2NhbGVbMF0gPSAtMTtcbiAgICB9XG4gICAgbWVzaC51cGRhdGVNYXRyaXgoKTtcbiAgICByZXR1cm4gbWVzaDtcbiAgfVxufVxuXG5jbGFzcyBVbmlmb3JtVGV4dHVyZTJEIGV4dGVuZHMgVW5pZm9ybSB7XG4gIGNvbnN0cnVjdG9yKGN0eCwgdGV4dHVyZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB0aGlzLl93ZWJnbFRleHR1cmUgPSBjdHguY3JlYXRlV2ViR0xUZXh0dXJlKHRleHR1cmUpO1xuICB9XG4gIGRlc3Ryb3koZ2wpIHtcbiAgICB0aGlzLnRleHR1cmUuZGVzdHJveSgpO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy5fd2ViZ2xUZXh0dXJlKTtcbiAgfVxuICB1cGRhdGUoZ2wsIGxvY2F0aW9uLCBpc1dlYkdMMikge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgY29uc3QgaXNWaWRlbyA9IHRleHR1cmUuaXNWaWRlbygpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkpO1xuICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgMCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fd2ViZ2xUZXh0dXJlKTtcbiAgICBpZiAoIWlzVmlkZW8gJiYgaXNXZWJHTDIpIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCFpc1ZpZGVvKSB7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbnZhciB2cyQyID0gXCIjZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO2F0dHJpYnV0ZSB2ZWMyIHV2O3VuaWZvcm0gbWF0NCB1TVZNYXRyaXg7dW5pZm9ybSBtYXQ0IHVQTWF0cml4O3ZhcnlpbmcgaGlnaHAgdmVjMiB2VVY7dm9pZCBtYWluKCl7dlVWPXV2O2dsX1Bvc2l0aW9uPXVQTWF0cml4KnVNVk1hdHJpeCp2ZWM0KHBvc2l0aW9uLDEuMCk7fVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbnZhciBmcyQyID0gXCIjZGVmaW5lIEdMU0xJRlkgMVxcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO3ZhcnlpbmcgaGlnaHAgdmVjMiB2VVY7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRCh1VGV4dHVyZSx2VVYuc3QpO31cIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogUHJvamVjdGlvbiBiYXNlZCBvbiBjdWJlbWFwIHN0cmlwLlxyXG4gKiBTbGlnaHRseSBtb3JlIGVmZmljaWVudCB0aGFuIHtAbGluayBDdWJlbWFwUHJvamVjdGlvbn0gYXMgaXQgZG9lc24ndCBjb3B5IGN1YmVtYXAgaW1hZ2UgdG8gY2FudmFzIHdoaWxlIHJlbmRlcmluZy5cclxuICogQWNjZXB0cyBvbmx5IHNpbmdsZSBpbWFnZS5cclxuICogQGtvIO2BkOu4jOuntSDsiqTtirjrpr0g6riw67CY7J2YIO2UhOuhnOygneyFmC5cclxuICoge0BsaW5rIEN1YmVtYXBQcm9qZWN0aW9ufeyZgCDri6zrpqwg66CM642U66eB7ZWY64qUIOqzvOygleyXkCDsupTrsoTsiqTsl5Ag7J2066+47KeA66W8IOuzteyCrO2VmOuKlCDqs7zsoJXsnbQg7JeG6riwIOuVjOusuOyXkCDsgrTsp50g642UIO2aqOycqOyggeyeheuLiOuLpC5cclxuICog64uo7J28IOydtOuvuOyngOunjCDsgqzsmqkg6rCA64ql7ZWp64uI64ukLlxyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IFByb2plY3Rpb25cclxuICovXG5jbGFzcyBDdWJlc3RyaXBQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2UuXHJcbiAgICogQGtvIOyDiCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMge0BrbyBPcHRpb25zfVxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgY3ViZW1hcE9yZGVyID0gXCJSTFVERkJcIixcbiAgICAgIGN1YmVtYXBGbGlwWCA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY3ViZW1hcE9yZGVyID0gY3ViZW1hcE9yZGVyO1xuICAgIHRoaXMuX2N1YmVtYXBGbGlwWCA9IGN1YmVtYXBGbGlwWDtcbiAgfVxuICBjcmVhdGVNZXNoKGN0eCwgdGV4dHVyZSkge1xuICAgIGNvbnN0IGN1YmVtYXBPcmRlciA9IHRoaXMuX2N1YmVtYXBPcmRlcjtcbiAgICBjb25zdCBjdWJlbWFwRmxpcFggPSB0aGlzLl9jdWJlbWFwRmxpcFg7XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICB1VGV4dHVyZTogbmV3IFVuaWZvcm1UZXh0dXJlMkQoY3R4LCB0ZXh0dXJlKVxuICAgIH07XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQ3ViZUdlb21ldHJ5KHtcbiAgICAgIG9yZGVyOiBjdWJlbWFwT3JkZXJcbiAgICB9KTtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0oY3R4LCB2cyQyLCBmcyQyLCB1bmlmb3Jtcyk7XG4gICAgY29uc3QgdmFvID0gY3R4LmNyZWF0ZVZBTyhnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgY29uc3QgbWVzaCA9IG5ldyBUcmlhbmdsZU1lc2godmFvLCBwcm9ncmFtKTtcbiAgICBpZiAoY3ViZW1hcEZsaXBYKSB7XG4gICAgICBtZXNoLnNjYWxlWzBdID0gLTE7XG4gICAgfVxuICAgIG1lc2gudXBkYXRlTWF0cml4KCk7XG4gICAgcmV0dXJuIG1lc2g7XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXG5jbGFzcyBDeWxpbmRlckdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihtYXhUaGV0YSkge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgY29uc3QgaW5kaWNpZXMgPSBbXTtcbiAgICBjb25zdCB1dnMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHQgPSAxO1xuICAgIGNvbnN0IHJhZGlhbFNlZ21lbnRzID0gNjA7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAqIDAuNTtcbiAgICBjb25zdCBoZWlnaHRTZWdtZW50cyA9IFstaGFsZkhlaWdodCwgaGFsZkhlaWdodF07XG4gICAgY29uc3QgaW52UmFkaWFsU2VnbWVudHMgPSAxIC8gcmFkaWFsU2VnbWVudHM7XG4gICAgY29uc3QgYW5nbGVDb25zdCA9IG1heFRoZXRhICogaW52UmFkaWFsU2VnbWVudHM7XG4gICAgZm9yIChsZXQgeUlkeCA9IDA7IHlJZHggPCAyOyB5SWR4KyspIHtcbiAgICAgIGNvbnN0IHkgPSBoZWlnaHRTZWdtZW50c1t5SWR4XTtcbiAgICAgIGZvciAobGV0IGxuZ0lkeCA9IDA7IGxuZ0lkeCA8PSByYWRpYWxTZWdtZW50czsgbG5nSWR4KyspIHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBsbmdJZHggKiBhbmdsZUNvbnN0ICsgTWF0aC5QSSAtIG1heFRoZXRhICogMC41O1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCB6ID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBjb25zdCB1ID0gbG5nSWR4ICogaW52UmFkaWFsU2VnbWVudHM7XG4gICAgICAgIGNvbnN0IHYgPSB5SWR4O1xuICAgICAgICB1dnMucHVzaCh1LCB2KTtcbiAgICAgICAgdmVydGljZXMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgaWYgKHlJZHggPT09IDAgJiYgbG5nSWR4IDwgcmFkaWFsU2VnbWVudHMpIHtcbiAgICAgICAgICBjb25zdCBhID0gbG5nSWR4O1xuICAgICAgICAgIGNvbnN0IGIgPSBhICsgcmFkaWFsU2VnbWVudHMgKyAxO1xuICAgICAgICAgIGluZGljaWVzLnB1c2goYSwgYiwgYSArIDEsIGIsIGIgKyAxLCBhICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIodmVydGljZXMsIGluZGljaWVzLCB1dnMpO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4qL1xuLyoqXHJcbiAqIFByb2plY3Rpb24gYmFzZWQgb24gY3lsaW5kcmljYWwgcHJvamVjdGlvbi5cclxuICogVGhpcyBjYW4gc2hvdyBwYW5vcmFtYSBpbWFnZXMgdGFrZW4gZnJvbSBzbWFydHBob25lcy5cclxuICogQGtvIOybkO2GtSDtiKzsmIHrspUg6riw67CY7J2YIO2UhOuhnOygneyFmC5cclxuICog7J2867CY7KCB7J24IOyKpOuniO2KuO2PsCDtjIzrhbjrnbzrp4gg7IKs7KeE7J2EIO2RnOyLnO2VmOuKlOuNsCDsgqzsmqnrkKAg7IiYIOyeiOyKteuLiOuLpC5cclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBQcm9qZWN0aW9uXHJcbiAqL1xuY2xhc3MgQ3lsaW5kcmljYWxQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2UuXHJcbiAgICogQGtvIOyDiCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMge0BrbyBPcHRpb25zfVxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgcGFydGlhbCA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcGFydGlhbCA9IHBhcnRpYWw7XG4gICAgdGhpcy5fYXNwZWN0ID0gMTtcbiAgICB0aGlzLl9oYWxmSGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9tZXNoID0gbnVsbDtcbiAgfVxuICBjcmVhdGVNZXNoKGN0eCwgdGV4dHVyZSkge1xuICAgIGlmICh0aGlzLl9tZXNoKSByZXR1cm4gdGhpcy5fbWVzaDtcbiAgICBjb25zdCBwYXJ0aWFsID0gdGhpcy5fcGFydGlhbDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0ZXh0dXJlO1xuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IGhhbGZWRm92ID0gMTgwIC8gYXNwZWN0O1xuICAgIGNvbnN0IGN5bGluZGVySGVpZ2h0ID0gcGFydGlhbCA/IDEgOiAyICogTWF0aC50YW4oaGFsZlZGb3YgKiBERUdfVE9fUkFEKTtcbiAgICBjb25zdCBjeWxpbmRlclRoZXRhID0gcGFydGlhbCA/IGFzcGVjdCA6IDIgKiBNYXRoLlBJO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEN5bGluZGVyR2VvbWV0cnkoY3lsaW5kZXJUaGV0YSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKGN0eCwgdnMkMiwgZnMkMiwge1xuICAgICAgdVRleHR1cmU6IG5ldyBVbmlmb3JtVGV4dHVyZTJEKGN0eCwgdGV4dHVyZSlcbiAgICB9KTtcbiAgICBjb25zdCB2YW8gPSBjdHguY3JlYXRlVkFPKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IFRyaWFuZ2xlTWVzaCh2YW8sIHByb2dyYW0pO1xuICAgIG1lc2guc2NhbGVbMV0gPSBjeWxpbmRlckhlaWdodDtcbiAgICBxdWF0LmlkZW50aXR5KG1lc2gucm90YXRpb24pO1xuICAgIHF1YXQucm90YXRlWShtZXNoLnJvdGF0aW9uLCBtZXNoLnJvdGF0aW9uLCAtTWF0aC5QSSAvIDIpO1xuICAgIG1lc2gudXBkYXRlTWF0cml4KCk7XG4gICAgdGhpcy5fYXNwZWN0ID0gYXNwZWN0O1xuICAgIHRoaXMuX2hhbGZIZWlnaHQgPSBjeWxpbmRlckhlaWdodCAqIDAuNTtcbiAgICB0aGlzLl9tZXNoID0gbWVzaDtcbiAgICByZXR1cm4gbWVzaDtcbiAgfVxuICB1cGRhdGVDYW1lcmEoY2FtZXJhKSB7XG4gICAgc3VwZXIudXBkYXRlQ2FtZXJhKGNhbWVyYSk7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMuX21lc2g7XG4gICAgY29uc3QgYXNwZWN0ID0gdGhpcy5fYXNwZWN0O1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSB0aGlzLl9oYWxmSGVpZ2h0O1xuICAgIGlmICghbWVzaCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9wYXJ0aWFsKSB7XG4gICAgICBjb25zdCByZXN0cmljdGVkWWF3ID0gMC41ICogYXNwZWN0ICogUkFEX1RPX0RFRztcbiAgICAgIGNhbWVyYS5yZXN0cmljdFlhd1JhbmdlKC1yZXN0cmljdGVkWWF3LCByZXN0cmljdGVkWWF3KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdHJpY3RlZFBpdGNoID0gTWF0aC5hdGFuMihoYWxmSGVpZ2h0LCAxKSAqIFJBRF9UT19ERUc7XG4gICAgY29uc3QgbWluWm9vbSA9IE1hdGgudGFuKGNhbWVyYS5mb3YgKiBERUdfVE9fUkFEICogMC41KSAvIChoYWxmSGVpZ2h0ICogY2FtZXJhLmFzcGVjdCk7XG4gICAgY2FtZXJhLnJlc3RyaWN0UGl0Y2hSYW5nZSgtcmVzdHJpY3RlZFBpdGNoLCByZXN0cmljdGVkUGl0Y2gpO1xuICAgIGNhbWVyYS5yZXN0cmljdFpvb21SYW5nZShtaW5ab29tLCBJbmZpbml0eSk7XG4gICAgY2FtZXJhLnJlc3RyaWN0UmVuZGVySGVpZ2h0KGhhbGZIZWlnaHQgKiAyKTtcbiAgfVxufVxuXG52YXIgZnMkMSA9IFwiI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG51bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTt2YXJ5aW5nIGhpZ2hwIHZlYzIgdlVWO2NvbnN0IHZlYzIgT1BFUkFURV9DT09SRFNfUkFOR0U9dmVjMigtMS4wLDEuMCk7Y29uc3QgdmVjMiBURVhUVVJFX0NPT1JEU19SQU5HRT12ZWMyKDAuMCwxLjApO2NvbnN0IGZsb2F0IE9ORV9USElSRD0xLjAvMy4wO2NvbnN0IGZsb2F0IEVBQ19DT05TVD0yLjAvUEk7ZmxvYXQgc2NhbGUodmVjMiBkb21haW5SYW5nZSx2ZWMyIHRhcmdldFJhbmdlLGZsb2F0IHZhbCl7ZmxvYXQgdW5pdD0xLjAvKGRvbWFpblJhbmdlWzFdLWRvbWFpblJhbmdlWzBdKTtyZXR1cm4gdGFyZ2V0UmFuZ2VbMF0rKHRhcmdldFJhbmdlWzFdLXRhcmdldFJhbmdlWzBdKSoodmFsLWRvbWFpblJhbmdlWzBdKSp1bml0O312b2lkIG1haW4odm9pZCl7ZmxvYXQgdHJhbnNmb3JtZWRDb29yZFg7ZmxvYXQgdHJhbnNmb3JtZWRDb29yZFk7ZmxvYXQgdGV4UmFuZ2VYU3RhcnQ9Zmxvb3IodlVWLnMqMy4pKk9ORV9USElSRDtmbG9hdCB0ZXhSYW5nZVlTdGFydD1mbG9vcih2VVYudCoyLikqMC41O3ZlYzIgb3JnVGV4dHVyZVJhbmdlWD12ZWMyKHRleFJhbmdlWFN0YXJ0LHRleFJhbmdlWFN0YXJ0K09ORV9USElSRCk7dmVjMiBvcmdUZXh0dXJlUmFuZ2VZPXZlYzIodGV4UmFuZ2VZU3RhcnQsdGV4UmFuZ2VZU3RhcnQrMC41KTtmbG9hdCBweD1zY2FsZShvcmdUZXh0dXJlUmFuZ2VYLE9QRVJBVEVfQ09PUkRTX1JBTkdFLHZVVi5zKTtmbG9hdCBweT1zY2FsZShvcmdUZXh0dXJlUmFuZ2VZLE9QRVJBVEVfQ09PUkRTX1JBTkdFLHZVVi50KTtmbG9hdCBxdT1FQUNfQ09OU1QqYXRhbihweCkrMC41O2Zsb2F0IHF2PUVBQ19DT05TVCphdGFuKHB5KSswLjU7dHJhbnNmb3JtZWRDb29yZFg9c2NhbGUoVEVYVFVSRV9DT09SRFNfUkFOR0Usb3JnVGV4dHVyZVJhbmdlWCxxdSk7dHJhbnNmb3JtZWRDb29yZFk9c2NhbGUoVEVYVFVSRV9DT09SRFNfUkFOR0Usb3JnVGV4dHVyZVJhbmdlWSxxdik7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRCh1VGV4dHVyZSx2ZWMyKHRyYW5zZm9ybWVkQ29vcmRYLHRyYW5zZm9ybWVkQ29vcmRZKSk7fVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBFcXVpLUFuZ3VsYXIgQ3ViZW1hcCBQcm9qZWN0aW9uLlxyXG4gKiBUaGlzIGZvcm1hdCBpcyB1c2VkIGJ5IFlvdXR1YmUncyAzNjAgdmlkZW9zLlxyXG4gKiBAa28gRXF1aS1Bbmd1bGFyIEN1YmVtYXAg7ZSE66Gc7KCd7IWYLlxyXG4gKiDsnbQg7Y+s66e37J2AIOyjvOuhnCBZb3V0dWJl7J2YIDM2MCDruYTrlJTsmKTsl5Ag7IKs7Jqp65Cp64uI64ukLlxyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IFByb2plY3Rpb25cclxuICovXG5jbGFzcyBFcXVpYW5ndWxhclByb2plY3Rpb24gZXh0ZW5kcyBQcm9qZWN0aW9uIHtcbiAgY3JlYXRlTWVzaChjdHgsIHRleHR1cmUpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHVUZXh0dXJlOiBuZXcgVW5pZm9ybVRleHR1cmUyRChjdHgsIHRleHR1cmUpXG4gICAgfTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBDdWJlR2VvbWV0cnkoe1xuICAgICAgb3JkZXI6IFwiTEZSREJVXCIsXG4gICAgICByb3RhdGVVVjogW1JPVEFURS5aRVJPLCBST1RBVEUuWkVSTywgUk9UQVRFLlpFUk8sIFJPVEFURS5DV185MCwgUk9UQVRFLkNDV185MCwgUk9UQVRFLkNXXzkwXVxuICAgIH0pO1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShjdHgsIHZzJDIsIGZzJDEsIHVuaWZvcm1zKTtcbiAgICBjb25zdCB2YW8gPSBjdHguY3JlYXRlVkFPKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IFRyaWFuZ2xlTWVzaCh2YW8sIHByb2dyYW0pO1xuICAgIHJldHVybiBtZXNoO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xuY2xhc3MgU3BoZXJlR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIC8qKiAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBjb25zdCByYWRpdXMgPSAxO1xuICAgIGNvbnN0IHdpZHRoU2VnbWVudHMgPSA2MDtcbiAgICBjb25zdCBoZWlnaHRTZWdtZW50cyA9IDYwO1xuICAgIGNvbnN0IEFOR0xFX0NPUlJFQ1RJT05fRk9SX0NFTlRFUl9BTElHTiA9IC0wLjUgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHV2cyA9IFtdO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgY29uc3QgaW5kaWNpZXMgPSBbXTtcbiAgICBsZXQgbGF0SWR4O1xuICAgIGxldCBsbmdJZHg7XG4gICAgZm9yIChsYXRJZHggPSAwOyBsYXRJZHggPD0gd2lkdGhTZWdtZW50czsgbGF0SWR4KyspIHtcbiAgICAgIGNvbnN0IHRoZXRhID0gKGxhdElkeCAvIHdpZHRoU2VnbWVudHMgLSAwLjUpICogTWF0aC5QSTtcbiAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgY29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICBmb3IgKGxuZ0lkeCA9IDA7IGxuZ0lkeCA8PSBoZWlnaHRTZWdtZW50czsgbG5nSWR4KyspIHtcbiAgICAgICAgY29uc3QgcGhpID0gKGxuZ0lkeCAvIGhlaWdodFNlZ21lbnRzIC0gMC41KSAqIDIgKiBNYXRoLlBJICsgQU5HTEVfQ09SUkVDVElPTl9GT1JfQ0VOVEVSX0FMSUdOO1xuICAgICAgICBjb25zdCBzaW5QaGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgICBjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgICBjb25zdCB4ID0gY29zUGhpICogY29zVGhldGE7XG4gICAgICAgIGNvbnN0IHkgPSBzaW5UaGV0YTtcbiAgICAgICAgY29uc3QgeiA9IHNpblBoaSAqIGNvc1RoZXRhO1xuICAgICAgICBjb25zdCB1ID0gbG5nSWR4IC8gaGVpZ2h0U2VnbWVudHM7XG4gICAgICAgIGNvbnN0IHYgPSBsYXRJZHggLyB3aWR0aFNlZ21lbnRzO1xuICAgICAgICB1dnMucHVzaCh1LCB2KTtcbiAgICAgICAgdmVydGljZXMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgaWYgKGxuZ0lkeCAhPT0gaGVpZ2h0U2VnbWVudHMgJiYgbGF0SWR4ICE9PSB3aWR0aFNlZ21lbnRzKSB7XG4gICAgICAgICAgY29uc3QgYSA9IGxhdElkeCAqIChoZWlnaHRTZWdtZW50cyArIDEpICsgbG5nSWR4O1xuICAgICAgICAgIGNvbnN0IGIgPSBhICsgaGVpZ2h0U2VnbWVudHMgKyAxO1xuICAgICAgICAgIGluZGljaWVzLnB1c2goYSwgYSArIDEsIGIsIGIsIGEgKyAxLCBiICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIodmVydGljZXMsIGluZGljaWVzLCB1dnMpO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBQcm9qZWN0aW9uIGJhc2VkIG9uIGVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKiBAa28g65OxIOyepeuwqe2YlSDrj4TrspUoRXF1aXJlY3Rhbmd1bGFyIHByb2plY3Rpb24pIOq4sOuwmOydmCDtlITroZzsoJ3shZhcclxuICogQHNpbmNlIDQuMC4wXHJcbiAqIEBjYXRlZ29yeSBQcm9qZWN0aW9uXHJcbiAqL1xuY2xhc3MgRXF1aXJlY3RQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2VcclxuICAgKiBAa28g7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHtAa28g7Ji17IWY65OkfVxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgY3JlYXRlTWVzaChjdHgsIHRleHR1cmUpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHVUZXh0dXJlOiBuZXcgVW5pZm9ybVRleHR1cmUyRChjdHgsIHRleHR1cmUpXG4gICAgfTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShjdHgsIHZzJDIsIGZzJDIsIHVuaWZvcm1zKTtcbiAgICBjb25zdCB2YW8gPSBjdHguY3JlYXRlVkFPKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IFRyaWFuZ2xlTWVzaCh2YW8sIHByb2dyYW0pO1xuICAgIHJldHVybiBtZXNoO1xuICB9XG59XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbmNsYXNzIFVuaWZvcm1GbG9hdCBleHRlbmRzIFVuaWZvcm0ge1xuICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICB9XG4gIHVwZGF0ZShnbCwgbG9jYXRpb24pIHtcbiAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHRoaXMudmFsKTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gIH1cbn1cblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXG5jbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnkge1xuICAvKiogKi9cbiAgY29uc3RydWN0b3Iod2lkdGggPSAyLCBoZWlnaHQgPSAyLCB6ID0gLTEpIHtcbiAgICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAqIDAuNTtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0ICogMC41O1xuICAgIGNvbnN0IHZlcnRpY2VzID0gWy1oYWxmV2lkdGgsIC1oYWxmSGVpZ2h0LCB6LCBoYWxmV2lkdGgsIC1oYWxmSGVpZ2h0LCB6LCAtaGFsZldpZHRoLCBoYWxmSGVpZ2h0LCB6LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQsIHpdO1xuICAgIGNvbnN0IGluZGljaWVzID0gWzAsIDEsIDIsIDIsIDEsIDNdO1xuICAgIGNvbnN0IHV2cyA9IFswLCAwLCAxLCAwLCAwLCAxLCAxLCAxXTtcbiAgICBzdXBlcih2ZXJ0aWNlcywgaW5kaWNpZXMsIHV2cyk7XG4gIH1cbn1cblxudmFyIHZzJDEgPSBcIiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb247YXR0cmlidXRlIHZlYzIgdXY7dW5pZm9ybSBtYXQ0IHVNVk1hdHJpeDt1bmlmb3JtIG1hdDQgdVBNYXRyaXg7dmFyeWluZyBoaWdocCB2ZWMyIHZVVjt2b2lkIG1haW4oKXt2VVY9dXY7Z2xfUG9zaXRpb249dmVjNChwb3NpdGlvbiwxLjApO31cIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgZnMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7dW5pZm9ybSBmbG9hdCB1WWF3O3VuaWZvcm0gZmxvYXQgdVBpdGNoO3VuaWZvcm0gZmxvYXQgdVpvb207dmFyeWluZyBoaWdocCB2ZWMyIHZVVjtjb25zdCBmbG9hdCBQST0zLjE0MTU5MjY1MzY7Y29uc3QgZmxvYXQgUElfMj1QSSowLjU7dmVjMiB0b1N0ZXJlb2dyYXBoaWNVVihpbiB2ZWMyIHV2LGluIHZlYzIgY2VudGVyKXtmbG9hdCBSPTEuKnVab29tO3ZlYzIgdGV4TGF0TG9uPSh1dioyLi0xLikqdmVjMihQSSxQSV8yKTt2ZWMyIGNlbnRyYWw9KGNlbnRlcioyLi0xLikqdmVjMihQSSxQSV8yKSt2ZWMyKFBJLDApO2Zsb2F0IHg9dGV4TGF0TG9uLng7ZmxvYXQgeT10ZXhMYXRMb24ueTtmbG9hdCByb3U9c3FydCh4KngreSp5KTtmbG9hdCBjPTIuMCphdGFuKHJvdSxSKjAuNSk7ZmxvYXQgc2luX2M9c2luKGMpO2Zsb2F0IGNvc19jPWNvcyhjKTtmbG9hdCBzaW5fY3k9c2luKGNlbnRyYWwueSk7ZmxvYXQgY29zX2N5PWNvcyhjZW50cmFsLnkpO2Zsb2F0IGxhdD1hc2luKGNvc19jKnNpbl9jeSsoeSpzaW5fYypjb3NfY3kpL3JvdSk7ZmxvYXQgbG9uPWNlbnRyYWwueCthdGFuKHgqc2luX2Mscm91KmNvc19jeSpjb3NfYy15KnNpbl9jeSpzaW5fYyk7ZmxvYXQgdT0obG9uL1BJKzEuMCkqMC41O2Zsb2F0IHY9KGxhdC9QSV8yKzEuMCkqMC41O3JldHVybiB2ZWMyKHUsdik7fXZvaWQgbWFpbigpe3ZlYzIgY2VudHJhbD12ZWMyKHVZYXcsdVBpdGNoKTt2ZWMyIHV2PXRvU3RlcmVvZ3JhcGhpY1VWKHZVVixjZW50cmFsKTtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKHVUZXh0dXJlLHV2KTt9XCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDIzLXByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIFByb2plY3Rpb24gYmFzZWQgb24gc28tY2FsbGVkIFwiTGl0dGxlIHBsYW5ldFwiIG9yIFwiVGlueSBwbGFuZXRcIiBlZmZlY3QuXHJcbiAqIEBrbyBcIkxpdHRsZSBwbGFuZXRcIiDtmLnsnYAgXCJUaW55IHBsYW5ldFwi66GcIOu2iOumrOuKlCDsnbTtjpntirgg6riw67CY7J2YIO2UhOuhnOygneyFmFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IFByb2plY3Rpb25cclxuICovXG5jbGFzcyBMaXR0bGVQbGFuZXRQcm9qZWN0aW9uIGV4dGVuZHMgUHJvamVjdGlvbiB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2VcclxuICAgKiBAa28g7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlanri4jri6QuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHtAa28g7Ji17IWY65OkfVxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgY3JlYXRlTWVzaChjdHgsIHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlLndyYXBTID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJFUEVBVDtcbiAgICB0ZXh0dXJlLndyYXBUID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJFUEVBVDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIHVUZXh0dXJlOiBuZXcgVW5pZm9ybVRleHR1cmUyRChjdHgsIHRleHR1cmUpLFxuICAgICAgdVlhdzogbmV3IFVuaWZvcm1GbG9hdCgwKSxcbiAgICAgIHVQaXRjaDogbmV3IFVuaWZvcm1GbG9hdCgwLjUpLFxuICAgICAgdVpvb206IG5ldyBVbmlmb3JtRmxvYXQoMSlcbiAgICB9O1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0oY3R4LCB2cyQxLCBmcywgdW5pZm9ybXMpO1xuICAgIGNvbnN0IHZhbyA9IGN0eC5jcmVhdGVWQU8oZ2VvbWV0cnksIHByb2dyYW0pO1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgVHJpYW5nbGVNZXNoKHZhbywgcHJvZ3JhbSk7XG4gICAgbWVzaC5vbihPQkpFQ1RfM0RfRVZFTlRTLlVQREFURSwgKHtcbiAgICAgIGNhbWVyYVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHVuaWZvcm1zID0gbWVzaC5wcm9ncmFtLnVuaWZvcm1zO1xuICAgICAgdW5pZm9ybXMudVlhdy52YWwgPSBjYW1lcmEueWF3IC8gMzYwO1xuICAgICAgLy8gUmFuZ2UgZnJvbSAwIH4gMVxuICAgICAgdW5pZm9ybXMudVBpdGNoLnZhbCA9IGNhbWVyYS5waXRjaCAvIDE4MCArIDAuNTtcbiAgICAgIHVuaWZvcm1zLnVab29tLnZhbCA9IGNhbWVyYS56b29tO1xuICAgICAgdW5pZm9ybXMudVlhdy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB1bmlmb3Jtcy51UGl0Y2gubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgdW5pZm9ybXMudVpvb20ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBtZXNoO1xuICB9XG4gIHVwZGF0ZUNvbnRyb2woY29udHJvbCkge1xuICAgIGNvbnRyb2wuaWdub3JlWm9vbVNjYWxlID0gdHJ1ZTtcbiAgfVxufVxuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG5jbGFzcyBVbmlmb3JtVmVjdG9yNEFycmF5IGV4dGVuZHMgVW5pZm9ybSB7XG4gIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gIH1cbiAgdXBkYXRlKGdsLCBsb2NhdGlvbikge1xuICAgIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHRoaXMudmFsLnJlZHVjZSgoYXJyLCB2ZWN0b3IpID0+IFsuLi5hcnIsIC4uLnZlY3Rvcl0sIFtdKSk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG59XG5cbnZhciB2cyA9IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjthdHRyaWJ1dGUgdmVjMiB1djt1bmlmb3JtIG1hdDQgdU1WTWF0cml4O3VuaWZvcm0gbWF0NCB1UE1hdHJpeDt1bmlmb3JtIHZlYzQgdVRleFNjYWxlT2Zmc2V0WzJdO3VuaWZvcm0gZmxvYXQgdUV5ZTt2YXJ5aW5nIGhpZ2hwIHZlYzIgdlVWO3ZvaWQgbWFpbigpe3ZlYzQgc2NhbGVPZmZzZXQ9dVRleFNjYWxlT2Zmc2V0W2ludCh1RXllKV07dlVWPXV2Lnh5KnNjYWxlT2Zmc2V0Lnh5K3NjYWxlT2Zmc2V0Lnp3O2dsX1Bvc2l0aW9uPXVQTWF0cml4KnVNVk1hdHJpeCp2ZWM0KHBvc2l0aW9uLDEuMCk7fVwiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMy1wcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBQcm9qZWN0aW9uIGJhc2VkIG9uIHN0ZXJlbyBlcXVpcmVjdGFuZ3VsYXIgaW1hZ2VzLlxyXG4gKiBAa28gU3RlcmVvIGVxdWlyZWN0YW5ndWxhciDsnbTrr7jsp4Ag6riw67CY7J2YIO2UhOuhnOygneyFmFxyXG4gKiBAc2luY2UgNC4wLjBcclxuICogQGNhdGVnb3J5IFByb2plY3Rpb25cclxuICovXG5jbGFzcyBTdGVyZW9FcXVpUHJvamVjdGlvbiBleHRlbmRzIFByb2plY3Rpb24ge1xuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IGluc3RhbmNlXHJcbiAgICogQGtvIOyDiOuhnOyatCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB7QGtvIOyYteyFmOuTpH1cclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuX21vZGUgPSBvcHRpb25zLm1vZGU7XG4gIH1cbiAgY3JlYXRlTWVzaChjdHgsIHRleHR1cmUpIHtcbiAgICBsZXQgbGVmdEV5ZTtcbiAgICBsZXQgcmlnaHRFeWU7XG4gICAgc3dpdGNoICh0aGlzLl9tb2RlKSB7XG4gICAgICBjYXNlIFN0ZXJlb0VxdWlQcm9qZWN0aW9uLk1PREUuTEVGVF9SSUdIVDpcbiAgICAgICAgbGVmdEV5ZSA9IFswLjUsIDEsIDAsIDBdO1xuICAgICAgICByaWdodEV5ZSA9IFswLjUsIDEsIDAuNSwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRGVmYXVsdCwgdXNlcyBcInRvcF9ib3R0b21cIlxuICAgICAgICBsZWZ0RXllID0gWzEsIDAuNSwgMCwgMF07XG4gICAgICAgIHJpZ2h0RXllID0gWzEsIDAuNSwgMCwgMC41XTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgICB1VGV4dHVyZTogbmV3IFVuaWZvcm1UZXh0dXJlMkQoY3R4LCB0ZXh0dXJlKSxcbiAgICAgIHVFeWU6IG5ldyBVbmlmb3JtRmxvYXQoMCksXG4gICAgICB1VGV4U2NhbGVPZmZzZXQ6IG5ldyBVbmlmb3JtVmVjdG9yNEFycmF5KFtsZWZ0RXllLCByaWdodEV5ZV0pXG4gICAgfTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShjdHgsIHZzLCBmcyQyLCB1bmlmb3Jtcyk7XG4gICAgY29uc3QgdmFvID0gY3R4LmNyZWF0ZVZBTyhnZW9tZXRyeSwgcHJvZ3JhbSk7XG4gICAgY29uc3QgbWVzaCA9IG5ldyBUcmlhbmdsZU1lc2godmFvLCBwcm9ncmFtKTtcbiAgICByZXR1cm4gbWVzaDtcbiAgfVxufVxuLyoqXHJcbiAqIEF2YWlsYWJsZSBzdGVyZW9zY29waWMgbW9kZXNcclxuICogQGtvIOyCrOyaqeqwgOuKpe2VnCDsiqTthYzroIjsmKTsiqTsvZTtlL0g66qo65Oc65OkXHJcbiAqIEBzaW5jZSA0LjAuMFxyXG4gKi9cblN0ZXJlb0VxdWlQcm9qZWN0aW9uLk1PREUgPSB7XG4gIC8qKlxyXG4gICAqIEBrbyDsnbTrr7jsp4DqsIAg7Jm87Kq9L+yYpOuluOyqveycvOuhnCDqtazshLHrkJjslrTsnojsnYQg6rK97JqwXHJcbiAgICogQHNpbmNlIDQuMC4wXHJcbiAgICovXG4gIExFRlRfUklHSFQ6IFwibGVmdF9yaWdodFwiLFxuICAvKipcclxuICAgKiBAa28g7J2066+47KeA6rCAIOychC/slYTrnpjroZwg6rWs7ISx65CY7Ja07J6I7J2EIOqyveyasFxyXG4gICAqIEBzaW5jZSA0LjAuMFxyXG4gICAqL1xuICBUT1BfQk9UVE9NOiBcInRvcF9ib3R0b21cIlxufTtcblxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXG5jb25zdCB3aXRoTWV0aG9kcyA9IChwcm90b3R5cGUsIGF0dHIpID0+IHtcbiAgW0NvbXBvbmVudC5wcm90b3R5cGUsIFZpZXczNjAucHJvdG90eXBlXS5mb3JFYWNoKHByb3RvID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZmlsdGVyKG5hbWUgPT4gbmFtZS5jaGFyQXQoMCkgIT09IFwiX1wiICYmIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIikuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBuYW1lKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgIC8vIFB1YmxpYyBGdW5jdGlvblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZS5jYWxsKHRoaXNbYXR0cl0sIC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBnZXR0ZXJEZXNjcmlwdG9yID0ge307XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgIGdldHRlckRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbYXR0cl0gJiYgKChfYSA9IGRlc2NyaXB0b3IuZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzW2F0dHJdKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICBnZXR0ZXJEZXNjcmlwdG9yLnNldCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGVzY3JpcHRvci5zZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXNbYXR0cl0sIC4uLmFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwgZ2V0dGVyRGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXG5jb25zdCBnZXRWYWxpZFByb3BzID0gcHJvcHNPYmogPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMocHJvcHNPYmopLnJlZHVjZSgocHJvcHMsIHByb3BOYW1lKSA9PiB7XG4gICAgaWYgKHByb3BzT2JqW3Byb3BOYW1lXSAhPSBudWxsKSB7XG4gICAgICBwcm9wc1twcm9wTmFtZV0gPSBwcm9wc09ialtwcm9wTmFtZV07XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfSwge30pO1xufTtcblxuY29uc3QgVklFVzM2MF9NRVRIT0RTID0gW1wiZGVzdHJveVwiLCBcImluaXRcIiwgXCJsb2FkXCIsIFwicmVzaXplXCIsIFwiYWRkUGx1Z2luc1wiLCBcInJlbW92ZVBsdWdpbnNcIiwgXCJyZW5kZXJGcmFtZVwiLFxuLy8gQGVnanMvY29tcG9uZW50IG1ldGhvZHNcblwib25cIiwgXCJoYXNPblwiLCBcIm9uY2VcIiwgXCJvZmZcIiwgXCJ0cmlnZ2VyXCJdO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMtcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG5cbmV4cG9ydCB7IEF1dG9SZXNpemVyLCBBdXRvcGxheSwgQ2FtZXJhLCBDYW1lcmFBbmltYXRpb24sIENvbnRyb2xCYXIsIENvbnRyb2xCYXJJdGVtLCBDdWJlbWFwUHJvamVjdGlvbiwgQ3ViZXN0cmlwUHJvamVjdGlvbiwgQ3lsaW5kcmljYWxQcm9qZWN0aW9uLCBERUZBVUxUX0NMQVNTLCBFQVNJTkcsIEVSUk9SX0NPREVTLCBFVkVOVFMsIEVxdWlhbmd1bGFyUHJvamVjdGlvbiwgRXF1aXJlY3RQcm9qZWN0aW9uLCBGdWxsc2NyZWVuQnV0dG9uLCBHeXJvQ29udHJvbCwgSG90c3BvdCwgSG90c3BvdFJlbmRlcmVyLCBMaXR0bGVQbGFuZXRQcm9qZWN0aW9uLCBMb2FkaW5nU3Bpbm5lciwgTW90aW9uLCBPYmplY3QzRCwgUGFub0NvbnRyb2wsIFBpZVZpZXcsIFBsYXlCdXR0b24sIFByb2dyZXNzQmFyLCBQcm9qZWN0aW9uLCBSb3RhdGVDb250cm9sLCBTdGVyZW9FcXVpUHJvamVjdGlvbiwgVklFVzM2MF9NRVRIT0RTLCBWaWRlb1RpbWUsIFZpZXczNjBFcnJvciwgVm9sdW1lQ29udHJvbCwgV2ViR0xSZW5kZXJlciwgWFJNYW5hZ2VyLCBab29tQ29udHJvbCwgVmlldzM2MCBhcyBkZWZhdWx0LCBnZXRWYWxpZFByb3BzLCB3aXRoTWV0aG9kcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldzM2MC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwicXVhdCIsInZlYzMiLCJtYXQ0IiwidmVjMiIsIkltUmVhZHkiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJWaWV3MzYwRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNvZGUiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsIm5hbWUiLCJFUlJPUl9DT0RFUyIsIldST05HX1RZUEUiLCJXUk9OR19PUFRJT04iLCJFTEVNRU5UX05PVF9GT1VORCIsIkNBTlZBU19OT1RfRk9VTkQiLCJXRUJHTF9OT1RfU1VQUE9SVEVEIiwiRkFJTEVEX0NSRUFURV9DT05URVhUXzJEIiwiUFJPVklERV9QUk9KRUNUSU9OX0ZJUlNUIiwiRkFJTEVEX0xJTktJTkdfUFJPR1JBTSIsIklOU1VGRklDSUVOVF9BUkdTIiwiTUVTU0FHRVMiLCJ2YWwiLCJ0eXBlcyIsIm1hcCIsInR5cGUiLCJqb2luIiwib3B0aW9uTmFtZSIsInF1ZXJ5IiwibXNnIiwic2hhZGVyTG9nIiwiRVJST1IiLCJDT0RFUyIsIkVWRU5UUyQxIiwiTU9VU0VfRE9XTiIsIk1PVVNFX01PVkUiLCJNT1VTRV9VUCIsIlRPVUNIX1NUQVJUIiwiVE9VQ0hfTU9WRSIsIlRPVUNIX0VORCIsIldIRUVMIiwiUkVTSVpFIiwiQ09OVEVYVF9NRU5VIiwiTU9VU0VfRU5URVIiLCJNT1VTRV9MRUFWRSIsIlBPSU5URVJfRE9XTiIsIlBPSU5URVJfTU9WRSIsIlBPSU5URVJfVVAiLCJQT0lOVEVSX0NBTkNFTCIsIlBPSU5URVJfRU5URVIiLCJQT0lOVEVSX0xFQVZFIiwiS0VZX0RPV04iLCJLRVlfVVAiLCJMT0FEIiwiQ0xJQ0siLCJET1VCTEVfQ0xJQ0siLCJDT05URVhUX0NSRUFURV9FUlJPUiIsIkNPTlRFWFRfTE9TVCIsIkNPTlRFWFRfUkVTVE9SRUQiLCJERVZJQ0VfT1JJRU5UQVRJT04iLCJERVZJQ0VfTU9USU9OIiwiT1JJRU5UQVRJT05fQ0hBTkdFIiwiVklERU9fUExBWSIsIlZJREVPX1BBVVNFIiwiVklERU9fTE9BREVEX0RBVEEiLCJWSURFT19WT0xVTUVfQ0hBTkdFIiwiVklERU9fVElNRV9VUERBVEUiLCJWSURFT19EVVJBVElPTl9DSEFOR0UiLCJWSURFT19DQU5fUExBWVRIUk9VR0giLCJUUkFOU0lUSU9OX0VORCIsIlhSX0VORCIsIkVMX0RJViIsIkVMX0JVVFRPTiIsIk1PVVNFX0JVVFRPTiIsIkNVUlNPUiIsIkdSQUIiLCJHUkFCQklORyIsIk5PTkUiLCJLRVlfRElSRUNUSU9OIiwiRElSRUNUSU9OX0tFWV9DT0RFIiwiU1BBQ0VfS0VZX0NPREUiLCJESVJFQ1RJT05fS0VZX05BTUUiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkRPV04iLCJTUEFDRV9LRVlfTkFNRSIsIkZVTExTQ1JFRU5fUkVRVUVTVCIsIkZVTExTQ1JFRU5fRUxFTUVOVCIsIkZVTExTQ1JFRU5fRVhJVCIsIkZVTExTQ1JFRU5fQ0hBTkdFIiwiREVGQVVMVF9DTEFTUyIsIkNPTlRBSU5FUiIsIkNBTlZBUyIsIkNUWF9MT1NUIiwiSU5fVlIiLCJIT1RTUE9UX0NPTlRBSU5FUiIsIkhPVFNQT1QiLCJIT1RTUE9UX1ZJU0lCTEUiLCJIT1RTUE9UX0ZMSVBfWCIsIkhPVFNQT1RfRkxJUF9ZIiwiRVZFTlRTIiwiUkVBRFkiLCJMT0FEX1NUQVJUIiwiUFJPSkVDVElPTl9DSEFOR0UiLCJCRUZPUkVfUkVOREVSIiwiUkVOREVSIiwiSU5QVVRfU1RBUlQiLCJJTlBVVF9FTkQiLCJWSUVXX0NIQU5HRSIsIlNUQVRJQ19DTElDSyIsIlZSX1NUQVJUIiwiVlJfRU5EIiwiRUFTSU5HIiwiTElORUFSIiwieCIsIlNJTkVfV0FWRSIsIk1hdGgiLCJzaW4iLCJQSSIsIkVBU0VfT1VUX0NVQklDIiwicG93IiwiRUFTRV9PVVRfQk9VTkNFIiwibjEiLCJkMSIsIl9hIiwiQ0FNRVJBX0VWRU5UUyIsIkNIQU5HRSIsIkFOSU1BVElPTl9FTkQiLCJPQkpFQ1RfM0RfRVZFTlRTIiwiVVBEQVRFIiwiQ09OVFJPTF9FVkVOVFMiLCJFTkFCTEUiLCJESVNBQkxFIiwiREVHX1RPX1JBRCIsIlJBRF9UT19ERUciLCJERUZBVUxUX0VBU0lORyIsIkRFRkFVTFRfQU5JTUFUSU9OX0RVUkFUSU9OIiwiSU5GSU5JVEVfUkFOR0UiLCJtaW4iLCJJbmZpbml0eSIsIm1heCIsIkRFRkFVTFRfUElUQ0hfUkFOR0UiLCJERUZBVUxUX1pPT01fUkFOR0UiLCJST1RBVEUiLCJWSURFT19USU1FX0NIQU5HRV9FVkVOVCIsIlNWR19OQU1FU1BBQ0UiLCJTRVNTSU9OX1ZSIiwiWFJfUkVGRVJFTkNFX1NQQUNFIiwiRVBTSUxPTiIsIk51bWJlciIsImlzU3RyaW5nIiwiaXNFbGVtZW50Iiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInRhZyIsImVsIiwiZG9jdW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJnZXROdWxsYWJsZUVsZW1lbnQiLCJwYXJlbnQiLCJ0YXJnZXRFbCIsInBhcmVudEVsIiwicXVlcnlSZXN1bHQiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0RWxlbWVudCIsImZpbmRDYW52YXMiLCJyb290Iiwic2VsZWN0b3IiLCJjYW52YXMiLCJyYW5nZSIsImVuZCIsIkFycmF5IiwidW5kZWYiLCJpZHgiLCJjbGFtcCIsImxlcnAiLCJhIiwiYiIsInQiLCJjaXJjdWxhdGUiLCJzaXplIiwiYWJzIiwib2Zmc2V0IiwiZmluZEluZGV4IiwiYXJyYXkiLCJjaGVja2VyIiwibGVuZ3RoIiwiZ2V0T2JqZWN0T3B0aW9uIiwidG9WZXJ0aWNhbEZvdiIsImZvdlJhZGlhbiIsImFzcGVjdCIsImF0YW4iLCJ0YW4iLCJyZW9yZGVyQ3ViZSIsImFyciIsIm9yZGVyIiwiZGVmYXVsdE9yZGVyIiwic3BsaXQiLCJmYWNlIiwiaW5kZXhPZiIsImluZGV4IiwiaXNGdWxsc2NyZWVuIiwia2V5Iiwic2Vuc29yQ2FuQmVFbmFibGVkSU9TIiwid2luZG93IiwiaXNTZWN1cmVDb250ZXh0IiwiRGV2aWNlTW90aW9uRXZlbnQiLCJoZm92VG9ab29tIiwiYmFzZUZvdiIsImZvdiIsInJlbmRlcmluZ1dpZHRoIiwiem9vbWVkV2lkdGgiLCJldWxlclRvUXVhdCIsIm91dCIsInlhdyIsInBpdGNoIiwicm9sbCIsImlkZW50aXR5IiwicGl0Y2hUaHJlc2hvbGQiLCJwaXRjaENsYW1wZWQiLCJyb3RhdGVZIiwicm90YXRlWCIsInJvdGF0ZVoiLCJxdWF0VG9FdWxlciIsInF1YXRlcm5pb24iLCJ5IiwieiIsInciLCJ4MiIsInkyIiwiejIiLCJ3MiIsInVuaXQiLCJ0ZXN0IiwiYXRhbjIiLCJ2aWV3IiwiZnJvbVZhbHVlcyIsInVwIiwidHJhbnNmb3JtUXVhdCIsInZpZXdYWiIsInNxcnQiLCJNb3Rpb24iLCJfdmFsIiwic3RhcnQiLCJfc3RhcnQiLCJfZW5kIiwicHJvZ3Jlc3MiLCJfcHJvZ3Jlc3MiLCJhY3RpdmF0ZWQiLCJfYWN0aXZhdGVkIiwiZHVyYXRpb24iLCJfZHVyYXRpb24iLCJsb29wIiwiX2xvb3AiLCJfcmFuZ2UiLCJlYXNpbmciLCJfZWFzaW5nIiwicmVzZXQiLCJ1cGRhdGUiLCJkZWx0YVRpbWUiLCJwcmV2IiwibmV4dFByb2dyZXNzIiwiZWFzZWRQcm9ncmVzcyIsImRlZmF1bHRWYWwiLCJkZWx0YSIsInNldE5ld0VuZEJ5RGVsdGEiLCJzZXRSYW5nZSIsIkNhbWVyYUFuaW1hdGlvbiIsIl9tb3Rpb24iLCJjYW1lcmEiLCJmcm9tIiwidG8iLCJfY2FtZXJhIiwiX2Zyb20iLCJfdG8iLCJfZmluaXNoUHJvbWlzZSIsIl9maW5pc2giLCJnZXRGaW5pc2hQcm9taXNlIiwibW90aW9uIiwicm90YXRpb24iLCJjcmVhdGUiLCJ6b29tIiwic2xlcnAiLCJyb3RhdGUiLCJDYW1lcmEiLCJfYXNwZWN0IiwiY2hhbmdlZCIsIl9jaGFuZ2VkIiwieWF3UmFuZ2UiLCJfaW5pdGlhbFlhd1JhbmdlIiwicGl0Y2hSYW5nZSIsIl9pbml0aWFsUGl0Y2hSYW5nZSIsInpvb21SYW5nZSIsIl9pbml0aWFsWm9vbVJhbmdlIiwiaW5pdGlhbFlhdyIsImluaXRpYWxQaXRjaCIsImluaXRpYWxab29tIiwicm9sbE9mZnNldCIsInBvc2l0aW9uIiwiYW5pbWF0aW9uIiwiX3VwIiwiX3lhd1JhbmdlIiwiX3BpdGNoUmFuZ2UiLCJfem9vbVJhbmdlIiwiX3VwZGF0ZVF1YXRlcm5pb24iLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsIl9tYXhSZW5kZXJIZWlnaHQiLCJkZXN0cm95Iiwib2ZmIiwicmVzaXplIiwid2lkdGgiLCJoZWlnaHQiLCJwcmV2QXNwZWN0IiwidXBkYXRlTWF0cml4IiwibG9va0F0IiwicHJldlF1YXRlcm5pb24iLCJjbG9uZSIsInByZXZab29tIiwiem9vbURpZmYiLCJlcXVhbHMiLCJub3JtYWxpemVkIiwibm9ybWFsaXplIiwiaXNTYW1lUm90YXRpb24iLCJjb3B5IiwiYW5pbWF0ZVRvIiwiZmluaXNoUHJvbWlzZSIsInRyaWdnZXIiLCJyZXN0cmljdFlhd1JhbmdlIiwicmVzdHJpY3RQaXRjaFJhbmdlIiwicmVzdHJpY3Rab29tUmFuZ2UiLCJyZXN0cmljdFJlbmRlckhlaWdodCIsInJlc2V0UmFuZ2UiLCJnZXRZYXdSYW5nZSIsInlhd0xpbWl0IiwibWF4UmVuZGVySGVpZ2h0IiwiaGFsZkhGb3YiLCJnZXRIb3Jpem9udGFsRm92IiwibWluWWF3IiwibWF4WWF3IiwiaGFsZlZGb3ZSYWQiLCJoIiwiZCIsInRoZXRhIiwiZ2V0UGl0Y2hSYW5nZSIsInBpdGNoTGltaXQiLCJtaW5QaXRjaCIsIm1heFBpdGNoIiwiaGFsZlZGb3YiLCJnZXRWZXJ0aWNhbEZvdiIsImdldFpvb21SYW5nZSIsImxpbWl0IiwibWluRm92IiwibWF4Rm92IiwiY3VycmVudEZvdiIsImN1cnJlbnQiLCJfZ2V0Wm9vbWVkSG9yaXpvbnRhbEZvdiIsImhGb3YiLCJ2Rm92IiwiZm92VG9ab29tIiwicHJvak1hdHJpeCIsInVwRGlyIiwidmlld0RpciIsInBlcnNwZWN0aXZlIiwib25GcmFtZVJlbmRlciIsIk1vdXNlSW5wdXQiLCJfb25Nb3VzZURvd24iLCJldnQiLCJfZWwiLCJidXR0b24iLCJwcmV2ZW50RGVmYXVsdCIsImZvY3VzIiwiX3ByZXZQb3MiLCJjbGllbnRYIiwiY2xpZW50WSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25Nb3VzZU1vdmUiLCJfb25Nb3VzZVVwIiwic3JjRXZlbnQiLCJpc1RvdWNoIiwiaXNLZXlib2FyZCIsInByZXZQb3MiLCJkZWx0YVgiLCJkZWx0YVkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2Nyb2xsaW5nIiwiZW5hYmxlIiwiZWxlbWVudCIsImRpc2FibGUiLCJUb3VjaElucHV0Iiwic2Nyb2xsYWJsZSIsIl9zY3JvbGxhYmxlIiwiX29uVG91Y2hTdGFydCIsInRvdWNoZXMiLCJfc2Nyb2xsaW5nIiwidG91Y2giLCJfaXNGaXJzdFRvdWNoIiwiX29uVG91Y2hNb3ZlIiwiY2FuY2VsYWJsZSIsIl9vblRvdWNoRW5kIiwicGFzc2l2ZSIsIktleWJvYXJkSW5wdXQiLCJhY3RpdmUiLCJwcmVzc2VkIiwiX3ByZXNzZWQiLCJfb25LZXlEb3duIiwibG9jYXRpb24iLCJLZXlib2FyZEV2ZW50IiwiRE9NX0tFWV9MT0NBVElPTl9TVEFOREFSRCIsIl91cGRhdGVLZXlQcmVzcyIsInByZXNzZWRDb3VudCIsIl9nZXRQcmVzc2VkS2V5Q291bnQiLCJyZXBlYXQiLCJfb25LZXlVcCIsIl9jbGVhclByZXNzZWRLZXlzIiwiX2dldERlbHRhQnlQcmVzc2VkS2V5cyIsInJlZHVjZSIsIm9iaiIsImtleU5hbWUiLCJhc3NpZ24iLCJldmVudCIsImlzRW5hYmxlIiwia2V5VG9VcGRhdGUiLCJrZXlDb2RlIiwiZmlsdGVyIiwiUm90YXRlQ29udHJvbCIsImVuYWJsZWQiLCJfZW5hYmxlZCIsImVuYWJsZUJsb2NrZWQiLCJfZW5hYmxlQmxvY2tlZCIsImFuaW1hdGluZyIsIl9rZXlib2FyZElucHV0IiwiX3hNb3Rpb24iLCJfeU1vdGlvbiIsIl90b3VjaElucHV0IiwicG9pbnRlclNjYWxlIiwiX3BvaW50ZXJTY2FsZSIsImtleWJvYXJkU2NhbGUiLCJfa2V5Ym9hcmRTY2FsZSIsImRpc2FibGVQaXRjaCIsIl9kaXNhYmxlUGl0Y2giLCJkaXNhYmxlWWF3IiwiX2Rpc2FibGVZYXciLCJkaXNhYmxlS2V5Ym9hcmQiLCJfZGlzYWJsZUtleWJvYXJkIiwiY29udHJvbEVsIiwiX29uSW5wdXRTdGFydCIsIl9jaGFuZ2VkV2hpbGVEcmFnZ2luZyIsImlucHV0VHlwZSIsIl9vbkNoYW5nZSIsImludlpvb21TY2FsZSIsIl96b29tU2NhbGUiLCJzY3JlZW5TY2FsZSIsIl9zY3JlZW5TY2FsZSIsInNjYWxlIiwic2NhbGVkWCIsInNjYWxlZFkiLCJfb25JbnB1dEVuZCIsIl9jb250cm9sRWwiLCJfbW91c2VJbnB1dCIsIl9iaW5kSW5wdXRzIiwieE1vdGlvbiIsInlNb3Rpb24iLCJrZXlib2FyZElucHV0IiwidXBkYXRlUmFuZ2UiLCJzZXRab29tU2NhbGUiLCJoZm92IiwidmZvdiIsImNvbnRyb2wiLCJ1cGRhdGVDdXJzb3IiLCJzeW5jIiwibW91c2VJbnB1dCIsInRvdWNoSW5wdXQiLCJvbiIsIldoZWVsSW5wdXQiLCJfb25XaGVlbCIsInN0b3BQcm9wYWdhdGlvbiIsIl9pbnB1dFRpbWVyIiwiX2NsZWFyVGltZXIiLCJfYmFzZVNjYWxlIiwic2V0VGltZW91dCIsImNhcHR1cmUiLCJjbGVhclRpbWVvdXQiLCJQaW5jaElucHV0IiwicHJldkRpc3RhbmNlIiwiX3ByZXZEaXN0YW5jZSIsImRpZmYiLCJwYWdlWCIsInBhZ2VZIiwiZGlzdGFuY2UiLCJab29tQ29udHJvbCIsIl93aGVlbElucHV0IiwiX3NjYWxlIiwic2NhbGVkRGVsdGEiLCJfcGluY2hJbnB1dCIsIndoZWVsSW5wdXQiLCJwaW5jaElucHV0IiwiUk9UQVRFX0NPTlNUQU5UIiwiUElUQ0hfREVMVEEiLCJZQVdfREVMVEFfQllfUk9MTCIsIllBV19ERUxUQV9CWV9ZQVciLCJ0YXJnZXRBeGlzIiwibWVzaFBvaW50IiwiR3lyb0lucHV0Iiwib3JpZW50YXRpb25VcGRhdGVkIiwiX29yaWVudGF0aW9uVXBkYXRlZCIsImlnbm9yZVJvbGwiLCJfaWdub3JlUm9sbCIsIl9vbkRldmljZU9yaWVudGF0aW9uIiwicHJldk9yaWVudGF0aW9uIiwiX29yaWVudGF0aW9uIiwiYWxwaGEiLCJiZXRhIiwiZ2FtbWEiLCJfbmVlZHNDYWxpYnJhdGUiLCJfY2FsaWJyYXRlU2Vuc29yIiwiX3VwZGF0ZVNjcmVlbk9yaWVudGF0aW9uIiwic2NyZWVuIiwib3JpZW50YXRpb24iLCJhbmdsZSIsInVuZGVmaW5lZCIsIl9zY3JlZW5PcmllbnRhdGlvbiIsIl95YXdPcmlnaW4iLCJfeWF3T2Zmc2V0IiwiX3VwZGF0ZVJvdGF0aW9uIiwiY29sbGVjdERlbHRhIiwicHJldlJvdGF0aW9uIiwiX3RvRXVsZXJEZWx0YSIsInNldEluaXRpYWxSb3RhdGlvbiIsInlhd09yaWdpbiIsInNlbnNvcllhdyIsInNjcmVlbkFuZ2xlIiwid29ybGQiLCJzZXQiLCJjb3MiLCJtdWx0aXBseSIsInByZXZRdWF0IiwiY3VycmVudFF1YXQiLCJfZ2V0RGVsdGFZYXciLCJfZ2V0RGVsdGFQaXRjaCIsInBydlEiLCJjdXJRIiwieWF3RGVsdGFCeVlhdyIsIl9nZXRSb3RhdGlvbkRlbHRhIiwieWF3RGVsdGFCeVJvbGwiLCJfZXh0cmFjdFBpdGNoRnJvbVF1YXQiLCJwcmV2USIsInJvdGF0ZUtpbmQiLCJjdXJRdWF0ZXJuaW9uIiwicHJldlBvaW50IiwiY3VyUG9pbnQiLCJyb3RhdGVEaXN0YW5jZSIsImRvdCIsImNyb3NzIiwicm90YXRlRGlyZWN0aW9uIiwibWVzaFBvaW50MiIsIm1lc2hQb2ludDMiLCJ2ZWNVIiwidmVjViIsInZlY04iLCJjb2VmZmljaWVudEEiLCJjb2VmZmljaWVudEIiLCJjb2VmZmljaWVudEMiLCJwcm9qZWN0ZWRQcmV2UG9pbnQiLCJzdWJ0cmFjdCIsInRyaWdvbm9tZXRyaWNSYXRpbyIsImFjb3MiLCJjcm9zc1ZlYyIsInRoZXRhRGlyZWN0aW9uIiwiZGVsdGFSYWRpYW4iLCJiYXNlViIsIkd5cm9Db250cm9sIiwiX2lucHV0IiwiaXNBdmFpbGFibGUiLCJvbkRldmljZU1vdGlvbkNoYW5nZSIsImxpc3RlbkRldmljZU1vdGlvbiIsInJlcyIsInJvdGF0aW9uUmF0ZSIsInRpbWVvdXQiLCJyYWNlIiwiYXZhaWxhYmxlIiwicmVxdWVzdFNlbnNvclBlcm1pc3Npb24iLCJyZXF1ZXN0UGVybWlzc2lvbiIsInBlcm1pc3Npb25TdGF0ZSIsImNhdGNoIiwiX3VwZGF0ZVlhd1BpdGNoIiwiaW5wdXQiLCJ5YXdEZWx0YSIsInBpdGNoRGVsdGEiLCJQYW5vQ29udHJvbCIsInVzZUdyYWJDdXJzb3IiLCJfdXNlR3JhYkN1cnNvciIsIl9zZXRDdXJzb3IiLCJkaXNhYmxlQ29udGV4dE1lbnUiLCJfZGlzYWJsZUNvbnRleHRNZW51IiwiX2Jsb2NrQ29udGV4dE1lbnUiLCJfcmVzdG9yZUNvbnRleHRNZW51IiwiX3JvdGF0ZUNvbnRyb2wiLCJ3aGVlbFNjcm9sbGFibGUiLCJfem9vbUNvbnRyb2wiLCJpZ25vcmVab29tU2NhbGUiLCJfaWdub3JlWm9vbVNjYWxlIiwiZ3lybyIsIl9neXJvQ29udHJvbCIsIl9wcmV2ZW50Q29udGV4dE1lbnUiLCJfb25FbmFibGUiLCJfb25EaXNhYmxlIiwiX29uQ2FtZXJhQW5pbWF0aW9uRW5kIiwiX2JpbmRFdmVudHMiLCJyb3RhdGVDb250cm9sIiwiem9vbUNvbnRyb2wiLCJneXJvQ29udHJvbCIsInpvb21TY2FsZSIsIm5ld0N1cnNvciIsInN0eWxlIiwiY3Vyc29yIiwiVGV4dHVyZSIsImZsaXBZIiwid3JhcFMiLCJXZWJHTFJlbmRlcmluZ0NvbnRleHQiLCJDTEFNUF9UT19FREdFIiwid3JhcFQiLCJpc1ZpZGVvIiwiaXNDdWJlIiwiVGV4dHVyZTJEIiwic291cmNlIiwiVGV4dHVyZVZpZGVvIiwidmlkZW8iLCJwYXVzZSIsInJlbW92ZUF0dHJpYnV0ZSIsImxvYWQiLCJpc1BhdXNlZCIsInBhdXNlZCIsImVuZGVkIiwicmVhZHlTdGF0ZSIsImhhc0F1ZGlvIiwiYXVkaW9UcmFja3MiLCJ3ZWJraXRBdWRpb0RlY29kZWRCeXRlQ291bnQiLCJtb3pIYXNBdWRpbyIsIlRleHR1cmVDdWJlIiwic291cmNlcyIsIlRleHR1cmVMb2FkZXIiLCJfbG9hZENoZWNrZXIiLCJzcmMiLCJsb2FkVmlkZW8iLCJpc0FycmF5IiwibG9hZEN1YmVJbWFnZSIsImltZ1NyYyIsImxvYWRJbWFnZSIsImltYWdlcyIsIl90b0ltYWdlQXJyYXkiLCJfbG9hZCIsImltYWdlIiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsInZpZGVvQ29uZmlnIiwiY29uZmlnIiwiYXV0b3BsYXkiLCJtdXRlZCIsInZvbHVtZSIsIl90b1ZpZGVvRWxlbWVudCIsImN1cnJlbnRUaW1lIiwicGxheSIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImNvbnRlbnQiLCJvbkxvYWQiLCJsb2FkZXIiLCJvbmNlIiwiZXJyb3JDb3VudCIsImNoZWNrIiwic3JjcyIsImltZ0VsIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIkhUTUxWaWRlb0VsZW1lbnQiLCJwbGF5c0lubGluZSIsInNldEF0dHJpYnV0ZSIsImZvckVhY2giLCJfYXBwZW5kU291cmNlRWxlbWVudCIsInNvdXJjZUNvdW50IiwicXVlcnlTZWxlY3RvckFsbCIsIkhUTUxTb3VyY2VFbGVtZW50Iiwic291cmNlRWwiLCJhcHBlbmRDaGlsZCIsIkZyYW1lQW5pbWF0b3IiLCJtYXhEZWx0YVRpbWUiLCJjb250ZXh0IiwiX2NvbnRleHQiLCJfcmFmSWQiLCJfcmFmVGltZXIiLCJfbGFzdFVwZGF0ZVRpbWUiLCJjYWxsYmFjayIsIl90aW1lIiwiZnJhbWUiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0b3AiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNoYW5nZUNvbnRleHQiLCJBdXRvUmVzaXplciIsInVzZVJlc2l6ZU9ic2VydmVyIiwiX3VzZVJlc2l6ZU9ic2VydmVyIiwib25SZXNpemUiLCJfc2tpcEZpcnN0UmVzaXplIiwiaXNGaXJzdFJlc2l6ZSIsIl9vblJlc2l6ZSIsIl9yZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiYmJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJlc2l6ZUltbWVkaWF0ZSIsInJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJBdXRvcGxheSIsInBsYXlpbmciLCJfaW50ZXJydXB0ZWQiLCJkZWxheSIsIl9kZWxheSIsImRlbGF5T25Nb3VzZUxlYXZlIiwiX2RlbGF5T25Nb3VzZUxlYXZlIiwic3BlZWQiLCJfc3BlZWQiLCJwYXVzZU9uSG92ZXIiLCJfcGF1c2VPbkhvdmVyIiwiY2FuSW50ZXJydXB0IiwiX2NhbkludGVycnVwdCIsImRpc2FibGVPbkludGVycnVwdCIsIl9kaXNhYmxlT25JbnRlcnJ1cHQiLCJ2aWV3ZXIiLCJvcHRpb25zIiwiX2NsZWFyVGltZW91dCIsIl9zZXRVbmludGVycnVwdGVkQWZ0ZXJEZWxheSIsIl9vbkd5cm9FbmFibGUiLCJfb25Nb3VzZUVudGVyIiwiX2hvdmVyaW5nIiwiX29uTW91c2VMZWF2ZSIsIl9jb250cm9sIiwiX2VsZW1lbnQiLCJfaW50ZXJydXB0aW9uVGltZXIiLCJlbmFibGVBZnRlckRlbGF5IiwiWFJNYW5hZ2VyIiwiY3R4IiwiZXhpdCIsIl9vblNlc3Npb25FbmQiLCJfeHJTZXNzaW9uIiwiX3hyUmVmU3BhY2UiLCJfY3R4IiwiX29wdGlvbnMiLCJ4ciIsIm5hdmlnYXRvciIsImlzU2Vzc2lvblN1cHBvcnRlZCIsImVudGVyIiwicmVxdWlyZWRGZWF0dXJlcyIsIm1ha2VYUkNvbXBhdGlibGUiLCJzZXNzaW9uIiwicmVxdWVzdFNlc3Npb24iLCJiaW5kWFJMYXllciIsInJlZlNwYWNlIiwicmVxdWVzdFJlZmVyZW5jZVNwYWNlIiwiX3NldFNlc3Npb24iLCJ4clNlc3Npb24iLCJjYW5SZW5kZXIiLCJwb3NlIiwiZ2V0Vmlld2VyUG9zZSIsImdldEV5ZVBhcmFtcyIsImdsTGF5ZXIiLCJyZW5kZXJTdGF0ZSIsImJhc2VMYXllciIsInZpZXdzIiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsInZNYXRyaXgiLCJ0cmFuc2Zvcm0iLCJpbnZlcnNlIiwibWF0cml4IiwicE1hdHJpeCIsIkhvdHNwb3QiLCJIb3RzcG90UmVuZGVyZXIiLCJyb290RWwiLCJyZW5kZXJlciIsIl9jb250YWluZXJFbCIsIl9yZW5kZXJlciIsIl9ob3RzcG90cyIsIl96b29tIiwicmVmcmVzaCIsImNvbnRhaW5lciIsImhvdHNwb3RFbHMiLCJzbGljZSIsIl9wYXJzZUhvdHNwb3QiLCJyZW5kZXIiLCJob3RzcG90cyIsImhhbGZXaWR0aCIsImhhbGZIZWlnaHQiLCJjZW50ZXJUcmFuc2Zvcm0iLCJ6b29tVHJhbnNmb3JtIiwiaG90c3BvdCIsInJlbFBvcyIsInRyYW5zZm9ybU1hdDQiLCJyZW1vdmUiLCJzY3JlZW5Qb3MiLCJ5YXdTdHIiLCJkYXRhc2V0IiwicGl0Y2hTdHIiLCJwb3NpdGlvblN0ciIsInBhcnNlRmxvYXQiLCJfeWF3UGl0Y2hUb1ZlYzMiLCJwb3MiLCJkZWZhdWx0UG9zIiwieWF3UmFkIiwicGl0Y2hSYWQiLCJWZXJ0ZXhBcnJheU9iamVjdCIsImNvdW50IiwiZ2VvbWV0cnkiLCJpbmRpY2llcyIsImJ1ZmZlcnMiLCJXZWJHTENvbnRleHQiLCJfY2FudmFzIiwibWF4VGV4dHVyZVNpemUiLCJfbWF4VGV4dHVyZVNpemUiLCJpc1dlYkdMMiIsIl9pc1dlYkdMMiIsInN1cHBvcnRWQU8iLCJfZXh0ZW5zaW9ucyIsInZhbyIsImxvc3QiLCJfY29udGV4dExvc3QiLCJkZWJ1ZyIsIl9kZWJ1ZyIsIl9vbkNvbnRleHRMb3N0IiwiX29uQ29udGV4dFJlc3RvcmUiLCJsb3NlQ29udGV4dCIsImluaXQiLCJnbCIsIl9nZXRDb250ZXh0IiwiX2dsIiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1RFWFRVUkVfU0laRSIsImdldEV4dGVuc2lvbiIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsImZvcmNlTG9zZUNvbnRleHQiLCJleHRlbnNpb24iLCJmb3JjZVJlc3RvcmVDb250ZXh0IiwicmVzdG9yZUNvbnRleHQiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJkcmF3aW5nQnVmZmVyV2lkdGgiLCJkcmF3aW5nQnVmZmVySGVpZ2h0IiwiY3JlYXRlVkFPIiwic2hhZGVyUHJvZ3JhbSIsIm5hdGl2ZVZBTyIsIl9jcmVhdGVOYXRpdmVWQU8iLCJfY3JlYXRlQnVmZmVyIiwidXYiLCJfYmluZE5hdGl2ZVZBTyIsIl9zdXBwbHlHZW9tZXRyeURhdGEiLCJfdW5iaW5kQnVmZmVycyIsImRyYXciLCJkcmF3RWxlbWVudHMiLCJUUklBTkdMRVMiLCJVTlNJR05FRF9TSE9SVCIsInJlbGVhc2VWQU8iLCJfZGVsZXRlTmF0aXZlVkFPIiwiX2RlbGV0ZUJ1ZmZlciIsImdldFVuaWZvcm1Mb2NhdGlvbnMiLCJwcm9ncmFtIiwidW5pZm9ybXMiLCJ1bmlmb3JtTG9jYXRpb25zIiwia2V5cyIsImxvY2F0aW9ucyIsImdldFVuaWZvcm1Mb2NhdGlvbiIsIl9nZXRDb21tb25Vbmlmb3JtTG9jYXRpb25zIiwidXBkYXRlQ29tbW9uVW5pZm9ybXMiLCJlbnRpdHkiLCJtdk1hdHJpeCIsInVuaWZvcm1NYXRyaXg0ZnYiLCJ1TVZNYXRyaXgiLCJ1UE1hdHJpeCIsInVwZGF0ZVZSVW5pZm9ybXMiLCJleWVJbmRleCIsInVFeWUiLCJ1bmlmb3JtMWYiLCJ1cGRhdGVVbmlmb3JtcyIsInVuaWZvcm0iLCJuZWVkc1VwZGF0ZSIsInJlbGVhc2VTaGFkZXJSZXNvdXJjZXMiLCJkZWxldGVQcm9ncmFtIiwidXNlUHJvZ3JhbSIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsInZzIiwiX2NvbXBpbGVTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZnMiLCJGUkFHTUVOVF9TSEFERVIiLCJhdHRhY2hTaGFkZXIiLCJiaW5kQXR0cmliTG9jYXRpb24iLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiZ2V0U2hhZGVySW5mb0xvZyIsImdldFByb2dyYW1JbmZvTG9nIiwiZGVsZXRlU2hhZGVyIiwiY3JlYXRlV2ViR0xUZXh0dXJlIiwidGV4RGF0YSIsInRleHR1cmUiLCJjcmVhdGVUZXh0dXJlIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiVEVYVFVSRV9XUkFQX1QiLCJnbDIiLCJ0ZXhTdG9yYWdlMkQiLCJSR0JBOCIsImNyZWF0ZVdlYkdMQ3ViZVRleHR1cmUiLCJURVhUVVJFX0NVQkVfTUFQIiwiYXR0cmlidXRlcyIsImdldENvbnRleHRBdHRyaWJ1dGVzIiwieHJDb21wYXRpYmxlIiwieHJMYXllciIsIlhSV2ViR0xMYXllciIsInVwZGF0ZVJlbmRlclN0YXRlIiwiYmluZFhSRnJhbWUiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImZyYW1lYnVmZmVyIiwidXNlRGVmYXVsdEZyYW1lQnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwiYnVmZmVyIiwiZGVsZXRlQnVmZmVyIiwiY3JlYXRlVmVydGV4QXJyYXkiLCJleHQiLCJjcmVhdGVWZXJ0ZXhBcnJheU9FUyIsImJpbmRWZXJ0ZXhBcnJheSIsImJpbmRWZXJ0ZXhBcnJheU9FUyIsImRlbGV0ZVZlcnRleEFycmF5IiwiZGVsZXRlVmVydGV4QXJyYXlPRVMiLCJfc3VwcGx5SW5kaWNpZXNEYXRhIiwiX3N1cHBseUF0dHJpYnV0ZURhdGEiLCJ2ZXJ0aWNlcyIsInV2cyIsImJ1ZmZlckRhdGEiLCJkYXRhIiwiU1RBVElDX0RSQVciLCJhdHRyaWJ1dGUiLCJhdHRyaWJMb2NhdGlvbiIsImdldEF0dHJpYkxvY2F0aW9uIiwidmVydGV4QXR0cmliUG9pbnRlciIsIml0ZW1TaXplIiwiRkxPQVQiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInNoYWRlciIsImNyZWF0ZVNoYWRlciIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJ3ZWJnbElkZW50aWZpZXJzIiwiY29udGV4dEF0dHJpYnV0ZXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJhbnRpYWxpYXMiLCJvbldlYmdsQ29udGV4dENyZWF0aW9uRXJyb3IiLCJzdGF0dXNNZXNzYWdlIiwiaWRlbnRpZmllciIsImdldENvbnRleHQiLCJXZWJHTFJlbmRlcmVyIiwiX2VsZW1lbnRTaXplIiwicGl4ZWxSYXRpbyIsIl9waXhlbFJhdGlvIiwiY2FudmFzU2l6ZSIsImRldmljZVBpeGVsUmF0aW8iLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIm1lc2giLCJyZW5kZXJWUiIsInZyIiwiZXllUGFyYW1zIiwiZXllIiwiVmlldzM2MCIsIl9yb290RWwiLCJfdnIiLCJfaG90c3BvdCIsInBsdWdpbnMiLCJfcGx1Z2lucyIsInByb2plY3Rpb24iLCJfcHJvamVjdGlvbiIsIl9pbml0aWFsaXplZCIsIl9tZXNoIiwiaW5pdGlhbGl6ZWQiLCJfYXV0b3BsYXkiLCJhdXRvSW5pdCIsIl9hdXRvSW5pdCIsImF1dG9SZXNpemUiLCJfYXV0b1Jlc2l6ZSIsImNhbnZhc1NlbGVjdG9yIiwiX2NhbnZhc1NlbGVjdG9yIiwidGFiSW5kZXgiLCJfdGFiSW5kZXgiLCJfYW5pbWF0b3IiLCJ1cGRhdGVDYW1lcmEiLCJyZW5kZXJGcmFtZSIsImF1dG9QbGF5ZXIiLCJfZW1pdCIsIl9yZW5kZXJGcmFtZU9uRGVtYW5kIiwiZ2V0VGV4dHVyZSIsIl9yZW5kZXJWUkZyYW1lIiwiX2RlbHRhIiwiX2F1dG9SZXNpemVyIiwiX2FkZEV2ZW50SGFuZGxlcnMiLCJwbHVnaW4iLCJhbmltYXRvciIsIl9iaW5kQ29tcG9uZW50RXZlbnRzIiwiX3Jlc2l6ZUNvbXBvbmVudHMiLCJfbG9hZFRleHR1cmUiLCJfYXBwbHlQcm9qZWN0aW9uIiwiaGFzQXR0cmlidXRlIiwiYWRkUGx1Z2lucyIsInB1c2giLCJyZW1vdmVQbHVnaW5zIiwicGx1Z2luSWR4Iiwic3BsaWNlIiwiZXZlbnROYW1lIiwicGFyYW1zIiwiZXZ0UGFyYW1zIiwidGFyZ2V0IiwibmV3TWVzaCIsImNyZWF0ZU1lc2giLCJ1cGRhdGVDb250cm9sIiwiY29udGVudExvYWRlciIsImV2ZW50cyIsImV2dE5hbWUiLCJjb250cm9sRXZlbnRzVG9Qcm9wYWdhdGUiLCJWRVJTSU9OIiwiT2JqZWN0M0QiLCJmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlIiwiTG9hZGluZ1NwaW5uZXIiLCJfc3RhcnRMb2FkaW5nIiwiX2NvbnRhaW5lciIsIl9kZXRhY2hFbGVtZW50cyIsInBhcmVudEVsZW1lbnQiLCJyZW1vdmVDaGlsZCIsIl9jcmVhdGVFbGVtZW50cyIsInJpbmciLCJSSU5HIiwiQ29udHJvbEJhckl0ZW0iLCJDT05UUk9MX0JBUl9ERUZBVUxUX0NMQVNTIiwiQ09OVFJPTFNfUk9PVCIsIkNPTlRST0xTX0JHIiwiQ09OVFJPTFNfTUFJTiIsIkNPTlRST0xTX1RPUCIsIkNPTlRST0xTX0JPVFRPTSIsIkNPTlRST0xTX01JRCIsIkNPTlRST0xTX0xFRlQiLCJDT05UUk9MU19SSUdIVCIsIkNPTlRST0xTX0ZMT0FUX0xFRlQiLCJDT05UUk9MU19GTE9BVF9SSUdIVCIsIkNPTlRST0xTX0JVVFRPTiIsIlBST0dSRVNTX1JPT1QiLCJWT0xVTUVfUk9PVCIsIlJBTkdFX1JPT1QiLCJSQU5HRV9UUkFDSyIsIlJBTkdFX1RIVU1CIiwiUkFOR0VfRklMTEVSIiwiUExBWV9CVVRUT04iLCJQQVVTRV9CVVRUT04iLCJVTk1VVEVEX0JVVFRPTiIsIk1VVEVEX0JVVFRPTiIsIkZVTExTQ1JFRU5fQlVUVE9OIiwiRlVMTFNDUkVFTl9FWElUX0JVVFRPTiIsIlZSX0JVVFRPTiIsIkdZUk9fRU5BQkxFRCIsIkdZUk9fRElTQUJMRUQiLCJWSURFT19USU1FX0RJU1BMQVkiLCJQSUVWSUVXX1JPT1QiLCJGSVhFRCIsIlVOQVZBSUxBQkxFIiwiSElEREVOIiwiQ09OVFJPTF9CQVJfSVRFTV9QT1NJVElPTiIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiTUFJTl9UT1AiLCJNQUlOX0JPVFRPTSIsIk1BSU5fTEVGVCIsIk1BSU5fUklHSFQiLCJSYW5nZUNvbnRyb2wiLCJfb25Ib2xkIiwiX2Jib3giLCJlbFgiLCJzY3JvbGxYIiwicGFnZVhPZmZzZXQiLCJjbGFtZXBkWCIsInRodW1iRWwiLCJfZml4ZWRDbGFzcyIsImNsYW1wZWRYIiwiX29uUmVsZWFzZSIsInRyYWNrIiwidGh1bWIiLCJmaWxsZXIiLCJkcmFnZ2FibGUiLCJ0cmFja0VsIiwiZmlsbGVyRWwiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ0b3AiLCJ1cGRhdGVTdHlsZSIsImNsYW1wZWRQcm9ncmVzcyIsIlByb2dyZXNzQmFyIiwiX3JhbmdlQ29udHJvbCIsIl9vblRpbWVVcGRhdGUiLCJfdmlkZW8iLCJfY3VycmVudFRpbWUiLCJfb25EdXJhdGlvbkNoYW5nZSIsImNvbnRyb2xCYXIiLCJfY29udHJvbEJhciIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsIl93YXNQYXVzZWQiLCJfcGxheVByb21pc2UiLCJfb25Db250cm9sIiwicmFuZ2VDb250cm9sIiwidW5hdmFpbGFibGVDbGFzcyIsIlBsYXlCdXR0b24iLCJfb25DbGljayIsIl9wYXVzZWQiLCJfb25QbGF5IiwidGl0bGUiLCJfb25QYXVzZSIsIlZvbHVtZUNvbnRyb2wiLCJfdXBkYXRlRGlzcGxheSIsImRpc2FibGVkIiwiX29uVm9sdW1lQ2hhbmdlIiwiX2J1dHRvbkVsIiwiY29udGFpbmVyRWwiLCJidXR0b25FbCIsIkZ1bGxzY3JlZW5CdXR0b24iLCJfdGFyZ2V0RWwiLCJfZXhpdEZ1bGxzY3JlZW4iLCJfcmVxdWVzdEZ1bGxzY3JlZW4iLCJfb25GdWxsc2NyZWVuQ2hhbmdlIiwiX2Z1bGxzY3JlZW5BdmFpbGFibGUiLCJfYWRkRnVsbHNjcmVlbkhhbmRsZXJzIiwiX3JlbW92ZUZ1bGxzY3JlZW5IYW5kbGVycyIsInNvbWUiLCJyZXF1ZXN0IiwiY2FsbCIsIlZpZGVvVGltZSIsIl9vbkN1c3RvbVRpbWVDaGFuZ2UiLCJ0aW1lTWludXRlIiwiZmxvb3IiLCJ0aW1lU2Vjb25kcyIsInRpbWVTZWNvbmRzRm9ybWF0dGVkIiwiZHVyYXRpb25NaW51dGUiLCJkdXJhdGlvblNlY29uZHMiLCJkdXJhdGlvblNlY29uZHNGb3JtYXR0ZWQiLCJpbm5lclRleHQiLCJQaWVWaWV3IiwicmVzZXRDYW1lcmEiLCJfdmlld2VyIiwiX3VwZGF0ZVBpZSIsInBpZVBhdGgiLCJfcGllUGF0aEVsIiwicmFuZ2VDaXJjbGUiLCJfcmFuZ2VDaXJjbGVFbCIsImhhbGZGb3YiLCJwaWVSYWRpdXMiLCJwaWVEZWciLCJwaWVPZmZzZXQiLCJpc0Zpbml0ZSIsInJhZGl1cyIsInJhbmdlRGlmZiIsIl9jcmVhdGVQaWVFbGVtZW50cyIsInJvb3RDbGFzcyIsInBpZVNWRyIsImNyZWF0ZUVsZW1lbnROUyIsIlZSQnV0dG9uIiwiR3lyb0J1dHRvbiIsIl91cGRhdGVTdHlsZSIsImVuYWJsZUJ1dHRvbiIsIkF1dG9IaWRlIiwiaGlkZGVuIiwiY29udGFpbnMiLCJfaGlkZGVuQ2xhc3MiLCJpbml0aWFsRGVsYXkiLCJpZGxlRGVsYXkiLCJhY3RpdmF0aW9uRGVsYXkiLCJfaXNDdXJzb3JJbnNpZGUiLCJzaG93IiwiX2hpZGVBZnRlckRlbGF5IiwiX2lzRnVsbHNjcmVlbiIsInNob3dUZW1wb3JhbGl5IiwiX2lzR3JhYmJpbmciLCJwb2ludGVyVHlwZSIsIl9vblZpZGVvUGxheSIsIl9vblZpZGVvUGF1c2UiLCJfaW5pdGlhbERlbGF5IiwiX2lkbGVEZWxheSIsIl90aW1lciIsImhpZGUiLCJfY2xlYXJIaWRlVGltZXIiLCJWaWRlb0NvbnRyb2wiLCJ2aWRlb0VsIiwia2V5UHJlc3NlZCIsIl9jaGFuZ2VWaWRlb1RpbWUiLCJfY2hhbmdlVmlkZW9Wb2x1bWUiLCJzcGFjZVByZXNzZWQiLCJfdG9nZ2xlVmlkZW8iLCJmb3J3YXJkIiwiaW5jcmVhc2UiLCJDb250cm9sQmFyIiwiYmFja2dyb3VuZEVsIiwiX2JnRWwiLCJpdGVtcyIsIl9pdGVtcyIsImN1c3RvbUl0ZW1zIiwiX2N1c3RvbUl0ZW1zIiwiYXV0b0hpZGUiLCJzaG93QmFja2dyb3VuZCIsImNsaWNrVG9QbGF5Iiwia2V5Ym9hcmRDb250cm9scyIsInByb2dyZXNzQmFyIiwicGxheUJ1dHRvbiIsInZvbHVtZUJ1dHRvbiIsImZ1bGxzY3JlZW5CdXR0b24iLCJ2aWRlb1RpbWUiLCJwaWVWaWV3IiwidnJCdXR0b24iLCJneXJvQnV0dG9uIiwiX29uU3RhdGljQ2xpY2siLCJhdXRvSGlkZXIiLCJfYXV0b0hpZGVyIiwiX29uTmV3U3JjTG9hZCIsIl91cGRhdGVCYWNrZ3JvdW5kIiwiX3VwZGF0ZUF1dG9IaWRlIiwiX3VwZGF0ZUtleWJvYXJkSGFuZGxlciIsImNhdGVnb3J5IiwiaXRlbSIsIl9jcmVhdGVQb3NpdGlvbldyYXBwZXJzIiwiUE9TSVRJT04iLCJfdmlkZW9Db250cm9sIiwicGFub1Jvb3QiLCJjb250cm9sc1Jvb3QiLCJkZWZhdWx0SXRlbXMiLCJfY3JlYXRlRGVmYXVsdEl0ZW1zIiwiX2FkZEl0ZW0iLCJfY2xlYXJJdGVtRWxlbWVudHMiLCJ3cmFwcGVyIiwiX3dyYXBwZXJFbCIsIm5leHRTaWJsaW5nSW5kZXgiLCJzaWJsaW5nIiwibmV4dFNpYmxpbmciLCJpbnNlcnRCZWZvcmUiLCJmbG9hdExlZnRFbCIsImZsb2F0UmlnaHRFbCIsInRvcFdyYXBwZXIiLCJib3R0b21XcmFwcGVyIiwibWlkV3JhcHBlciIsImxlZnRDb250cm9sc1dyYXBwZXIiLCJyaWdodENvbnRyb2xzV3JhcHBlciIsIndyYXBwZXJzIiwiZmlyc3RDaGlsZCIsIl9iIiwiYmFja2dyb3VuZCIsImhpZGRlbkNsYXNzIiwidmlkZW9Db250cm9sIiwiUHJvamVjdGlvbiIsIlVuaWZvcm0iLCJVbmlmb3JtVGV4dHVyZUN1YmUiLCJjdWJlbWFwT3JkZXIiLCJfd2ViZ2xUZXh0dXJlIiwiX2N1YmVtYXBPcmRlciIsImRlbGV0ZVRleHR1cmUiLCJwaXhlbFN0b3JlaSIsIlVOUEFDS19GTElQX1lfV0VCR0wiLCJ1bmlmb3JtMWkiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJ0ZXhTdWJJbWFnZTJEIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJ0ZXhJbWFnZTJEIiwiQ3ViZVRleHR1cmVQYWludGVyIiwiX3NpemUiLCJfcmVuZGVyaW5nT3JkZXIiLCJfY2FsY1JlbmRlcmluZ1NpemUiLCJzdXJmYWNlSWR4Iiwicm93IiwiX3JvdyIsImNvbHVtbiIsIl9jb2x1bW4iLCJyZW5kZXJpbmdGYWNlIiwiZHJhd0ltYWdlIiwiVW5pZm9ybUNhbnZhc0N1YmUiLCJfcGFpbnRlciIsIlRyaWFuZ2xlTWVzaCIsInVUZXh0dXJlIiwiU2hhZGVyUHJvZ3JhbSIsIlZlcnRleERhdGEiLCJHZW9tZXRyeSIsIkZsb2F0MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiQ3ViZUdlb21ldHJ5Iiwicm90YXRlVVYiLCJvbmVUaGlyZCIsImNvb3JkcyIsInIiLCJjIiwiY29vcmQiLCJkZWdyZWUiLCJaRVJPIiwibmV3T3JkZXIiLCJDV185MCIsIkNDV185MCIsIm5ld0Nvb3JkcyIsInV2SWR4IiwiYWNjIiwiY29uY2F0IiwidnMkMyIsImZzJDMiLCJDdWJlbWFwUHJvamVjdGlvbiIsImN1YmVtYXBGbGlwWCIsIl9jdWJlbWFwRmxpcFgiLCJVbmlmb3JtVGV4dHVyZTJEIiwidnMkMiIsImZzJDIiLCJDdWJlc3RyaXBQcm9qZWN0aW9uIiwiQ3lsaW5kZXJHZW9tZXRyeSIsIm1heFRoZXRhIiwicmFkaWFsU2VnbWVudHMiLCJoZWlnaHRTZWdtZW50cyIsImludlJhZGlhbFNlZ21lbnRzIiwiYW5nbGVDb25zdCIsInlJZHgiLCJsbmdJZHgiLCJ1IiwidiIsIkN5bGluZHJpY2FsUHJvamVjdGlvbiIsInBhcnRpYWwiLCJfcGFydGlhbCIsIl9oYWxmSGVpZ2h0IiwiY3lsaW5kZXJIZWlnaHQiLCJjeWxpbmRlclRoZXRhIiwicmVzdHJpY3RlZFlhdyIsInJlc3RyaWN0ZWRQaXRjaCIsIm1pblpvb20iLCJmcyQxIiwiRXF1aWFuZ3VsYXJQcm9qZWN0aW9uIiwiU3BoZXJlR2VvbWV0cnkiLCJ3aWR0aFNlZ21lbnRzIiwiQU5HTEVfQ09SUkVDVElPTl9GT1JfQ0VOVEVSX0FMSUdOIiwibGF0SWR4Iiwic2luVGhldGEiLCJjb3NUaGV0YSIsInBoaSIsInNpblBoaSIsImNvc1BoaSIsIkVxdWlyZWN0UHJvamVjdGlvbiIsIlVuaWZvcm1GbG9hdCIsIlBsYW5lR2VvbWV0cnkiLCJ2cyQxIiwiTGl0dGxlUGxhbmV0UHJvamVjdGlvbiIsIlJFUEVBVCIsInVZYXciLCJ1UGl0Y2giLCJ1Wm9vbSIsIlVuaWZvcm1WZWN0b3I0QXJyYXkiLCJ1bmlmb3JtNGZ2IiwidmVjdG9yIiwiU3RlcmVvRXF1aVByb2plY3Rpb24iLCJfbW9kZSIsIm1vZGUiLCJsZWZ0RXllIiwicmlnaHRFeWUiLCJNT0RFIiwiTEVGVF9SSUdIVCIsInVUZXhTY2FsZU9mZnNldCIsIlRPUF9CT1RUT00iLCJ3aXRoTWV0aG9kcyIsImF0dHIiLCJwcm90byIsImdldE93blByb3BlcnR5TmFtZXMiLCJjaGFyQXQiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJhcmdzIiwiZ2V0dGVyRGVzY3JpcHRvciIsImdldCIsImdldFZhbGlkUHJvcHMiLCJwcm9wc09iaiIsInByb3BzIiwicHJvcE5hbWUiLCJWSUVXMzYwX01FVEhPRFMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/view360/dist/view360.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@egjs/react-view360/css/view360.min.css":
/*!**************************************************************!*\
  !*** ./node_modules/@egjs/react-view360/css/view360.min.css ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"c89f0a7d26bb\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVnanMvcmVhY3QtdmlldzM2MC9jc3MvdmlldzM2MC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9ibGVzLXJlbmRlci8uL25vZGVfbW9kdWxlcy9AZWdqcy9yZWFjdC12aWV3MzYwL2Nzcy92aWV3MzYwLm1pbi5jc3M/MmQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImM4OWYwYTdkMjZiYlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@egjs/react-view360/css/view360.min.css\n");

/***/ })

};
;