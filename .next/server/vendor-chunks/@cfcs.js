"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cfcs";
exports.ids = ["vendor-chunks/@cfcs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@cfcs/core/dist/cfcs.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/@cfcs/core/dist/cfcs.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Computed: () => (/* binding */ Computed),\n/* harmony export */   ComputedObserver: () => (/* binding */ ComputedObserver),\n/* harmony export */   Observe: () => (/* binding */ Observe),\n/* harmony export */   Observer: () => (/* binding */ Observer),\n/* harmony export */   Reactive: () => (/* binding */ Reactive),\n/* harmony export */   ReactiveSubscribe: () => (/* binding */ ReactiveSubscribe),\n/* harmony export */   adaptReactive: () => (/* binding */ adaptReactive),\n/* harmony export */   camelize: () => (/* binding */ camelize),\n/* harmony export */   computed: () => (/* binding */ computed),\n/* harmony export */   defineObservers: () => (/* binding */ defineObservers),\n/* harmony export */   findTarget: () => (/* binding */ findTarget),\n/* harmony export */   getObserver: () => (/* binding */ getObserver),\n/* harmony export */   getObservers: () => (/* binding */ getObservers),\n/* harmony export */   injectReactiveSubscribe: () => (/* binding */ injectReactiveSubscribe),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isObserver: () => (/* binding */ isObserver),\n/* harmony export */   isReactive: () => (/* binding */ isReactive),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   partialReactive: () => (/* binding */ partialReactive),\n/* harmony export */   reactive: () => (/* binding */ reactive),\n/* harmony export */   setObserver: () => (/* binding */ setObserver),\n/* harmony export */   withClassMethods: () => (/* binding */ withClassMethods),\n/* harmony export */   withReactiveMethods: () => (/* binding */ withReactiveMethods)\n/* harmony export */ });\n/* harmony import */ var _egjs_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @egjs/component */ \"(ssr)/./node_modules/@egjs/component/dist/component.esm.js\");\n/*\nCopyright (c) NAVER Crop.\nname: @cfcs/core\nlicense: MIT\nauthor: NAVER Crop.\nrepository: https://github.com/naver/cfcs\nversion: 0.0.24\n*/ \n/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */ /**\n * @hidden\n */ function keys(obj) {\n    return Object.keys(obj);\n}\n/**\n * @hidden\n */ function camelize(str) {\n    return str.replace(/[\\s-_]([a-z])/g, function(all, letter) {\n        return letter.toUpperCase();\n    });\n}\n/**\n * @hidden\n */ function isString(val) {\n    return typeof val === \"string\";\n}\n/**\n * @hidden\n */ function isObject(val) {\n    return typeof val === \"object\";\n}\n/**\n * @hidden\n */ function isFunction(val) {\n    return typeof val === \"function\";\n}\n/**\n * @hidden\n */ function findTarget(target) {\n    var el;\n    if (!target) {\n        return null;\n    }\n    if (isString(target)) {\n        el = document.querySelector(target);\n    } else if (target instanceof Element) {\n        el = target;\n    } else if (\"value\" in target || \"current\" in target) {\n        el = target.value || target.current;\n    }\n    return el;\n}\n/**\n * @description Sets the name of the class method to be exposed to the outside.\n * @category DOM\n * @return Property Decorator\n * @example\n * ```ts\n * import { withClassMethods } from \"@cfcs/core\";\n *\n * class YourFrameworkComponent {\n *   @withClassMethod(METHOD_NAMES)\n *   inst = new YourComponent();\n * }\n * ```\n */ function withClassMethods(methods) {\n    return function(prototype, memberName) {\n        methods.forEach(function(name) {\n            if (name in prototype) {\n                return;\n            }\n            prototype[name] = function() {\n                var _a;\n                var args = [];\n                for(var _i = 0; _i < arguments.length; _i++){\n                    args[_i] = arguments[_i];\n                }\n                var result = (_a = this[memberName])[name].apply(_a, args); // fix `this` type to return your own `class` instance to the instance using the decorator.\n                if (result === this[memberName]) {\n                    return this;\n                } else {\n                    return result;\n                }\n            };\n        });\n    };\n}\nvar OBSERVERS_PATH = \"__observers__\";\nvar COMPUTED_PATH = \"__computed__\";\nvar CFCS_DETECTED_DEPENDENCIES_VERSION = 1;\nvar CFCS_DETECTED_DEPENDENCIES = \"__CFCS_DETECTED_DEPENDENCIES__\";\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction getDetectedStack() {\n    // Version issues do not occur when you access the native object in the global.\n    Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};\n    var versionList = Object[CFCS_DETECTED_DEPENDENCIES];\n    versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];\n    return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];\n}\nfunction getCurrentDetected() {\n    var stack = getDetectedStack();\n    return stack[stack.length - 1];\n}\nfunction detectDependencies(host) {\n    var stack = getDetectedStack();\n    var observers = [];\n    var detected = {\n        host: host,\n        observers: observers,\n        push: function(observer) {\n            if (host !== observer && observers.indexOf(observer) === -1) {\n                observers.push(observer);\n            }\n        }\n    };\n    stack.push(detected);\n    return detected;\n}\nfunction endDetectDependencies() {\n    var stack = getDetectedStack();\n    return stack.pop();\n}\n/**\n * Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @see observe\n */ var Observer = /*#__PURE__*/ function() {\n    /**\n   *\n   */ function Observer(value) {\n        this._emitter = new _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this._current = value;\n    }\n    var __proto = Observer.prototype;\n    Object.defineProperty(__proto, \"current\", {\n        /**\n     * return the current value.\n     */ get: function() {\n            var currentDetected = getCurrentDetected();\n            currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);\n            return this._current;\n        },\n        set: function(value) {\n            this._setCurrent(value);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n   * When the current value changes, the callback function is called.\n   */ __proto.subscribe = function(callback) {\n        this.current;\n        this._emitter.on(\"update\", callback);\n        return this;\n    };\n    /**\n   * Cancel the registered subscription through callback.\n   */ __proto.unsubscribe = function(callback) {\n        this._emitter.off(\"update\", callback);\n        return this;\n    };\n    __proto._setCurrent = function(value) {\n        var prevValue = this._current;\n        var isUpdate = value !== prevValue;\n        this._current = value;\n        if (isUpdate) {\n            this._emitter.trigger(\"update\", value, prevValue);\n        }\n    };\n    /**\n   * @hidden\n   */ __proto.toString = function() {\n        return \"\".concat(this.current);\n    };\n    /**\n   * @hidden\n   */ __proto.valueOf = function() {\n        return this.current;\n    };\n    return Observer;\n}();\n/**\n * @category Reactive\n * @hidden\n */ var ComputedObserver = /*#__PURE__*/ function(_super) {\n    __extends(ComputedObserver, _super);\n    /**\n   * @description Creates a new computed observer from the values of other observers.\n   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.\n   * @param _computedCallback A function for observers to be computed.\n   */ function ComputedObserver(_computedCallback) {\n        var _this = _super.call(this) || this;\n        _this._computedCallback = _computedCallback;\n        _this._registered = [];\n        _this._onCheckUpdate = function() {\n            _this._setCurrent(_this.current);\n        };\n        _this._current = _this.current;\n        return _this;\n    }\n    var __proto = ComputedObserver.prototype;\n    Object.defineProperty(__proto, \"current\", {\n        get: function() {\n            var _this = this;\n            detectDependencies(this);\n            var value = this._computedCallback();\n            var results = endDetectDependencies();\n            this._registered.forEach(function(observer) {\n                observer.unsubscribe(_this._onCheckUpdate);\n            });\n            results.observers.forEach(function(observer) {\n                observer.subscribe(_this._onCheckUpdate);\n            });\n            this._registered = results.observers;\n            return value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ComputedObserver;\n}(Observer);\nfunction injectObserve(prototype, memberName, publicName) {\n    if (publicName === void 0) {\n        publicName = memberName;\n    }\n    var nextAttributes = {\n        configurable: true,\n        get: function() {\n            return getObserver(this, publicName).current;\n        },\n        set: function(value) {\n            getObserver(this, publicName, value).current = value;\n        }\n    };\n    Object.defineProperty(prototype, memberName, nextAttributes);\n    if (publicName !== memberName) {\n        Object.defineProperty(prototype, publicName, {\n            configurable: true,\n            get: function() {\n                return getObserver(this, publicName).current;\n            }\n        });\n    }\n}\n/**\n * @description `Observe` is a property decorator and converts the property into a `reactive state`. You can detect its status through `.subscribe`.\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n* ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  // The public name and state name are the same.\n  @Observe value1 = 1;\n  // If you want to set public name and private properties separately\n  @Observe(\"value2\") _value2 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\ninterface C\n```\n */ function Observe() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    if (args.length > 1) {\n        return injectObserve(args[0], args[1]);\n    }\n    return function(prototype, memberName) {\n        return injectObserve(prototype, memberName, args[0]);\n    };\n}\n/**\n * @hidden\n */ function Reactive() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    return Observe.apply(void 0, args);\n}\n/**\n * @hidden\n */ function injectReactiveSubscribe(object) {\n    object[\"subscribe\"] = function(name, callback) {\n        this[name];\n        getObserver(this, name).subscribe(callback);\n    };\n    object[\"unsubscribe\"] = function(name, callback) {\n        var _this = this;\n        if (!name) {\n            keys(getObservers(this)).forEach(function(observerName) {\n                _this.unsubscribe(observerName);\n            });\n            return;\n        }\n        if (!(name in this)) {\n            return;\n        }\n        getObserver(this, name).unsubscribe(callback);\n    };\n}\n/**\n * @description `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.\n * @category Reactive-Decorator\n * @see Observe\n * @example\n * ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  @Observe value1 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\n\ninterface Component extends ReactiveSubscribe<{\n  value1: number;\n  value2: number;\n}> {}\n\nconst component = new Component();\n\n// 1\nconsole.log(component.value1);\n\ncomponent.subscribe(\"value1\", nextValue => {\n  // When the change event occurs => (2, 2)\n  console.log(nextValue, component.value2);\n});\n```\n */ function ReactiveSubscribe(Constructor) {\n    var prototype = Constructor.prototype;\n    injectReactiveSubscribe(prototype);\n}\nfunction makeReactiveObject(setup, all) {\n    var result = isFunction(setup) ? setup() : setup;\n    var reactiveObject = {};\n    defineObservers(reactiveObject);\n    keys(result).forEach(function(name) {\n        var value = result[name];\n        if (isObserver(value)) {\n            setObserver(reactiveObject, name, value);\n        } else {\n            setObserver(reactiveObject, name, observe(value));\n        }\n        Observe(name)(reactiveObject, name);\n    });\n    injectReactiveSubscribe(reactiveObject);\n    return reactiveObject;\n}\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Makes all values into reactive objects.\n * @example\n * ```ts\n * import { reactive } from \"@cfcs/core\";\n *\n * const obj = reactive({\n *  value1: 1,\n *  value2: 2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * obj.value1 = 2;\n * ```\n */ function reactive(setup) {\n    return makeReactiveObject(setup);\n}\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Only the values to which observer is applied are objects to which reactive is applied.\n * @example\n * ```ts\n * import { partialReactive, observe } from \"@cfcs/core\";\n *\n * const value1 = observe(1);\n * const value2 = observe(2);\n * const obj = partialReactive({\n *  value1,\n *  value2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * value1.current = 2;\n * ```\n */ function partialReactive(setup) {\n    return makeReactiveObject(setup);\n}\n/**\n * @description Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @example\n * ```ts\n * import { observe } from \"@cfcs/core\";\n *\n * const ob1 = observe(1);\n *\n * ob1.subscribe(nextValue => {\n *   console.log(nextValue);\n * });\n *\n * ob1.current = 2;\n * ```\n */ function observe(defaultValue) {\n    return new Observer(defaultValue);\n}\n/**\n * @hidden\n */ function computed(computedCallback) {\n    return new ComputedObserver(computedCallback);\n}\n/**\n * @hidden\n */ function withReactiveMethods(ref, methods) {\n    var obj = {};\n    if (!methods) {\n        return obj;\n    }\n    methods.forEach(function(name) {\n        obj[name] = function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            var current = ref.current || ref.value;\n            return current[name].apply(current, args);\n        };\n    });\n    return obj;\n}\n/**\n * @hidden\n */ function defineObservers(instance) {\n    var observers = {};\n    Object.defineProperty(instance, OBSERVERS_PATH, {\n        get: function() {\n            return observers;\n        }\n    });\n    return observers;\n}\n/**\n * @hidden\n */ function getObservers(instance) {\n    var _a, _b;\n    if (!instance[OBSERVERS_PATH]) {\n        defineObservers(instance);\n    }\n    var observers = instance[OBSERVERS_PATH];\n    var computedList = (_b = (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b[COMPUTED_PATH];\n    if (computedList) {\n        computedList.forEach(function(name) {\n            if (!(name in observers) && name in instance) {\n                instance[name];\n            }\n        });\n    }\n    return observers;\n}\n/**\n * @hidden\n */ function getObserver(instance, name, defaultValue) {\n    var observers = getObservers(instance);\n    if (!observers[name]) {\n        observers[name] = observe(defaultValue);\n    }\n    return observers[name];\n}\n/**\n * @hidden\n */ function setObserver(instance, name, observer) {\n    var observers = getObservers(instance);\n    observers[name] = observer;\n}\n/**\n * @description Whether that object is an observer instance\n * @category Reactive\n */ function isObserver(val) {\n    return val && isObject(val) && \"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n/**\n * @description Whether the object is reactive\n * @category Reactive\n */ function isReactive(val) {\n    return val && !isObserver(val) && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n/**\n * @category Reactive\n * @hidden\n */ function adaptReactive(adapter, props) {\n    var objectAdapter = isFunction(adapter) ? {\n        setup: adapter\n    } : adapter;\n    function getProps() {\n        var _a, _b, _c, _d, _e;\n        return (_e = (_c = (_a = props === null || props === void 0 ? void 0 : props()) !== null && _a !== void 0 ? _a : (_b = objectAdapter.props) === null || _b === void 0 ? void 0 : _b.call(objectAdapter)) !== null && _c !== void 0 ? _c : (_d = objectAdapter.data) === null || _d === void 0 ? void 0 : _d.call(objectAdapter)) !== null && _e !== void 0 ? _e : {};\n    }\n    var eventEmitter = new _egjs_component__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    var mountedHooks = [];\n    var initHooks = [];\n    var destroyHooks = [];\n    var onHooks = [];\n    var instanceRef = {\n        current: null\n    };\n    var offHooksList = [];\n    var initialState = null;\n    var eventNames = [];\n    var methodNames = [];\n    var onMounted = function(callback) {\n        mountedHooks.push(callback);\n    };\n    var onInit = function(callback) {\n        initHooks.push(callback);\n    };\n    var onDestroy = function(callback) {\n        destroyHooks.push(callback);\n    };\n    var on = function(callback) {\n        onHooks.push(callback);\n    };\n    var emit = function(eventName) {\n        var params = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            params[_i - 1] = arguments[_i];\n        }\n        eventEmitter.trigger.apply(eventEmitter, __spreadArray([\n            eventName\n        ], params, false));\n    };\n    var setInitialState = function(state) {\n        initialState = state;\n    };\n    var setEvents = function(events) {\n        eventNames = events;\n    };\n    var setMethods = function(methods) {\n        methodNames = methods;\n    };\n    if (objectAdapter.setup) {\n        instanceRef.current = objectAdapter.setup({\n            getProps: getProps,\n            setInitialState: setInitialState,\n            setEvents: setEvents,\n            setMethods: setMethods,\n            onMounted: onMounted,\n            onDestroy: onDestroy,\n            onInit: onInit,\n            emit: emit,\n            on: on\n        }) || null;\n    }\n    if (objectAdapter.created) {\n        instanceRef.current = objectAdapter.created(getProps()) || null;\n    }\n    if (objectAdapter.events) {\n        setEvents(objectAdapter.events);\n    }\n    if (objectAdapter.state) {\n        setInitialState(objectAdapter.state);\n    }\n    if (objectAdapter.methods) {\n        setMethods(objectAdapter.methods);\n    }\n    if (objectAdapter.mounted) {\n        onMounted(objectAdapter.mounted);\n    }\n    if (objectAdapter.destroy) {\n        destroyHooks.push(objectAdapter.destroy);\n    }\n    if (objectAdapter.init) {\n        initHooks.push(objectAdapter.init);\n    }\n    if (objectAdapter.on) {\n        onHooks.push(function(instance, eventName, listener) {\n            var off = objectAdapter.on(instance, eventName, listener);\n            return function() {\n                var _a;\n                off && off();\n                (_a = objectAdapter.off) === null || _a === void 0 ? void 0 : _a.call(objectAdapter, instance, eventName, listener);\n            };\n        });\n    }\n    return {\n        events: function() {\n            return eventNames;\n        },\n        state: function() {\n            var inst = instanceRef.current;\n            if (initialState) {\n                return initialState;\n            }\n            if (inst) {\n                var observers_1 = getObservers(inst);\n                setInitialState(keys(observers_1).reduce(function(prev, cur) {\n                    prev[cur] = observers_1[cur].current;\n                    return prev;\n                }, {}));\n            }\n            return initialState || {};\n        },\n        instance: function() {\n            return instanceRef.current;\n        },\n        mounted: function() {\n            var props = getProps();\n            mountedHooks.forEach(function(hook) {\n                instanceRef.current = hook(props, instanceRef.current) || instanceRef.current;\n            });\n        },\n        init: function() {\n            // on events\n            var instance = instanceRef.current;\n            var props = getProps();\n            offHooksList = eventNames.map(function(eventName) {\n                var listener = function() {\n                    var _a;\n                    var params = [];\n                    for(var _i = 0; _i < arguments.length; _i++){\n                        params[_i] = arguments[_i];\n                    }\n                    (_a = eventEmitter).trigger.apply(_a, __spreadArray([\n                        eventName\n                    ], params, false));\n                };\n                var instance = instanceRef.current;\n                return onHooks.map(function(hook) {\n                    return hook(instance, eventName, listener);\n                }).filter(Boolean);\n            }); // init\n            initHooks.forEach(function(hook) {\n                hook(instance, props);\n            });\n        },\n        destroy: function() {\n            // off events\n            offHooksList.forEach(function(offHooks) {\n                offHooks.forEach(function(hook) {\n                    hook();\n                });\n            }); // destroy\n            eventEmitter.off();\n            var instance = instanceRef.current;\n            var props = getProps();\n            destroyHooks.forEach(function(hook) {\n                hook(instance, props);\n            });\n        },\n        methods: function() {\n            return withReactiveMethods(instanceRef, methodNames);\n        },\n        on: function(eventName, listener) {\n            eventEmitter.on(eventName, listener);\n        },\n        off: function(eventName, listener) {\n            eventEmitter.off(eventName, listener);\n        }\n    };\n}\n/**\n * @description `Computed` is a property decorator.\n * Changes in computed state values are also recognized according to changes in observers used within the getter function.\n * You can detect its status through `.subscribe`.\n * @hidden\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n * ```ts\nconst ob1 = observe(0);\nconst ob2 = observe(1);\n\n// When\n@ReactiveSubscribe\nclass TestComputed {\n    @Computed\n    get ob3() {\n        return ob1.current + ob2.current;\n    }\n}\nconst inst = new TestComputed();\n\ninst.subscribe(\"ob3\", ob3 => {\n  console.log(ob3);\n});\n\nob1.current = 1;\n```\n */ function Computed(prototype, memberName, attributes) {\n    var get = attributes.get;\n    function getComputed() {\n        var observers = getObservers(this);\n        if (!(memberName in observers)) {\n            observers[memberName] = computed(get.bind(this));\n        }\n        return getObserver(this, memberName).current;\n    }\n    var nextAttributes = {\n        configurable: true,\n        get: getComputed\n    };\n    if (COMPUTED_PATH in prototype) {\n        prototype[COMPUTED_PATH] || (prototype[COMPUTED_PATH] = []);\n        var computedList = prototype[COMPUTED_PATH];\n        if (computedList.indexOf(memberName) === -1) {\n            computedList.push(memberName);\n        }\n    }\n    Object.defineProperty(prototype, memberName, nextAttributes);\n    return nextAttributes;\n}\n //# sourceMappingURL=cfcs.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNmY3MvY29yZS9kaXN0L2NmY3MuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7O0FBT0EsR0FDd0M7QUFFeEM7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBQ0QsU0FBU0MsS0FBS0MsR0FBRztJQUNmLE9BQU9DLE9BQU9GLElBQUksQ0FBQ0M7QUFDckI7QUFDQTs7Q0FFQyxHQUVELFNBQVNFLFNBQVNDLEdBQUc7SUFDbkIsT0FBT0EsSUFBSUMsT0FBTyxDQUFDLGtCQUFrQixTQUFVQyxHQUFHLEVBQUVDLE1BQU07UUFDeEQsT0FBT0EsT0FBT0MsV0FBVztJQUMzQjtBQUNGO0FBQ0E7O0NBRUMsR0FFRCxTQUFTQyxTQUFTQyxHQUFHO0lBQ25CLE9BQU8sT0FBT0EsUUFBUTtBQUN4QjtBQUNBOztDQUVDLEdBRUQsU0FBU0MsU0FBU0QsR0FBRztJQUNuQixPQUFPLE9BQU9BLFFBQVE7QUFDeEI7QUFDQTs7Q0FFQyxHQUVELFNBQVNFLFdBQVdGLEdBQUc7SUFDckIsT0FBTyxPQUFPQSxRQUFRO0FBQ3hCO0FBRUE7O0NBRUMsR0FFRCxTQUFTRyxXQUFXQyxNQUFNO0lBQ3hCLElBQUlDO0lBRUosSUFBSSxDQUFDRCxRQUFRO1FBQ1gsT0FBTztJQUNUO0lBRUEsSUFBSUwsU0FBU0ssU0FBUztRQUNwQkMsS0FBS0MsU0FBU0MsYUFBYSxDQUFDSDtJQUM5QixPQUFPLElBQUlBLGtCQUFrQkksU0FBUztRQUNwQ0gsS0FBS0Q7SUFDUCxPQUFPLElBQUksV0FBV0EsVUFBVSxhQUFhQSxRQUFRO1FBQ25EQyxLQUFLRCxPQUFPSyxLQUFLLElBQUlMLE9BQU9NLE9BQU87SUFDckM7SUFFQSxPQUFPTDtBQUNUO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUVELFNBQVNNLGlCQUFpQkMsT0FBTztJQUMvQixPQUFPLFNBQVVDLFNBQVMsRUFBRUMsVUFBVTtRQUNwQ0YsUUFBUUcsT0FBTyxDQUFD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bmRlci8uL25vZGVfbW9kdWxlcy9AY2Zjcy9jb3JlL2Rpc3QvY2Zjcy5lc20uanM/NGEzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSBOQVZFUiBDcm9wLlxubmFtZTogQGNmY3MvY29yZVxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENyb3AuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvY2Zjc1xudmVyc2lvbjogMC4wLjI0XG4qL1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZWdqcy9jb21wb25lbnQnO1xuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBrZXlzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHMtX10oW2Etel0pL2csIGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kVGFyZ2V0KHRhcmdldCkge1xuICB2YXIgZWw7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIGVsID0gdGFyZ2V0O1xuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiB0YXJnZXQgfHwgXCJjdXJyZW50XCIgaW4gdGFyZ2V0KSB7XG4gICAgZWwgPSB0YXJnZXQudmFsdWUgfHwgdGFyZ2V0LmN1cnJlbnQ7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyBtZXRob2QgdG8gYmUgZXhwb3NlZCB0byB0aGUgb3V0c2lkZS5cbiAqIEBjYXRlZ29yeSBET01cbiAqIEByZXR1cm4gUHJvcGVydHkgRGVjb3JhdG9yXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHdpdGhDbGFzc01ldGhvZHMgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuICpcbiAqIGNsYXNzIFlvdXJGcmFtZXdvcmtDb21wb25lbnQge1xuICogICBAd2l0aENsYXNzTWV0aG9kKE1FVEhPRF9OQU1FUylcbiAqICAgaW5zdCA9IG5ldyBZb3VyQ29tcG9uZW50KCk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiB3aXRoQ2xhc3NNZXRob2RzKG1ldGhvZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIG1lbWJlck5hbWUpIHtcbiAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lIGluIHByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gKF9hID0gdGhpc1ttZW1iZXJOYW1lXSlbbmFtZV0uYXBwbHkoX2EsIGFyZ3MpOyAvLyBmaXggYHRoaXNgIHR5cGUgdG8gcmV0dXJuIHlvdXIgb3duIGBjbGFzc2AgaW5zdGFuY2UgdG8gdGhlIGluc3RhbmNlIHVzaW5nIHRoZSBkZWNvcmF0b3IuXG5cblxuICAgICAgICBpZiAocmVzdWx0ID09PSB0aGlzW21lbWJlck5hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIE9CU0VSVkVSU19QQVRIID0gXCJfX29ic2VydmVyc19fXCI7XG52YXIgQ09NUFVURURfUEFUSCA9IFwiX19jb21wdXRlZF9fXCI7XG52YXIgQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfVkVSU0lPTiA9IDE7XG52YXIgQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVMgPSBcIl9fQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfX1wiO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICBhcltpXSA9IGZyb21baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5mdW5jdGlvbiBnZXREZXRlY3RlZFN0YWNrKCkge1xuICAvLyBWZXJzaW9uIGlzc3VlcyBkbyBub3Qgb2NjdXIgd2hlbiB5b3UgYWNjZXNzIHRoZSBuYXRpdmUgb2JqZWN0IGluIHRoZSBnbG9iYWwuXG4gIE9iamVjdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU10gPSBPYmplY3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNdIHx8IHt9O1xuICB2YXIgdmVyc2lvbkxpc3QgPSBPYmplY3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNdO1xuICB2ZXJzaW9uTGlzdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19WRVJTSU9OXSA9IHZlcnNpb25MaXN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX1ZFUlNJT05dIHx8IFtdO1xuICByZXR1cm4gdmVyc2lvbkxpc3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfVkVSU0lPTl07XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50RGV0ZWN0ZWQoKSB7XG4gIHZhciBzdGFjayA9IGdldERldGVjdGVkU3RhY2soKTtcbiAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZWN0RGVwZW5kZW5jaWVzKGhvc3QpIHtcbiAgdmFyIHN0YWNrID0gZ2V0RGV0ZWN0ZWRTdGFjaygpO1xuICB2YXIgb2JzZXJ2ZXJzID0gW107XG4gIHZhciBkZXRlY3RlZCA9IHtcbiAgICBob3N0OiBob3N0LFxuICAgIG9ic2VydmVyczogb2JzZXJ2ZXJzLFxuICAgIHB1c2g6IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgaWYgKGhvc3QgIT09IG9ic2VydmVyICYmIG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSA9PT0gLTEpIHtcbiAgICAgICAgb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhY2sucHVzaChkZXRlY3RlZCk7XG4gIHJldHVybiBkZXRlY3RlZDtcbn1cbmZ1bmN0aW9uIGVuZERldGVjdERlcGVuZGVuY2llcygpIHtcbiAgdmFyIHN0YWNrID0gZ2V0RGV0ZWN0ZWRTdGFjaygpO1xuICByZXR1cm4gc3RhY2sucG9wKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG11dGFibGUgcmVmIG9iamVjdC4gWW91IGNhbiBhY2Nlc3MgdGhlIGAuY3VycmVudGAgdmFsdWUgYW5kIGRldGVjdCB0aGUgdmFsdWUgY2hhbmdlIHRocm91Z2ggYC5zdWJzY3JpYmVgLlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAc2VlIG9ic2VydmVcbiAqL1xuXG52YXIgT2JzZXJ2ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE9ic2VydmVyKHZhbHVlKSB7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBDb21wb25lbnQoKTtcbiAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG4gIH1cblxuICB2YXIgX19wcm90byA9IE9ic2VydmVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY3VycmVudFwiLCB7XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnREZXRlY3RlZCA9IGdldEN1cnJlbnREZXRlY3RlZCgpO1xuICAgICAgY3VycmVudERldGVjdGVkID09PSBudWxsIHx8IGN1cnJlbnREZXRlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERldGVjdGVkLnB1c2godGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRDdXJyZW50KHZhbHVlKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIGN1cnJlbnQgdmFsdWUgY2hhbmdlcywgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICovXG5cbiAgX19wcm90by5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLmN1cnJlbnQ7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKFwidXBkYXRlXCIsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2FuY2VsIHRoZSByZWdpc3RlcmVkIHN1YnNjcmlwdGlvbiB0aHJvdWdoIGNhbGxiYWNrLlxuICAgKi9cblxuXG4gIF9fcHJvdG8udW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihcInVwZGF0ZVwiLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLl9zZXRDdXJyZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHByZXZWYWx1ZSA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgdmFyIGlzVXBkYXRlID0gdmFsdWUgIT09IHByZXZWYWx1ZTtcbiAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG5cbiAgICBpZiAoaXNVcGRhdGUpIHtcbiAgICAgIHRoaXMuX2VtaXR0ZXIudHJpZ2dlcihcInVwZGF0ZVwiLCB2YWx1ZSwgcHJldlZhbHVlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAaGlkZGVuXG4gICAqL1xuXG5cbiAgX19wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5jdXJyZW50KTtcbiAgfTtcbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICovXG5cblxuICBfX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2ZXI7XG59KCk7XG5cbi8qKlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAaGlkZGVuXG4gKi9cblxudmFyIENvbXB1dGVkT2JzZXJ2ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ29tcHV0ZWRPYnNlcnZlciwgX3N1cGVyKTtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgbmV3IGNvbXB1dGVkIG9ic2VydmVyIGZyb20gdGhlIHZhbHVlcyBvZiBvdGhlciBvYnNlcnZlcnMuXG4gICAqIEl0IGlzIHJlYWQtb25seSBhbmQgaWYgeW91IGNoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIG9ic2VydmVyIHVzZWQgaW5zaWRlIHRoZSBjYWxsYmFjaywgaXRzIHZhbHVlIHdpbGwgYmUgYXV0b21hdGljYWxseSB1cGRhdGVkLlxuICAgKiBAcGFyYW0gX2NvbXB1dGVkQ2FsbGJhY2sgQSBmdW5jdGlvbiBmb3Igb2JzZXJ2ZXJzIHRvIGJlIGNvbXB1dGVkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENvbXB1dGVkT2JzZXJ2ZXIoX2NvbXB1dGVkQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuX2NvbXB1dGVkQ2FsbGJhY2sgPSBfY29tcHV0ZWRDYWxsYmFjaztcbiAgICBfdGhpcy5fcmVnaXN0ZXJlZCA9IFtdO1xuXG4gICAgX3RoaXMuX29uQ2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fc2V0Q3VycmVudChfdGhpcy5jdXJyZW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2N1cnJlbnQgPSBfdGhpcy5jdXJyZW50O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gQ29tcHV0ZWRPYnNlcnZlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImN1cnJlbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgZGV0ZWN0RGVwZW5kZW5jaWVzKHRoaXMpO1xuXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9jb21wdXRlZENhbGxiYWNrKCk7XG5cbiAgICAgIHZhciByZXN1bHRzID0gZW5kRGV0ZWN0RGVwZW5kZW5jaWVzKCk7XG5cbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWQuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIudW5zdWJzY3JpYmUoX3RoaXMuX29uQ2hlY2tVcGRhdGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdHMub2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLnN1YnNjcmliZShfdGhpcy5fb25DaGVja1VwZGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSByZXN1bHRzLm9ic2VydmVycztcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIENvbXB1dGVkT2JzZXJ2ZXI7XG59KE9ic2VydmVyKTtcblxuZnVuY3Rpb24gaW5qZWN0T2JzZXJ2ZShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHB1YmxpY05hbWUpIHtcbiAgaWYgKHB1YmxpY05hbWUgPT09IHZvaWQgMCkge1xuICAgIHB1YmxpY05hbWUgPSBtZW1iZXJOYW1lO1xuICB9XG5cbiAgdmFyIG5leHRBdHRyaWJ1dGVzID0ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRPYnNlcnZlcih0aGlzLCBwdWJsaWNOYW1lKS5jdXJyZW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGdldE9ic2VydmVyKHRoaXMsIHB1YmxpY05hbWUsIHZhbHVlKS5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBuZXh0QXR0cmlidXRlcyk7XG5cbiAgaWYgKHB1YmxpY05hbWUgIT09IG1lbWJlck5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwdWJsaWNOYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldE9ic2VydmVyKHRoaXMsIHB1YmxpY05hbWUpLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIGBPYnNlcnZlYCBpcyBhIHByb3BlcnR5IGRlY29yYXRvciBhbmQgY29udmVydHMgdGhlIHByb3BlcnR5IGludG8gYSBgcmVhY3RpdmUgc3RhdGVgLiBZb3UgY2FuIGRldGVjdCBpdHMgc3RhdHVzIHRocm91Z2ggYC5zdWJzY3JpYmVgLlxuICogQGNhdGVnb3J5IFJlYWN0aXZlLURlY29yYXRvclxuICogQHNlZSBSZWFjdGl2ZVN1YnNjcmliZVxuICogQGV4YW1wbGVcbiogYGBgdHNcbmltcG9ydCB7IFJlYWN0aXZlU3Vic2NyaWJlLCBPYnNlcnZlIH0gZnJvbSBcIkBjZmNzL2NvcmVcIjtcblxuQFJlYWN0aXZlU3Vic2NyaWJlXG5jbGFzcyBDb21wb25lbnQge1xuICAvLyBUaGUgcHVibGljIG5hbWUgYW5kIHN0YXRlIG5hbWUgYXJlIHRoZSBzYW1lLlxuICBAT2JzZXJ2ZSB2YWx1ZTEgPSAxO1xuICAvLyBJZiB5b3Ugd2FudCB0byBzZXQgcHVibGljIG5hbWUgYW5kIHByaXZhdGUgcHJvcGVydGllcyBzZXBhcmF0ZWx5XG4gIEBPYnNlcnZlKFwidmFsdWUyXCIpIF92YWx1ZTIgPSAxO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnZhbHVlMSA9IDI7XG4gICAgfSk7XG4gIH1cbn1cbmludGVyZmFjZSBDXG5gYGBcbiAqL1xuXG5cbmZ1bmN0aW9uIE9ic2VydmUoKSB7XG4gIHZhciBhcmdzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGluamVjdE9ic2VydmUoYXJnc1swXSwgYXJnc1sxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgbWVtYmVyTmFtZSkge1xuICAgIHJldHVybiBpbmplY3RPYnNlcnZlKHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgYXJnc1swXSk7XG4gIH07XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBSZWFjdGl2ZSgpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIHJldHVybiBPYnNlcnZlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGluamVjdFJlYWN0aXZlU3Vic2NyaWJlKG9iamVjdCkge1xuICBvYmplY3RbXCJzdWJzY3JpYmVcIl0gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzW25hbWVdO1xuICAgIGdldE9ic2VydmVyKHRoaXMsIG5hbWUpLnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH07XG5cbiAgb2JqZWN0W1widW5zdWJzY3JpYmVcIl0gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBrZXlzKGdldE9ic2VydmVycyh0aGlzKSkuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXJOYW1lKSB7XG4gICAgICAgIF90aGlzLnVuc3Vic2NyaWJlKG9ic2VydmVyTmFtZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIShuYW1lIGluIHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0T2JzZXJ2ZXIodGhpcywgbmFtZSkudW5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9O1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gYFJlYWN0aXZlU3Vic2NyaWJlYCBpcyBhIGNsYXNzIGRlY29yYXRvciBhbmQgYWRkcyBgLnN1YnNjcmliZWAgYW5kIGAudW5zdWJzY3JpYmVgIG1ldGhvZHMuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmUtRGVjb3JhdG9yXG4gKiBAc2VlIE9ic2VydmVcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuaW1wb3J0IHsgUmVhY3RpdmVTdWJzY3JpYmUsIE9ic2VydmUgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuXG5AUmVhY3RpdmVTdWJzY3JpYmVcbmNsYXNzIENvbXBvbmVudCB7XG4gIEBPYnNlcnZlIHZhbHVlMSA9IDE7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMudmFsdWUxID0gMjtcbiAgICB9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ29tcG9uZW50IGV4dGVuZHMgUmVhY3RpdmVTdWJzY3JpYmU8e1xuICB2YWx1ZTE6IG51bWJlcjtcbiAgdmFsdWUyOiBudW1iZXI7XG59PiB7fVxuXG5jb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8vIDFcbmNvbnNvbGUubG9nKGNvbXBvbmVudC52YWx1ZTEpO1xuXG5jb21wb25lbnQuc3Vic2NyaWJlKFwidmFsdWUxXCIsIG5leHRWYWx1ZSA9PiB7XG4gIC8vIFdoZW4gdGhlIGNoYW5nZSBldmVudCBvY2N1cnMgPT4gKDIsIDIpXG4gIGNvbnNvbGUubG9nKG5leHRWYWx1ZSwgY29tcG9uZW50LnZhbHVlMik7XG59KTtcbmBgYFxuICovXG5cbmZ1bmN0aW9uIFJlYWN0aXZlU3Vic2NyaWJlKENvbnN0cnVjdG9yKSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGluamVjdFJlYWN0aXZlU3Vic2NyaWJlKHByb3RvdHlwZSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZWFjdGl2ZU9iamVjdChzZXR1cCwgYWxsKSB7XG4gIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uKHNldHVwKSA/IHNldHVwKCkgOiBzZXR1cDtcbiAgdmFyIHJlYWN0aXZlT2JqZWN0ID0ge307XG4gIGRlZmluZU9ic2VydmVycyhyZWFjdGl2ZU9iamVjdCk7XG4gIGtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gcmVzdWx0W25hbWVdO1xuXG4gICAgaWYgKGlzT2JzZXJ2ZXIodmFsdWUpKSB7XG4gICAgICBzZXRPYnNlcnZlcihyZWFjdGl2ZU9iamVjdCwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRPYnNlcnZlcihyZWFjdGl2ZU9iamVjdCwgbmFtZSwgb2JzZXJ2ZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIE9ic2VydmUobmFtZSkocmVhY3RpdmVPYmplY3QsIG5hbWUpO1xuICB9KTtcbiAgaW5qZWN0UmVhY3RpdmVTdWJzY3JpYmUocmVhY3RpdmVPYmplY3QpO1xuICByZXR1cm4gcmVhY3RpdmVPYmplY3Q7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBNYWtlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgb2JqZWN0IG9yIGZ1bmN0aW9uIGEgcmVhY3RpdmUgb2JqZWN0LlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAcGFyYW0gc2V0dXAgLSBUaGUgdGFyZ2V0IG9iamVjdCBvciBmdW5jdGlvbiB0byB3aGljaCByZWFjdGl2ZSBpcyBhcHBsaWVkXG4gKiBAcmV0dXJucyBNYWtlcyBhbGwgdmFsdWVzIGludG8gcmVhY3RpdmUgb2JqZWN0cy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcmVhY3RpdmUgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuICpcbiAqIGNvbnN0IG9iaiA9IHJlYWN0aXZlKHtcbiAqICB2YWx1ZTE6IDEsXG4gKiAgdmFsdWUyOiAyLFxuICogfSk7XG4gKlxuICogb2JqLnN1YnNjcmliZShcInZhbHVlMVwiLCB2YWx1ZTEgPT4ge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZTEpO1xuICogfSk7XG4gKiBvYmoudmFsdWUxID0gMjtcbiAqIGBgYFxuICovXG5cblxuZnVuY3Rpb24gcmVhY3RpdmUoc2V0dXApIHtcbiAgcmV0dXJuIG1ha2VSZWFjdGl2ZU9iamVjdChzZXR1cCk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBNYWtlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgb2JqZWN0IG9yIGZ1bmN0aW9uIGEgcmVhY3RpdmUgb2JqZWN0LlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAcGFyYW0gc2V0dXAgLSBUaGUgdGFyZ2V0IG9iamVjdCBvciBmdW5jdGlvbiB0byB3aGljaCByZWFjdGl2ZSBpcyBhcHBsaWVkXG4gKiBAcmV0dXJucyBPbmx5IHRoZSB2YWx1ZXMgdG8gd2hpY2ggb2JzZXJ2ZXIgaXMgYXBwbGllZCBhcmUgb2JqZWN0cyB0byB3aGljaCByZWFjdGl2ZSBpcyBhcHBsaWVkLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwYXJ0aWFsUmVhY3RpdmUsIG9ic2VydmUgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuICpcbiAqIGNvbnN0IHZhbHVlMSA9IG9ic2VydmUoMSk7XG4gKiBjb25zdCB2YWx1ZTIgPSBvYnNlcnZlKDIpO1xuICogY29uc3Qgb2JqID0gcGFydGlhbFJlYWN0aXZlKHtcbiAqICB2YWx1ZTEsXG4gKiAgdmFsdWUyLFxuICogfSk7XG4gKlxuICogb2JqLnN1YnNjcmliZShcInZhbHVlMVwiLCB2YWx1ZTEgPT4ge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZTEpO1xuICogfSk7XG4gKiB2YWx1ZTEuY3VycmVudCA9IDI7XG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsUmVhY3RpdmUoc2V0dXApIHtcbiAgcmV0dXJuIG1ha2VSZWFjdGl2ZU9iamVjdChzZXR1cCk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgbXV0YWJsZSByZWYgb2JqZWN0LiBZb3UgY2FuIGFjY2VzcyB0aGUgYC5jdXJyZW50YCB2YWx1ZSBhbmQgZGV0ZWN0IHRoZSB2YWx1ZSBjaGFuZ2UgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG4gKlxuICogY29uc3Qgb2IxID0gb2JzZXJ2ZSgxKTtcbiAqXG4gKiBvYjEuc3Vic2NyaWJlKG5leHRWYWx1ZSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKG5leHRWYWx1ZSk7XG4gKiB9KTtcbiAqXG4gKiBvYjEuY3VycmVudCA9IDI7XG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBvYnNlcnZlKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKGRlZmF1bHRWYWx1ZSk7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBjb21wdXRlZChjb21wdXRlZENhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgQ29tcHV0ZWRPYnNlcnZlcihjb21wdXRlZENhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gd2l0aFJlYWN0aXZlTWV0aG9kcyhyZWYsIG1ldGhvZHMpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICghbWV0aG9kcykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBvYmpbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gcmVmLmN1cnJlbnQgfHwgcmVmLnZhbHVlO1xuICAgICAgcmV0dXJuIGN1cnJlbnRbbmFtZV0uYXBwbHkoY3VycmVudCwgYXJncyk7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVPYnNlcnZlcnMoaW5zdGFuY2UpIHtcbiAgdmFyIG9ic2VydmVycyA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIE9CU0VSVkVSU19QQVRILCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXJzO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYnNlcnZlcnM7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBnZXRPYnNlcnZlcnMoaW5zdGFuY2UpIHtcbiAgdmFyIF9hLCBfYjtcblxuICBpZiAoIWluc3RhbmNlW09CU0VSVkVSU19QQVRIXSkge1xuICAgIGRlZmluZU9ic2VydmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICB2YXIgb2JzZXJ2ZXJzID0gaW5zdGFuY2VbT0JTRVJWRVJTX1BBVEhdO1xuICB2YXIgY29tcHV0ZWRMaXN0ID0gKF9iID0gKF9hID0gaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbmNlLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbQ09NUFVURURfUEFUSF07XG5cbiAgaWYgKGNvbXB1dGVkTGlzdCkge1xuICAgIGNvbXB1dGVkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoIShuYW1lIGluIG9ic2VydmVycykgJiYgbmFtZSBpbiBpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvYnNlcnZlcnM7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBnZXRPYnNlcnZlcihpbnN0YW5jZSwgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciBvYnNlcnZlcnMgPSBnZXRPYnNlcnZlcnMoaW5zdGFuY2UpO1xuXG4gIGlmICghb2JzZXJ2ZXJzW25hbWVdKSB7XG4gICAgb2JzZXJ2ZXJzW25hbWVdID0gb2JzZXJ2ZShkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIG9ic2VydmVyc1tuYW1lXTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIHNldE9ic2VydmVyKGluc3RhbmNlLCBuYW1lLCBvYnNlcnZlcikge1xuICB2YXIgb2JzZXJ2ZXJzID0gZ2V0T2JzZXJ2ZXJzKGluc3RhbmNlKTtcbiAgb2JzZXJ2ZXJzW25hbWVdID0gb2JzZXJ2ZXI7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIHRoYXQgb2JqZWN0IGlzIGFuIG9ic2VydmVyIGluc3RhbmNlXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqL1xuXG5mdW5jdGlvbiBpc09ic2VydmVyKHZhbCkge1xuICByZXR1cm4gdmFsICYmIGlzT2JqZWN0KHZhbCkgJiYgXCJjdXJyZW50XCIgaW4gdmFsICYmIFwic3Vic2NyaWJlXCIgaW4gdmFsICYmIFwidW5zdWJzY3JpYmVcIiBpbiB2YWw7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIHRoZSBvYmplY3QgaXMgcmVhY3RpdmVcbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZVxuICovXG5cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgIWlzT2JzZXJ2ZXIodmFsKSAmJiBcInN1YnNjcmliZVwiIGluIHZhbCAmJiBcInVuc3Vic2NyaWJlXCIgaW4gdmFsO1xufVxuXG4vKipcbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZVxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGFkYXB0UmVhY3RpdmUoYWRhcHRlciwgcHJvcHMpIHtcbiAgdmFyIG9iamVjdEFkYXB0ZXIgPSBpc0Z1bmN0aW9uKGFkYXB0ZXIpID8ge1xuICAgIHNldHVwOiBhZGFwdGVyXG4gIH0gOiBhZGFwdGVyO1xuXG4gIGZ1bmN0aW9uIGdldFByb3BzKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG5cbiAgICByZXR1cm4gKF9lID0gKF9jID0gKF9hID0gcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IG9iamVjdEFkYXB0ZXIucHJvcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKG9iamVjdEFkYXB0ZXIpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSBvYmplY3RBZGFwdGVyLmRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKG9iamVjdEFkYXB0ZXIpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB7fTtcbiAgfVxuXG4gIHZhciBldmVudEVtaXR0ZXIgPSBuZXcgQ29tcG9uZW50KCk7XG4gIHZhciBtb3VudGVkSG9va3MgPSBbXTtcbiAgdmFyIGluaXRIb29rcyA9IFtdO1xuICB2YXIgZGVzdHJveUhvb2tzID0gW107XG4gIHZhciBvbkhvb2tzID0gW107XG4gIHZhciBpbnN0YW5jZVJlZiA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG4gIHZhciBvZmZIb29rc0xpc3QgPSBbXTtcbiAgdmFyIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gIHZhciBldmVudE5hbWVzID0gW107XG4gIHZhciBtZXRob2ROYW1lcyA9IFtdO1xuXG4gIHZhciBvbk1vdW50ZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBtb3VudGVkSG9va3MucHVzaChjYWxsYmFjayk7XG4gIH07XG5cbiAgdmFyIG9uSW5pdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGluaXRIb29rcy5wdXNoKGNhbGxiYWNrKTtcbiAgfTtcblxuICB2YXIgb25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgZGVzdHJveUhvb2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xuXG4gIHZhciBvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIG9uSG9va3MucHVzaChjYWxsYmFjayk7XG4gIH07XG5cbiAgdmFyIGVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG5cbiAgICBldmVudEVtaXR0ZXIudHJpZ2dlci5hcHBseShldmVudEVtaXR0ZXIsIF9fc3ByZWFkQXJyYXkoW2V2ZW50TmFtZV0sIHBhcmFtcywgZmFsc2UpKTtcbiAgfTtcblxuICB2YXIgc2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gc3RhdGU7XG4gIH07XG5cbiAgdmFyIHNldEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICBldmVudE5hbWVzID0gZXZlbnRzO1xuICB9O1xuXG4gIHZhciBzZXRNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcbiAgICBtZXRob2ROYW1lcyA9IG1ldGhvZHM7XG4gIH07XG5cbiAgaWYgKG9iamVjdEFkYXB0ZXIuc2V0dXApIHtcbiAgICBpbnN0YW5jZVJlZi5jdXJyZW50ID0gb2JqZWN0QWRhcHRlci5zZXR1cCh7XG4gICAgICBnZXRQcm9wczogZ2V0UHJvcHMsXG4gICAgICBzZXRJbml0aWFsU3RhdGU6IHNldEluaXRpYWxTdGF0ZSxcbiAgICAgIHNldEV2ZW50czogc2V0RXZlbnRzLFxuICAgICAgc2V0TWV0aG9kczogc2V0TWV0aG9kcyxcbiAgICAgIG9uTW91bnRlZDogb25Nb3VudGVkLFxuICAgICAgb25EZXN0cm95OiBvbkRlc3Ryb3ksXG4gICAgICBvbkluaXQ6IG9uSW5pdCxcbiAgICAgIGVtaXQ6IGVtaXQsXG4gICAgICBvbjogb25cbiAgICB9KSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKG9iamVjdEFkYXB0ZXIuY3JlYXRlZCkge1xuICAgIGluc3RhbmNlUmVmLmN1cnJlbnQgPSBvYmplY3RBZGFwdGVyLmNyZWF0ZWQoZ2V0UHJvcHMoKSkgfHwgbnVsbDtcbiAgfVxuXG4gIGlmIChvYmplY3RBZGFwdGVyLmV2ZW50cykge1xuICAgIHNldEV2ZW50cyhvYmplY3RBZGFwdGVyLmV2ZW50cyk7XG4gIH1cblxuICBpZiAob2JqZWN0QWRhcHRlci5zdGF0ZSkge1xuICAgIHNldEluaXRpYWxTdGF0ZShvYmplY3RBZGFwdGVyLnN0YXRlKTtcbiAgfVxuXG4gIGlmIChvYmplY3RBZGFwdGVyLm1ldGhvZHMpIHtcbiAgICBzZXRNZXRob2RzKG9iamVjdEFkYXB0ZXIubWV0aG9kcyk7XG4gIH1cblxuICBpZiAob2JqZWN0QWRhcHRlci5tb3VudGVkKSB7XG4gICAgb25Nb3VudGVkKG9iamVjdEFkYXB0ZXIubW91bnRlZCk7XG4gIH1cblxuICBpZiAob2JqZWN0QWRhcHRlci5kZXN0cm95KSB7XG4gICAgZGVzdHJveUhvb2tzLnB1c2gob2JqZWN0QWRhcHRlci5kZXN0cm95KTtcbiAgfVxuXG4gIGlmIChvYmplY3RBZGFwdGVyLmluaXQpIHtcbiAgICBpbml0SG9va3MucHVzaChvYmplY3RBZGFwdGVyLmluaXQpO1xuICB9XG5cbiAgaWYgKG9iamVjdEFkYXB0ZXIub24pIHtcbiAgICBvbkhvb2tzLnB1c2goZnVuY3Rpb24gKGluc3RhbmNlLCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgb2ZmID0gb2JqZWN0QWRhcHRlci5vbihpbnN0YW5jZSwgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgb2ZmICYmIG9mZigpO1xuICAgICAgICAoX2EgPSBvYmplY3RBZGFwdGVyLm9mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob2JqZWN0QWRhcHRlciwgaW5zdGFuY2UsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXZlbnROYW1lcztcbiAgICB9LFxuICAgIHN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5zdCA9IGluc3RhbmNlUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIG9ic2VydmVyc18xID0gZ2V0T2JzZXJ2ZXJzKGluc3QpO1xuICAgICAgICBzZXRJbml0aWFsU3RhdGUoa2V5cyhvYnNlcnZlcnNfMSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgICAgICBwcmV2W2N1cl0gPSBvYnNlcnZlcnNfMVtjdXJdLmN1cnJlbnQ7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGUgfHwge307XG4gICAgfSxcbiAgICBpbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlUmVmLmN1cnJlbnQ7XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvcHMgPSBnZXRQcm9wcygpO1xuICAgICAgbW91bnRlZEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgaW5zdGFuY2VSZWYuY3VycmVudCA9IGhvb2socHJvcHMsIGluc3RhbmNlUmVmLmN1cnJlbnQpIHx8IGluc3RhbmNlUmVmLmN1cnJlbnQ7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIG9uIGV2ZW50c1xuICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VSZWYuY3VycmVudDtcbiAgICAgIHZhciBwcm9wcyA9IGdldFByb3BzKCk7XG4gICAgICBvZmZIb29rc0xpc3QgPSBldmVudE5hbWVzLm1hcChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcGFyYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKF9hID0gZXZlbnRFbWl0dGVyKS50cmlnZ2VyLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtldmVudE5hbWVdLCBwYXJhbXMsIGZhbHNlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VSZWYuY3VycmVudDtcbiAgICAgICAgcmV0dXJuIG9uSG9va3MubWFwKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2soaW5zdGFuY2UsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB9KTsgLy8gaW5pdFxuXG4gICAgICBpbml0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICBob29rKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIG9mZiBldmVudHNcbiAgICAgIG9mZkhvb2tzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChvZmZIb29rcykge1xuICAgICAgICBvZmZIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgaG9vaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBkZXN0cm95XG5cbiAgICAgIGV2ZW50RW1pdHRlci5vZmYoKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlUmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgcHJvcHMgPSBnZXRQcm9wcygpO1xuICAgICAgZGVzdHJveUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgaG9vayhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBtZXRob2RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gd2l0aFJlYWN0aXZlTWV0aG9kcyhpbnN0YW5jZVJlZiwgbWV0aG9kTmFtZXMpO1xuICAgIH0sXG4gICAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICBldmVudEVtaXR0ZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICBldmVudEVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gYENvbXB1dGVkYCBpcyBhIHByb3BlcnR5IGRlY29yYXRvci5cbiAqIENoYW5nZXMgaW4gY29tcHV0ZWQgc3RhdGUgdmFsdWVzIGFyZSBhbHNvIHJlY29nbml6ZWQgYWNjb3JkaW5nIHRvIGNoYW5nZXMgaW4gb2JzZXJ2ZXJzIHVzZWQgd2l0aGluIHRoZSBnZXR0ZXIgZnVuY3Rpb24uXG4gKiBZb3UgY2FuIGRldGVjdCBpdHMgc3RhdHVzIHRocm91Z2ggYC5zdWJzY3JpYmVgLlxuICogQGhpZGRlblxuICogQGNhdGVnb3J5IFJlYWN0aXZlLURlY29yYXRvclxuICogQHNlZSBSZWFjdGl2ZVN1YnNjcmliZVxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG5jb25zdCBvYjEgPSBvYnNlcnZlKDApO1xuY29uc3Qgb2IyID0gb2JzZXJ2ZSgxKTtcblxuLy8gV2hlblxuQFJlYWN0aXZlU3Vic2NyaWJlXG5jbGFzcyBUZXN0Q29tcHV0ZWQge1xuICAgIEBDb21wdXRlZFxuICAgIGdldCBvYjMoKSB7XG4gICAgICAgIHJldHVybiBvYjEuY3VycmVudCArIG9iMi5jdXJyZW50O1xuICAgIH1cbn1cbmNvbnN0IGluc3QgPSBuZXcgVGVzdENvbXB1dGVkKCk7XG5cbmluc3Quc3Vic2NyaWJlKFwib2IzXCIsIG9iMyA9PiB7XG4gIGNvbnNvbGUubG9nKG9iMyk7XG59KTtcblxub2IxLmN1cnJlbnQgPSAxO1xuYGBgXG4gKi9cblxuZnVuY3Rpb24gQ29tcHV0ZWQocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBnZXQgPSBhdHRyaWJ1dGVzLmdldDtcblxuICBmdW5jdGlvbiBnZXRDb21wdXRlZCgpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gZ2V0T2JzZXJ2ZXJzKHRoaXMpO1xuXG4gICAgaWYgKCEobWVtYmVyTmFtZSBpbiBvYnNlcnZlcnMpKSB7XG4gICAgICBvYnNlcnZlcnNbbWVtYmVyTmFtZV0gPSBjb21wdXRlZChnZXQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9ic2VydmVyKHRoaXMsIG1lbWJlck5hbWUpLmN1cnJlbnQ7XG4gIH1cblxuICB2YXIgbmV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZ2V0Q29tcHV0ZWRcbiAgfTtcblxuICBpZiAoQ09NUFVURURfUEFUSCBpbiBwcm90b3R5cGUpIHtcbiAgICBwcm90b3R5cGVbQ09NUFVURURfUEFUSF0gfHwgKHByb3RvdHlwZVtDT01QVVRFRF9QQVRIXSA9IFtdKTtcbiAgICB2YXIgY29tcHV0ZWRMaXN0ID0gcHJvdG90eXBlW0NPTVBVVEVEX1BBVEhdO1xuXG4gICAgaWYgKGNvbXB1dGVkTGlzdC5pbmRleE9mKG1lbWJlck5hbWUpID09PSAtMSkge1xuICAgICAgY29tcHV0ZWRMaXN0LnB1c2gobWVtYmVyTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgbmV4dEF0dHJpYnV0ZXMpO1xuICByZXR1cm4gbmV4dEF0dHJpYnV0ZXM7XG59XG5cbmV4cG9ydCB7IENvbXB1dGVkLCBDb21wdXRlZE9ic2VydmVyLCBPYnNlcnZlLCBPYnNlcnZlciwgUmVhY3RpdmUsIFJlYWN0aXZlU3Vic2NyaWJlLCBhZGFwdFJlYWN0aXZlLCBjYW1lbGl6ZSwgY29tcHV0ZWQsIGRlZmluZU9ic2VydmVycywgZmluZFRhcmdldCwgZ2V0T2JzZXJ2ZXIsIGdldE9ic2VydmVycywgaW5qZWN0UmVhY3RpdmVTdWJzY3JpYmUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc09ic2VydmVyLCBpc1JlYWN0aXZlLCBpc1N0cmluZywga2V5cywgb2JzZXJ2ZSwgcGFydGlhbFJlYWN0aXZlLCByZWFjdGl2ZSwgc2V0T2JzZXJ2ZXIsIHdpdGhDbGFzc01ldGhvZHMsIHdpdGhSZWFjdGl2ZU1ldGhvZHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNmY3MuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsImtleXMiLCJvYmoiLCJPYmplY3QiLCJjYW1lbGl6ZSIsInN0ciIsInJlcGxhY2UiLCJhbGwiLCJsZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsImlzU3RyaW5nIiwidmFsIiwiaXNPYmplY3QiLCJpc0Z1bmN0aW9uIiwiZmluZFRhcmdldCIsInRhcmdldCIsImVsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiRWxlbWVudCIsInZhbHVlIiwiY3VycmVudCIsIndpdGhDbGFzc01ldGhvZHMiLCJtZXRob2RzIiwicHJvdG90eXBlIiwibWVtYmVyTmFtZSIsImZvckVhY2giLCJuYW1lIiwiX2EiLCJhcmdzIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyZXN1bHQiLCJhcHBseSIsIk9CU0VSVkVSU19QQVRIIiwiQ09NUFVURURfUEFUSCIsIkNGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX1ZFUlNJT04iLCJDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFUyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwiaSIsImwiLCJhciIsInNsaWNlIiwiY29uY2F0IiwiZ2V0RGV0ZWN0ZWRTdGFjayIsInZlcnNpb25MaXN0IiwiZ2V0Q3VycmVudERldGVjdGVkIiwic3RhY2siLCJkZXRlY3REZXBlbmRlbmNpZXMiLCJob3N0Iiwib2JzZXJ2ZXJzIiwiZGV0ZWN0ZWQiLCJwdXNoIiwib2JzZXJ2ZXIiLCJpbmRleE9mIiwiZW5kRGV0ZWN0RGVwZW5kZW5jaWVzIiwicG9wIiwiT2JzZXJ2ZXIiLCJfZW1pdHRlciIsIl9jdXJyZW50IiwiX19wcm90byIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiY3VycmVudERldGVjdGVkIiwic2V0IiwiX3NldEN1cnJlbnQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJvbiIsInVuc3Vic2NyaWJlIiwib2ZmIiwicHJldlZhbHVlIiwiaXNVcGRhdGUiLCJ0cmlnZ2VyIiwidG9TdHJpbmciLCJ2YWx1ZU9mIiwiQ29tcHV0ZWRPYnNlcnZlciIsIl9zdXBlciIsIl9jb21wdXRlZENhbGxiYWNrIiwiX3RoaXMiLCJfcmVnaXN0ZXJlZCIsIl9vbkNoZWNrVXBkYXRlIiwicmVzdWx0cyIsImluamVjdE9ic2VydmUiLCJwdWJsaWNOYW1lIiwibmV4dEF0dHJpYnV0ZXMiLCJnZXRPYnNlcnZlciIsIk9ic2VydmUiLCJSZWFjdGl2ZSIsImluamVjdFJlYWN0aXZlU3Vic2NyaWJlIiwib2JqZWN0IiwiZ2V0T2JzZXJ2ZXJzIiwib2JzZXJ2ZXJOYW1lIiwiUmVhY3RpdmVTdWJzY3JpYmUiLCJDb25zdHJ1Y3RvciIsIm1ha2VSZWFjdGl2ZU9iamVjdCIsInNldHVwIiwicmVhY3RpdmVPYmplY3QiLCJkZWZpbmVPYnNlcnZlcnMiLCJpc09ic2VydmVyIiwic2V0T2JzZXJ2ZXIiLCJvYnNlcnZlIiwicmVhY3RpdmUiLCJwYXJ0aWFsUmVhY3RpdmUiLCJkZWZhdWx0VmFsdWUiLCJjb21wdXRlZCIsImNvbXB1dGVkQ2FsbGJhY2siLCJ3aXRoUmVhY3RpdmVNZXRob2RzIiwicmVmIiwiaW5zdGFuY2UiLCJfYiIsImNvbXB1dGVkTGlzdCIsImlzUmVhY3RpdmUiLCJhZGFwdFJlYWN0aXZlIiwiYWRhcHRlciIsInByb3BzIiwib2JqZWN0QWRhcHRlciIsImdldFByb3BzIiwiX2MiLCJfZCIsIl9lIiwiZGF0YSIsImV2ZW50RW1pdHRlciIsIm1vdW50ZWRIb29rcyIsImluaXRIb29rcyIsImRlc3Ryb3lIb29rcyIsIm9uSG9va3MiLCJpbnN0YW5jZVJlZiIsIm9mZkhvb2tzTGlzdCIsImluaXRpYWxTdGF0ZSIsImV2ZW50TmFtZXMiLCJtZXRob2ROYW1lcyIsIm9uTW91bnRlZCIsIm9uSW5pdCIsIm9uRGVzdHJveSIsImVtaXQiLCJldmVudE5hbWUiLCJwYXJhbXMiLCJzZXRJbml0aWFsU3RhdGUiLCJzdGF0ZSIsInNldEV2ZW50cyIsImV2ZW50cyIsInNldE1ldGhvZHMiLCJjcmVhdGVkIiwibW91bnRlZCIsImRlc3Ryb3kiLCJpbml0IiwibGlzdGVuZXIiLCJpbnN0Iiwib2JzZXJ2ZXJzXzEiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwiaG9vayIsIm1hcCIsImZpbHRlciIsIkJvb2xlYW4iLCJvZmZIb29rcyIsIkNvbXB1dGVkIiwiYXR0cmlidXRlcyIsImdldENvbXB1dGVkIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cfcs/core/dist/cfcs.esm.js\n");

/***/ })

};
;